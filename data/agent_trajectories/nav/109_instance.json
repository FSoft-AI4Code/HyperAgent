{"system_prompt": "You are an expert in finding all relevant information insider a code repository to answer the query from a planner agent. You have the full access to the codebase of the project you're working on to resolve a query from a planner. Your tools help you navigate the codebase and find relevant information. Use them wisely to explore the repository and find the information you need to resolve the query. \nIf your first attempts do not provide enough information to resolve the query, try different tools or use tool with different parameters to get the information you need.\nThink carefully before making a decision. Your tools can provide valuable insights to help you resolve the query. Once you have collected relevant information, you can provide a response to the query with Final Answer, put any code snippet into that summary. Do not repeat your actions (IMPORTANT!)\n\nTOP Priorities:\n    1. Understanding the query, think step-by-step carefully before decision (Important!) to propose actions to collect necessary information to resolve the query.\n    2. Do not repeat your actions (IMPORTANT!).\n    3. Try to use the tools to get the information you need. DO NOT GUESS or refuse to response the planner's request. Planner request is always correct. You may only see part of the information, but the planner sees the whole picture. \n    4. If one tool does not find the information you need, try another tool. If you open a file, but do not find the information you need, reopen with different start_line and end_line or keywords.\n    5. Your summarization should be relevant to the query (provide code snippet if it's required by query), do not provide unnecessary information.\n    \nImportant Tips:\n    1. Try to combine different tools to seek related information to the query inside the project\n    2. get_all_references: Use this tool to get all references to a symbol in the codebase. This will help you understand how the symbol is used in the codebase.\n    3. get_all_symbols: Use this tool to get all symbols in the target file, it should be used with a keyword.\n    4. get_folder_structure: Use this tool to get the structure of the target folder. This will help you understand the organization of the codebase, and find the relevant files to use other tools.\n    5. code_search: Use this tool to search for symbol name if you know the exact name of the symbol, this is useful to find the definition if you're not familiar with codebase yet.\n    6. go_to_definition: Use this tool to navigate to the definition of an identifier, for example self._print in a class.\n    7. open_file: Use this tool to open a file in the codebase, this is useful to read the partial content of the file (40 lines). Should be used with a keyword or limited start_line and end_line. If your previous open does not show all the information, next turn you can open the same file with different start_line and end_line (incrementally scrolling).\n\nYou have access to the following tools:\n\ncode_search: Useful when you want to find all matched primary symbols (function, class name) in a repository. You want to quickly find a class or function like 'some_function' function., args: {'names': {'description': 'The names of the identifiers to search', 'items': {'type': 'string'}, 'title': 'Names', 'type': 'array'}}\ngo_to_definition: Useful when you want to find the definition of an identifier inside a code snippet that you saw. This can be applied into variable., args: {'word': {'title': 'Word', 'type': 'string'}, 'relative_path': {'title': 'Relative Path', 'type': 'string'}, 'line': {'title': 'Line', 'type': 'integer'}, 'verbose': {'title': 'Verbose', 'default': True, 'type': 'boolean'}}\nfind_all_references: Given a code snippet that contains target symbol, find all references of this symbol inside the project., args: {'word': {'title': 'Word', 'type': 'string'}, 'relative_file_path': {'title': 'Relative File Path', 'type': 'string'}, 'line': {'title': 'Line', 'type': 'integer'}, 'num_results': {'title': 'Num Results', 'default': 10, 'type': 'integer'}}\nget_all_symbols: Useful when you want to find all symbols (functions, classes, methods) of source files. If you want to look for a specific keyword, specify it, otherwise if you want to see all the symbols, do not provide the keyword. Prioritize using keyword to shorten the search., args: {'path_to_file': {'title': 'Path To File', 'type': 'string'}, 'keyword': {'title': 'Keyword', 'type': 'string'}}\nget_folder_structure: Useful when you want to explore the tree structure of a folder, good for initial exploration with knowing the parent folder name. Remember to provide the relative path correctly.\n    , args: {'relative_path': {'title': 'Relative Path', 'type': 'string'}}\nopen_file: Useful when you want to open a file inside a repo. If you have a keyword in mind, you can use it to search the keyword in the file. Otherwise, you can specify the start and end line to view the content of the file. The number of lines to show is limited at 20 for example (100:120) or (240:260).\n    , args: {'relative_file_path': {'title': 'Relative File Path', 'type': 'string'}, 'start_line': {'title': 'Start Line', 'type': 'integer'}, 'end_line': {'title': 'End Line', 'type': 'integer'}, 'keywords': {'title': 'Keywords', 'default': [], 'type': 'array', 'items': {'type': 'string'}}, 'preview_size': {'title': 'Preview Size', 'default': 10, 'type': 'integer'}, 'max_num_result': {'title': 'Max Num Result', 'default': 5, 'type': 'integer'}}\n\nUse a json blob to specify a tool by providing an action key (tool name) and an action_input key (tool input).\n\nValid \"action\" values: \"Final Answer\" or code_search, go_to_definition, find_all_references, get_all_symbols, get_folder_structure, open_file\n\nProvide only ONE action per $JSON_BLOB, as shown:\n\n```\n{\n  \"action\": $TOOL_NAME,\n  \"action_input\": $INPUT\n}\n```\n\nFollow this format:\n\nThought: consider previous and subsequent steps, notes down some useful information (like code snippet) from observation\nAction:\n```\n$JSON_BLOB\n```\nObservation: action result\n... (repeat Thought/Action/Observation N times)\nThought: I know what to respond\nAction:\n```\n{\n  \"action\": \"Final Answer\",\n  \"action_input\": \"Final response to human\"\n}\n```\n\nBegin! Reminder to ALWAYS respond with a valid json blob of a single action. Use tools if necessary. Respond directly if you have gathered enough information from the repository. Format is Action:```$JSON_BLOB```then Observation:. Thought: ", "human_message": "Objective: Please provide the source code for:\n1. `sympy.physics.continuum_mechanics.beam.Beam` class definition, specifically focusing on the `shear_force` method.\n2. `sympy.printing.latex._print_SingularityFunction` method definition.\nAgent scratchpad:\nThis was your previous work (but I haven't seen any of it! I only see what you return as final answer):\nThought: To resolve this query, I will need to explore the SymPy codebase to find the relevant source code for the requested classes and methods.\n\nAction:\n```\n{\n  \"action\": \"get_folder_structure\",\n  \"action_input\": {\n    \"relative_path\": \"sympy\"\n  }\n}\n```\n\n\nObservation: The tree structure of sympy is: \nsympy\n\u251c\u2500\u2500 algebras\n\u251c\u2500\u2500 assumptions\n\u251c\u2500\u2500 benchmarks\n\u251c\u2500\u2500 calculus\n\u251c\u2500\u2500 categories\n\u251c\u2500\u2500 codegen\n\u251c\u2500\u2500 combinatorics\n\u251c\u2500\u2500 concrete\n\u251c\u2500\u2500 core\n\u251c\u2500\u2500 crypto\n\u251c\u2500\u2500 diffgeom\n\u251c\u2500\u2500 discrete\n\u251c\u2500\u2500 external\n\u251c\u2500\u2500 functions\n\u251c\u2500\u2500 galgebra.py\n\u251c\u2500\u2500 geometry\n\u251c\u2500\u2500 holonomic\n\u251c\u2500\u2500 integrals\n\u251c\u2500\u2500 interactive\n\u251c\u2500\u2500 liealgebras\n\u251c\u2500\u2500 logic\n\u251c\u2500\u2500 matrices\n\u251c\u2500\u2500 multipledispatch\n\u251c\u2500\u2500 ntheory\n\u251c\u2500\u2500 parsing\n\u251c\u2500\u2500 physics\n\u251c\u2500\u2500 plotting\n\u251c\u2500\u2500 polys\n\u251c\u2500\u2500 printing\n\u251c\u2500\u2500 sandbox\n\u251c\u2500\u2500 series\n\u251c\u2500\u2500 sets\n\u251c\u2500\u2500 simplify\n\u251c\u2500\u2500 solvers\n\u251c\u2500\u2500 stats\n\u251c\u2500\u2500 strategies\n\u251c\u2500\u2500 tensor\n\u251c\u2500\u2500 testing\n\u251c\u2500\u2500 this.py\n\u251c\u2500\u2500 unify\n\u251c\u2500\u2500 utilities\n\u251c\u2500\u2500 vector\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 abc.py\n\u251c\u2500\u2500 conftest.py\n\u251c\u2500\u2500 release.py\n\u2514\u2500\u2500 __pycache__\n\n41 directories, 6 files\nThought:Okay, let's try to resolve this query step-by-step:\n\nAction:\n```\n{\n  \"action\": \"open_file\",\n  \"action_input\": {\n    \"relative_file_path\": \"sympy/physics/continuum_mechanics/beam.py\",\n    \"start_line\": 1,\n    \"end_line\": 200,\n    \"keywords\": [\"Beam\"]\n  }\n}\n```\n\n\nObservation: The content of sympy/physics/continuum_mechanics/beam.pywith keyword ['Beam'] is: \n22 class Beam:\n23     \"\"\"\n24     A Beam is a structural element that is capable of withstanding load\n25     primarily by resisting against bending. Beams are characterized by\n26     their cross sectional profile(Second moment of area), their length\n27     and their material.\n28 \n29     .. note::\n30        While solving a beam bending problem, a user should choose its\n31        own sign convention and should stick to it. The results will\n32        automatically follow the chosen sign convention. However, the\n33        chosen sign convention must respect the rule that, on the positive\n34        side of beam's axis (in respect to current section), a loading force\n35        giving positive shear yields a negative moment, as below (the\n36        curved arrow shows the positive moment and rotation):\n37 \n38     .. image:: allowed-sign-conventions.png\n39 \n40     Examples\n41     ========\n42     There is a beam of length 4 meters. A constant distributed load of 6 N/m\n43     is applied from half of the beam till the end. There are two simple supports\n44     below the beam, one at the starting point and another at the ending point\n45     of the beam. The deflection of the beam at the end is restricted.\n46 \n47     Using the sign convention of downwards forces being positive.\n48 \n49     >>> from sympy.physics.continuum_mechanics.beam import Beam\n50     >>> from sympy import symbols, Piecewise\n51     >>> E, I = symbols('E, I')\n52     >>> R1, R2 = symbols('R1, R2')\n53     >>> b = Beam(4, E, I)\n54     >>> b.apply_load(R1, 0, -1)\n55     >>> b.apply_load(6, 2, 0)\n56     >>> b.apply_load(R2, 4, -1)\n57     >>> b.bc_deflection = [(0, 0), (4, 0)]\n58     >>> b.boundary_conditions\n59     {'deflection': [(0, 0), (4, 0)], 'slope': []}\n60     >>> b.load\n61     R1*SingularityFunction(x, 0, -1) + R2*SingularityFunction(x, 4, -1) + 6*SingularityFunction(x, 2, 0)\n62     >>> b.solve_for_reaction_loads(R1, R2)\n63     >>> b.load\n64     -3*SingularityFunction(x, 0, -1) + 6*SingularityFunction(x, 2, 0) - 9*SingularityFunction(x, 4, -1)\n65     >>> b.shear_force()\n66     3*SingularityFunction(x, 0, 0) - 6*SingularityFunction(x, 2, 1) + 9*SingularityFunction(x, 4, 0)\n67     >>> b.bending_moment()\n68     3*SingularityFunction(x, 0, 1) - 3*SingularityFunction(x, 2, 2) + 9*SingularityFunction(x, 4, 1)\n69     >>> b.slope()\n70     (-3*SingularityFunction(x, 0, 2)/2 + SingularityFunction(x, 2, 3) - 9*SingularityFunction(x, 4, 2)/2 + 7)/(E*I)\n71     >>> b.deflection()\n72     (7*x - SingularityFunction(x, 0, 3)/2 + SingularityFunction(x, 2, 4)/4 - 3*SingularityFunction(x, 4, 3)/2)/(E*I)\n73     >>> b.deflection().rewrite(Piecewise)\n74     (7*x - Piecewise((x**3, x > 0), (0, True))/2\n75          - 3*Piecewise(((x - 4)**3, x - 4 > 0), (0, True))/2\n76          + Piecewise(((x - 2)**4, x - 2 > 0), (0, True))/4)/(E*I)\n77     \"\"\"\n78 \n79     def __init__(self, length, elastic_modulus, second_moment, area=Symbol('A'), variable=Symbol('x'), base_char='C'):\n80         \"\"\"Initializes the class.\n81 \n82         Parameters\n83         ==========\n84 \n85         length : Sympifyable\n86             A Symbol or value representing the Beam's length.\n87 \n88         elastic_modulus : Sympifyable\n89             A SymPy expression representing the Beam's Modulus of Elasticity.\n90             It is a measure of the stiffness of the Beam material. It can\n91             also be a continuous function of position along the beam.\n92 \n93         second_moment : Sympifyable or Geometry object\n94             Describes the cross-section of the beam via a SymPy expression\n95             representing the Beam's second moment of area. It is a geometrical\n96             property of an area which reflects how its points are distributed\n97             with respect to its neutral axis. It can also be a continuous\n98             function of position along the beam. Alternatively ``second_moment``\n99             can be a shape object such as a ``Polygon`` from the geometry module\n100             representing the shape of the cross-section of the beam. In such cases,\n101             it is assumed that the x-axis of the shape object is aligned with the\n102             bending axis of the beam. The second moment of area will be computed\n103             from the shape object internally.\n104 \n105         area : Symbol/float\n106             Represents the cross-section area of beam\n107 \n108         variable : Symbol, optional\n109             A Symbol object that will be used as the variable along the beam\n110             while representing the load, shear, moment, slope and deflection\n111             curve. By default, it is set to ``Symbol('x')``.\n112 \n113         base_char : String, optional\n114             A String that will be used as base character to generate sequential\n115             symbols for integration constants in cases where boundary conditions\n116             are not sufficient to solve them.\n117         \"\"\"\n118         self.length = length\n119         self.elastic_modulus = elastic_modulus\n120         if isinstance(second_moment, GeometryEntity):\n121             self.cross_section = second_moment\n122         else:\n123             self.cross_section = None\n124             self.second_moment = second_moment\n125         self.variable = variable\n126         self._base_char = base_char\n127         self._boundary_conditions = {'deflection': [], 'slope': []}\n128         self._load = 0\n129         self._area = area\n130         self._applied_supports = []\n131         self._support_as_loads = []\n132         self._applied_loads = []\n133         self._reaction_loads = {}\n134         self._composite_type = None\n135         self._hinge_position = None\n136 \n137     def __str__(self):\n138         shape_description = self._cross_section if self._cross_section else self._second_moment\n139         str_sol = 'Beam({}, {}, {})'.format(sstr(self._length), sstr(self._elastic_modulus), sstr(shape_description))\n140         return str_sol\n141 \n142     @property\n143     def reaction_loads(self):\n144         \"\"\" Returns the reaction forces in a dictionary.\"\"\"\n145         return self._reaction_loads\n146 \n147     @property\n148     def length(self):\n149         \"\"\"Length of the Beam.\"\"\"\n150         return self._length\n151 \n152     @length.setter\n153     def length(self, l):\n154         self._length = sympify(l)\n155 \n156     @property\n157     def area(self):\n158         \"\"\"Cross-sectional area of the Beam. \"\"\"\n159         return self._area\n160 \n161     @area.setter\n162     def area(self, a):\n163         self._area = sympify(a)\n164 \n165     @property\n166     def variable(self):\n167         \"\"\"\n168         A symbol that can be used as a variable along the length of the beam\n169         while representing load distribution, shear force curve, bending\n170         moment, slope curve and the deflection curve. By default, it is set\n171         to ``Symbol('x')``, but this property is mutable.\n172 \n173         Examples\n174         ========\n175 \n176         >>> from sympy.physics.continuum_mechanics.beam import Beam\n177         >>> from sympy import symbols\n178         >>> E, I, A = symbols('E, I, A')\n179         >>> x, y, z = symbols('x, y, z')\n180         >>> b = Beam(4, E, I)\n181         >>> b.variable\n182         x\n183         >>> b.variable = y\n184         >>> b.variable\n185         y\n186         >>> b = Beam(4, E, I, A, z)\n187         >>> b.variable\n188         z\n189         \"\"\"\n190         return self._variable\n191 \n192     @variable.setter\n193     def variable(self, v):\n194         if isinstance(v, Symbol):\n195             self._variable = v\n196         else:\n197             raise TypeError(\"\"\"The variable should be a Symbol object.\"\"\")\n198 \n199     @property\n200     def elastic_modulus(self):\n201         \"\"\"Young's Modulus of the Beam. \"\"\"\n202         return self._elastic_modulus\n203 \n204     @elastic_modulus.setter\n205     def elastic_modulus(self, e):\n206         self._elastic_modulus = sympify(e)\n207 \n208     @property\n209     def second_moment(self):\n210         \"\"\"Second moment of area of the Beam. \"\"\"\n211         return self._second_moment\n212 \n213     @second_moment.setter\n214     def second_moment(self, i):\n215         self._cross_section = None\n216         if isinstance(i, GeometryEntity):\n217             raise ValueError(\"To update cross-section geometry use `cross_section` attribute\")\n218         else:\n219             self._second_moment = sympify(i)\n220 \n221     @property\n222     def cross_section(self):\n223         \"\"\"Cross-section of the beam\"\"\"\n224         return self._cross_section\n225 \n226     @cross_section.setter\n227     def cross_section(self, s):\n228         if s:\n229             self._second_moment = s.second_moment_of_area()[0]\n230         self._cross_section = s\n231 \n232     @property\n233     def boundary_conditions(self):\n234         \"\"\"\n235         Returns a dictionary of boundary conditions applied on the beam.\n236         The dictionary has three keywords namely moment, slope and deflection.\n237         The value of each keyword is a list of tuple, where each tuple\n238         contains location and value of a boundary condition in the format\n239         (location, value).\n240 \n241         Examples\n242         ========\n243         There is a beam of length 4 meters. The bending moment at 0 should be 4\n244         and at 4 it should be 0. The slope of the beam should be 1 at 0. The\n245         deflection should be 2 at 0.\n246 \n247         >>> from sympy.physics.continuum_mechanics.beam import Beam\n248         >>> from sympy import symbols\n249         >>> E, I = symbols('E, I')\n250         >>> b = Beam(4, E, I)\n251         >>> b.bc_deflection = [(0, 2)]\n252         >>> b.bc_slope = [(0, 1)]\n253         >>> b.boundary_conditions\n254         {'deflection': [(0, 2)], 'slope': [(0, 1)]}\n255 \n256         Here the deflection of the beam should be ``2`` at ``0``.\n257         Similarly, the slope of the beam should be ``1`` at ``0``.\n258         \"\"\"\n259         return self._boundary_conditions\n260 \n261     @property\n262     def bc_slope(self):\n263         return self._boundary_conditions['slope']\n264 \n265     @bc_slope.setter\n266     def bc_slope(self, s_bcs):\n267         self._boundary_conditions['slope'] = s_bcs\n268 \n269     @property\n270     def bc_deflection(self):\n271         return self._boundary_conditions['deflection']\n272 \n273     @bc_deflection.setter\n274     def bc_deflection(self, d_bcs):\n275         self._boundary_conditions['deflection'] = d_bcs\n276 \n277     def join(self, beam, via=\"fixed\"):\n278         \"\"\"\n279         This method joins two beams to make a new composite beam system.\n280         Passed Beam class instance is attached to the right end of calling\n281         object. This method can be used to form beams having Discontinuous\n282         values of Elastic modulus or Second moment.\n283 \n284         Parameters\n285         ==========\n286         beam : Beam class object\n287             The Beam object which would be connected to the right of calling\n288             object.\n289         via : String\n290             States the way two Beam object would get connected\n291             - For axially fixed Beams, via=\"fixed\"\n292             - For Beams connected via hinge, via=\"hinge\"\n293 \n294         Examples\n295         ========\n296         There is a cantilever beam of length 4 meters. For first 2 meters\n297         its moment of inertia is `1.5*I` and `I` for the other end.\n298         A pointload of magnitude 4 N is applied from the top at its free end.\n299 \n300         >>> from sympy.physics.continuum_mechanics.beam import Beam\n301         >>> from sympy import symbols\n302         >>> E, I = symbols('E, I')\n303         >>> R1, R2 = symbols('R1, R2')\n304         >>> b1 = Beam(2, E, 1.5*I)\n305         >>> b2 = Beam(2, E, I)\n306         >>> b = b1.join(b2, \"fixed\")\n307         >>> b.apply_load(20, 4, -1)\n308         >>> b.apply_load(R1, 0, -1)\n309         >>> b.apply_load(R2, 0, -2)\n310         >>> b.bc_slope = [(0, 0)]\n311         >>> b.bc_deflection = [(0, 0)]\n312         >>> b.solve_for_reaction_loads(R1, R2)\n313         >>> b.load\n314         80*SingularityFunction(x, 0, -2) - 20*SingularityFunction(x, 0, -1) + 20*SingularityFunction(x, 4, -1)\n315         >>> b.slope()\n316         (-((-80*SingularityFunction(x, 0, 1) + 10*SingularityFunction(x, 0, 2) - 10*SingularityFunction(x, 4, 2))/I + 120/I)/E + 80.0/(E*I))*SingularityFunction(x, 2, 0)\n317         - 0.666666666666667*(-80*SingularityFunction(x, 0, 1) + 10*SingularityFunction(x, 0, 2) - 10*SingularityFunction(x, 4, 2))*SingularityFunction(x, 0, 0)/(E*I)\n318         + 0.666666666666667*(-80*SingularityFunction(x, 0, 1) + 10*SingularityFunction(x, 0, 2) - 10*SingularityFunction(x, 4, 2))*SingularityFunction(x, 2, 0)/(E*I)\n319         \"\"\"\n320         x = self.variable\n321         E = self.elastic_modulus\n322         new_length = self.length + beam.length\n323         if self.second_moment != beam.second_moment:\n324             new_second_moment = Piecewise((self.second_moment, x<=self.length),\n325                                     (beam.second_moment, x<=new_length))\n326         else:\n327             new_second_moment = self.second_moment\n328 \n329         if via == \"fixed\":\n330             new_beam = Beam(new_length, E, new_second_moment, x)\n331             new_beam._composite_type = \"fixed\"\n332             return new_beam\n333 \n334         if via == \"hinge\":\n335             new_beam = Beam(new_length, E, new_second_moment, x)\n336             new_beam._composite_type = \"hinge\"\n337             new_beam._hinge_position = self.length\n338             return new_beam\n339 \n340     def apply_support(self, loc, type=\"fixed\"):\n341         \"\"\"\n342         This method applies support to a particular beam object.\n343 \n344         Parameters\n345         ==========\n346         loc : Sympifyable\n347             Location of point at which support is applied.\n348         type : String\n349             Determines type of Beam support applied. To apply support structure\n350             with\n351             - zero degree of freedom, type = \"fixed\"\n352             - one degree of freedom, type = \"pin\"\n353             - two degrees of freedom, type = \"roller\"\n354 \n355         Examples\n356         ========\n357         There is a beam of length 30 meters. A moment of magnitude 120 Nm is\n358         applied in the clockwise direction at the end of the beam. A pointload\n359         of magnitude 8 N is applied from the top of the beam at the starting\n360         point. There are two simple supports below the beam. One at the end\n361         and another one at a distance of 10 meters from the start. The\n362         deflection is restricted at both the supports.\n363 \n364         Using the sign convention of upward forces and clockwise moment\n365         being positive.\n366 \n367         >>> from sympy.physics.continuum_mechanics.beam import Beam\n368         >>> from sympy import symbols\n369         >>> E, I = symbols('E, I')\n370         >>> b = Beam(30, E, I)\n371         >>> b.apply_support(10, 'roller')\n372         >>> b.apply_support(30, 'roller')\n373         >>> b.apply_load(-8, 0, -1)\n374         >>> b.apply_load(120, 30, -2)\n375         >>> R_10, R_30 = symbols('R_10, R_30')\n376         >>> b.solve_for_reaction_loads(R_10, R_30)\n377         >>> b.load\n378         -8*SingularityFunction(x, 0, -1) + 6*SingularityFunction(x, 10, -1)\n379         + 120*SingularityFunction(x, 30, -2) + 2*SingularityFunction(x, 30, -1)\n380         >>> b.slope()\n381         (-4*SingularityFunction(x, 0, 2) + 3*SingularityFunction(x, 10, 2)\n382             + 120*SingularityFunction(x, 30, 1) + SingularityFunction(x, 30, 2) + 4000/3)/(E*I)\n383         \"\"\"\n384         loc = sympify(loc)\n385         self._applied_supports.append((loc, type))\n386         if type == \"pin\" or type == \"roller\":\n387             reaction_load = Symbol('R_'+str(loc))\n388             self.apply_load(reaction_load, loc, -1)\n389             self.bc_deflection.append((loc, 0))\n390         else:\n391             reaction_load = Symbol('R_'+str(loc))\n392             reaction_moment = Symbol('M_'+str(loc))\n393             self.apply_load(reaction_load, loc, -1)\n394             self.apply_load(reaction_moment, loc, -2)\n395             self.bc_deflection.append((loc, 0))\n396             self.bc_slope.append((loc, 0))\n397             self._support_as_loads.append((reaction_moment, loc, -2, None))\n398 \n399         self._support_as_loads.append((reaction_load, loc, -1, None))\n400 \n401     def apply_load(self, value, start, order, end=None):\n402         \"\"\"\n403         This method adds up the loads given to a particular beam object.\n404 \n405         Parameters\n406         ==========\n407         value : Sympifyable\n408             The value inserted should have the units [Force/(Distance**(n+1)]\n409             where n is the order of applied load.\n410             Units for applied loads:\n411 \n412                - For moments, unit = kN*m\n413                - For point loads, unit = kN\n414                - For constant distributed load, unit = kN/m\n415                - For ramp loads, unit = kN/m/m\n416                - For parabolic ramp loads, unit = kN/m/m/m\n417                - ... so on.\n418 \n419         start : Sympifyable\n420             The starting point of the applied load. For point moments and\n421             point forces this is the location of application.\n422         order : Integer\n423             The order of the applied load.\n424 \n425                - For moments, order = -2\n426                - For point loads, order =-1\n427                - For constant distributed load, order = 0\n428                - For ramp loads, order = 1\n429                - For parabolic ramp loads, order = 2\n430                - ... so on.\n431 \n432         end : Sympifyable, optional\n433             An optional argument that can be used if the load has an end point\n434             within the length of the beam.\n435 \n436         Examples\n437         ========\n438         There is a beam of length 4 meters. A moment of magnitude 3 Nm is\n439         applied in the clockwise direction at the starting point of the beam.\n440         A point load of magnitude 4 N is applied from the top of the beam at\n441         2 meters from the starting point and a parabolic ramp load of magnitude\n442         2 N/m is applied below the beam starting from 2 meters to 3 meters\n443         away from the starting point of the beam.\n444 \n445         >>> from sympy.physics.continuum_mechanics.beam import Beam\n446         >>> from sympy import symbols\n447         >>> E, I = symbols('E, I')\n448         >>> b = Beam(4, E, I)\n449         >>> b.apply_load(-3, 0, -2)\n450         >>> b.apply_load(4, 2, -1)\n451         >>> b.apply_load(-2, 2, 2, end=3)\n452         >>> b.load\n453         -3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1) - 2*SingularityFunction(x, 2, 2) + 2*SingularityFunction(x, 3, 0) + 4*SingularityFunction(x, 3, 1) + 2*SingularityFunction(x, 3, 2)\n454 \n455         \"\"\"\n456         x = self.variable\n457         value = sympify(value)\n458         start = sympify(start)\n459         order = sympify(order)\n460 \n461         self._applied_loads.append((value, start, order, end))\n462         self._load += value*SingularityFunction(x, start, order)\n463 \n464         if end:\n465             if order.is_negative:\n466                 msg = (\"If 'end' is provided the 'order' of the load cannot \"\n467                        \"be negative, i.e. 'end' is only valid for distributed \"\n468                        \"loads.\")\n469                 raise ValueError(msg)\n470             # NOTE : A Taylor series can be used to define the summation of\n471             # singularity functions that subtract from the load past the end\n472             # point such that it evaluates to zero past 'end'.\n473             f = value*x**order\n474             for i in range(0, order + 1):\n475                 self._load -= (f.diff(x, i).subs(x, end - start) *\n476                                SingularityFunction(x, end, i)/factorial(i))\n477 \n478     def remove_load(self, value, start, order, end=None):\n479         \"\"\"\n480         This method removes a particular load present on the beam object.\n481         Returns a ValueError if the load passed as an argument is not\n482         present on the beam.\n483 \n484         Parameters\n485         ==========\n486         value : Sympifyable\n487             The magnitude of an applied load.\n488         start : Sympifyable\n489             The starting point of the applied load. For point moments and\n490             point forces this is the location of application.\n491         order : Integer\n492             The order of the applied load.\n493             - For moments, order= -2\n494             - For point loads, order=-1\n495             - For constant distributed load, order=0\n496             - For ramp loads, order=1\n497             - For parabolic ramp loads, order=2\n498             - ... so on.\n499         end : Sympifyable, optional\n500             An optional argument that can be used if the load has an end point\n501             within the length of the beam.\n502 \n503         Examples\n504         ========\n505         There is a beam of length 4 meters. A moment of magnitude 3 Nm is\n506         applied in the clockwise direction at the starting point of the beam.\n507         A pointload of magnitude 4 N is applied from the top of the beam at\n508         2 meters from the starting point and a parabolic ramp load of magnitude\n509         2 N/m is applied below the beam starting from 2 meters to 3 meters\n510         away from the starting point of the beam.\n511 \n512         >>> from sympy.physics.continuum_mechanics.beam import Beam\n513         >>> from sympy import symbols\n514         >>> E, I = symbols('E, I')\n515         >>> b = Beam(4, E, I)\n516         >>> b.apply_load(-3, 0, -2)\n517         >>> b.apply_load(4, 2, -1)\n518         >>> b.apply_load(-2, 2, 2, end=3)\n519         >>> b.load\n520         -3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1) - 2*SingularityFunction(x, 2, 2) + 2*SingularityFunction(x, 3, 0) + 4*SingularityFunction(x, 3, 1) + 2*SingularityFunction(x, 3, 2)\n521         >>> b.remove_load(-2, 2, 2, end = 3)\n522         >>> b.load\n523         -3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1)\n524         \"\"\"\n525         x = self.variable\n526         value = sympify(value)\n527         start = sympify(start)\n528         order = sympify(order)\n529 \n530         if (value, start, order, end) in self._applied_loads:\n531             self._load -= value*SingularityFunction(x, start, order)\n532             self._applied_loads.remove((value, start, order, end))\n533         else:\n534             msg = \"No such load distribution exists on the beam object.\"\n535             raise ValueError(msg)\n536 \n537         if end:\n538             # TODO : This is essentially duplicate code wrt to apply_load,\n539             # would be better to move it to one location and both methods use\n540             # it.\n541             if order.is_negative:\n542                 msg = (\"If 'end' is provided the 'order' of the load cannot \"\n543                        \"be negative, i.e. 'end' is only valid for distributed \"\n544                        \"loads.\")\n545                 raise ValueError(msg)\n546             # NOTE : A Taylor series can be used to define the summation of\n547             # singularity functions that subtract from the load past the end\n548             # point such that it evaluates to zero past 'end'.\n549             f = value*x**order\n550             for i in range(0, order + 1):\n551                 self._load += (f.diff(x, i).subs(x, end - start) *\n552                                SingularityFunction(x, end, i)/factorial(i))\n553 \n554     @property\n555     def load(self):\n556         \"\"\"\n557         Returns a Singularity Function expression which represents\n558         the load distribution curve of the Beam object.\n559 \n560         Examples\n561         ========\n562         There is a beam of length 4 meters. A moment of magnitude 3 Nm is\n563         applied in the clockwise direction at the starting point of the beam.\n564         A point load of magnitude 4 N is applied from the top of the beam at\n565         2 meters from the starting point and a parabolic ramp load of magnitude\n566         2 N/m is applied below the beam starting from 3 meters away from the\n567         starting point of the beam.\n568 \n569         >>> from sympy.physics.continuum_mechanics.beam import Beam\n570         >>> from sympy import symbols\n571         >>> E, I = symbols('E, I')\n572         >>> b = Beam(4, E, I)\n573         >>> b.apply_load(-3, 0, -2)\n574         >>> b.apply_load(4, 2, -1)\n575         >>> b.apply_load(-2, 3, 2)\n576         >>> b.load\n577         -3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1) - 2*SingularityFunction(x, 3, 2)\n578         \"\"\"\n579         return self._load\n580 \n581     @property\n582     def applied_loads(self):\n583         \"\"\"\n584         Returns a list of all loads applied on the beam object.\n585         Each load in the list is a tuple of form (value, start, order, end).\n586 \n587         Examples\n588         ========\n589         There is a beam of length 4 meters. A moment of magnitude 3 Nm is\n590         applied in the clockwise direction at the starting point of the beam.\n591         A pointload of magnitude 4 N is applied from the top of the beam at\n592         2 meters from the starting point. Another pointload of magnitude 5 N\n593         is applied at same position.\n594 \n595         >>> from sympy.physics.continuum_mechanics.beam import Beam\n596         >>> from sympy import symbols\n597         >>> E, I = symbols('E, I')\n598         >>> b = Beam(4, E, I)\n599         >>> b.apply_load(-3, 0, -2)\n600         >>> b.apply_load(4, 2, -1)\n601         >>> b.apply_load(5, 2, -1)\n602         >>> b.load\n603         -3*SingularityFunction(x, 0, -2) + 9*SingularityFunction(x, 2, -1)\n604         >>> b.applied_loads\n605         [(-3, 0, -2, None), (4, 2, -1, None), (5, 2, -1, None)]\n606         \"\"\"\n607         return self._applied_loads\n608 \n609     def _solve_hinge_beams(self, *reactions):\n610         \"\"\"Method to find integration constants and reactional variables in a\n611         composite beam connected via hinge.\n612         This method resolves the composite Beam into its sub-beams and then\n613         equations of shear force, bending moment, slope and deflection are\n614         evaluated for both of them separately. These equations are then solved\n615         for unknown reactions and integration constants using the boundary\n616         conditions applied on the Beam. Equal deflection of both sub-beams\n617         at the hinge joint gives us another equation to solve the system.\n618 \n619         Examples\n620         ========\n621         A combined beam, with constant fkexural rigidity E*I, is formed by joining\n622         a Beam of length 2*l to the right of another Beam of length l. The whole beam\n623         is fixed at both of its both end. A point load of magnitude P is also applied\n624         from the top at a distance of 2*l from starting point.\n625 \n626         >>> from sympy.physics.continuum_mechanics.beam import Beam\n627         >>> from sympy import symbols\n628         >>> E, I = symbols('E, I')\n629         >>> l=symbols('l', positive=True)\n630         >>> b1=Beam(l ,E,I)\n631         >>> b2=Beam(2*l ,E,I)\n632         >>> b=b1.join(b2,\"hinge\")\n633         >>> M1, A1, M2, A2, P = symbols('M1 A1 M2 A2 P')\n634         >>> b.apply_load(A1,0,-1)\n635         >>> b.apply_load(M1,0,-2)\n636         >>> b.apply_load(P,2*l,-1)\n637         >>> b.apply_load(A2,3*l,-1)\n638         >>> b.apply_load(M2,3*l,-2)\n639         >>> b.bc_slope=[(0,0), (3*l, 0)]\n640         >>> b.bc_deflection=[(0,0), (3*l, 0)]\n641         >>> b.solve_for_reaction_loads(M1, A1, M2, A2)\n642         >>> b.reaction_loads\n643         {A1: -5*P/18, A2: -13*P/18, M1: 5*P*l/18, M2: -4*P*l/9}\n644         >>> b.slope()\n645         (5*P*l*SingularityFunction(x, 0, 1)/18 - 5*P*SingularityFunction(x, 0, 2)/36 + 5*P*SingularityFunction(x, l, 2)/36)*SingularityFunction(x, 0, 0)/(E*I)\n646         - (5*P*l*SingularityFunction(x, 0, 1)/18 - 5*P*SingularityFunction(x, 0, 2)/36 + 5*P*SingularityFunction(x, l, 2)/36)*SingularityFunction(x, l, 0)/(E*I)\n647         + (P*l**2/18 - 4*P*l*SingularityFunction(-l + x, 2*l, 1)/9 - 5*P*SingularityFunction(-l + x, 0, 2)/36 + P*SingularityFunction(-l + x, l, 2)/2\n648         - 13*P*SingularityFunction(-l + x, 2*l, 2)/36)*SingularityFunction(x, l, 0)/(E*I)\n649         >>> b.deflection()\n650         (5*P*l*SingularityFunction(x, 0, 2)/36 - 5*P*SingularityFunction(x, 0, 3)/108 + 5*P*SingularityFunction(x, l, 3)/108)*SingularityFunction(x, 0, 0)/(E*I)\n651         - (5*P*l*SingularityFunction(x, 0, 2)/36 - 5*P*SingularityFunction(x, 0, 3)/108 + 5*P*SingularityFunction(x, l, 3)/108)*SingularityFunction(x, l, 0)/(E*I)\n652         + (5*P*l**3/54 + P*l**2*(-l + x)/18 - 2*P*l*SingularityFunction(-l + x, 2*l, 2)/9 - 5*P*SingularityFunction(-l + x, 0, 3)/108 + P*SingularityFunction(-l + x, l, 3)/6\n653         - 13*P*SingularityFunction(-l + x, 2*l, 3)/108)*SingularityFunction(x, l, 0)/(E*I)\n654         \"\"\"\n655         x = self.variable\n656         l = self._hinge_position\n657         E = self._elastic_modulus\n658         I = self._second_moment\n659 \n660         if isinstance(I, Piecewise):\n661             I1 = I.args[0][0]\n662             I2 = I.args[1][0]\n663         else:\n664             I1 = I2 = I\n665 \n666         load_1 = 0       # Load equation on first segment of composite beam\n667         load_2 = 0       # Load equation on second segment of composite beam\n668 \n669         # Distributing load on both segments\n670         for load in self.applied_loads:\n671             if load[1] < l:\n672                 load_1 += load[0]*SingularityFunction(x, load[1], load[2])\n673                 if load[2] == 0:\n674                     load_1 -= load[0]*SingularityFunction(x, load[3], load[2])\n675                 elif load[2] > 0:\n676                     load_1 -= load[0]*SingularityFunction(x, load[3], load[2]) + load[0]*SingularityFunction(x, load[3], 0)\n677             elif load[1] == l:\n678                 load_1 += load[0]*SingularityFunction(x, load[1], load[2])\n679                 load_2 += load[0]*SingularityFunction(x, load[1] - l, load[2])\n680             elif load[1] > l:\n681                 load_2 += load[0]*SingularityFunction(x, load[1] - l, load[2])\n682                 if load[2] == 0:\n683                     load_2 -= load[0]*SingularityFunction(x, load[3] - l, load[2])\n684                 elif load[2] > 0:\n685                     load_2 -= load[0]*SingularityFunction(x, load[3] - l, load[2]) + load[0]*SingularityFunction(x, load[3] - l, 0)\n686 \n687         h = Symbol('h')     # Force due to hinge\n688         load_1 += h*SingularityFunction(x, l, -1)\n689         load_2 -= h*SingularityFunction(x, 0, -1)\n690 \n691         eq = []\n692         shear_1 = integrate(load_1, x)\n693         shear_curve_1 = limit(shear_1, x, l)\n694         eq.append(shear_curve_1)\n695         bending_1 = integrate(shear_1, x)\n696         moment_curve_1 = limit(bending_1, x, l)\n697         eq.append(moment_curve_1)\n698 \n699         shear_2 = integrate(load_2, x)\n700         shear_curve_2 = limit(shear_2, x, self.length - l)\n701         eq.append(shear_curve_2)\n702         bending_2 = integrate(shear_2, x)\n703         moment_curve_2 = limit(bending_2, x, self.length - l)\n704         eq.append(moment_curve_2)\n705 \n706         C1 = Symbol('C1')\n707         C2 = Symbol('C2')\n708         C3 = Symbol('C3')\n709         C4 = Symbol('C4')\n710         slope_1 = S.One/(E*I1)*(integrate(bending_1, x) + C1)\n711         def_1 = S.One/(E*I1)*(integrate((E*I)*slope_1, x) + C1*x + C2)\n712         slope_2 = S.One/(E*I2)*(integrate(integrate(integrate(load_2, x), x), x) + C3)\n713         def_2 = S.One/(E*I2)*(integrate((E*I)*slope_2, x) + C4)\n714 \n715         for position, value in self.bc_slope:\n716             if position<l:\n717                 eq.append(slope_1.subs(x, position) - value)\n718             else:\n719                 eq.append(slope_2.subs(x, position - l) - value)\n720 \n721         for position, value in self.bc_deflection:\n722             if position<l:\n723                 eq.append(def_1.subs(x, position) - value)\n724             else:\n725                 eq.append(def_2.subs(x, position - l) - value)\n726 \n727         eq.append(def_1.subs(x, l) - def_2.subs(x, 0)) # Deflection of both the segments at hinge would be equal\n728 \n729         constants = list(linsolve(eq, C1, C2, C3, C4, h, *reactions))\n730         reaction_values = list(constants[0])[5:]\n731 \n732         self._reaction_loads = dict(zip(reactions, reaction_values))\n733         self._load = self._load.subs(self._reaction_loads)\n734 \n735         # Substituting constants and reactional load and moments with their corresponding values\n736         slope_1 = slope_1.subs({C1: constants[0][0], h:constants[0][4]}).subs(self._reaction_loads)\n737         def_1 = def_1.subs({C1: constants[0][0], C2: constants[0][1], h:constants[0][4]}).subs(self._reaction_loads)\n738         slope_2 = slope_2.subs({x: x-l, C3: constants[0][2], h:constants[0][4]}).subs(self._reaction_loads)\n739         def_2 = def_2.subs({x: x-l,C3: constants[0][2], C4: constants[0][3], h:constants[0][4]}).subs(self._reaction_loads)\n740 \n741         self._hinge_beam_slope = slope_1*SingularityFunction(x, 0, 0) - slope_1*SingularityFunction(x, l, 0) + slope_2*SingularityFunction(x, l, 0)\n742         self._hinge_beam_deflection = def_1*SingularityFunction(x, 0, 0) - def_1*SingularityFunction(x, l, 0) + def_2*SingularityFunction(x, l, 0)\n743 \n744     def solve_for_reaction_loads(self, *reactions):\n745         \"\"\"\n746         Solves for the reaction forces.\n747 \n748         Examples\n749         ========\n750         There is a beam of length 30 meters. A moment of magnitude 120 Nm is\n751         applied in the clockwise direction at the end of the beam. A pointload\n752         of magnitude 8 N is applied from the top of the beam at the starting\n753         point. There are two simple supports below the beam. One at the end\n754         and another one at a distance of 10 meters from the start. The\n755         deflection is restricted at both the supports.\n756 \n757         Using the sign convention of upward forces and clockwise moment\n758         being positive.\n759 \n760         >>> from sympy.physics.continuum_mechanics.beam import Beam\n761         >>> from sympy import symbols\n762         >>> E, I = symbols('E, I')\n763         >>> R1, R2 = symbols('R1, R2')\n764         >>> b = Beam(30, E, I)\n765         >>> b.apply_load(-8, 0, -1)\n766         >>> b.apply_load(R1, 10, -1)  # Reaction force at x = 10\n767         >>> b.apply_load(R2, 30, -1)  # Reaction force at x = 30\n768         >>> b.apply_load(120, 30, -2)\n769         >>> b.bc_deflection = [(10, 0), (30, 0)]\n770         >>> b.load\n771         R1*SingularityFunction(x, 10, -1) + R2*SingularityFunction(x, 30, -1)\n772             - 8*SingularityFunction(x, 0, -1) + 120*SingularityFunction(x, 30, -2)\n773         >>> b.solve_for_reaction_loads(R1, R2)\n774         >>> b.reaction_loads\n775         {R1: 6, R2: 2}\n776         >>> b.load\n777         -8*SingularityFunction(x, 0, -1) + 6*SingularityFunction(x, 10, -1)\n778             + 120*SingularityFunction(x, 30, -2) + 2*SingularityFunction(x, 30, -1)\n779         \"\"\"\n780         if self._composite_type == \"hinge\":\n781             return self._solve_hinge_beams(*reactions)\n782 \n783         x = self.variable\n784         l = self.length\n785         C3 = Symbol('C3')\n786         C4 = Symbol('C4')\n787 \n788         shear_curve = limit(self.shear_force(), x, l)\n789         moment_curve = limit(self.bending_moment(), x, l)\n790 \n791         slope_eqs = []\n792         deflection_eqs = []\n793 \n794         slope_curve = integrate(self.bending_moment(), x) + C3\n795         for position, value in self._boundary_conditions['slope']:\n796             eqs = slope_curve.subs(x, position) - value\n797             slope_eqs.append(eqs)\n798 \n799         deflection_curve = integrate(slope_curve, x) + C4\n800         for position, value in self._boundary_conditions['deflection']:\n801             eqs = deflection_curve.subs(x, position) - value\n802             deflection_eqs.append(eqs)\n803 \n804         solution = list((linsolve([shear_curve, moment_curve] + slope_eqs\n805                             + deflection_eqs, (C3, C4) + reactions).args)[0])\n806         solution = solution[2:]\n807 \n808         self._reaction_loads = dict(zip(reactions, solution))\n809         self._load = self._load.subs(self._reaction_loads)\n810 \n811     def shear_force(self):\n812         \"\"\"\n813         Returns a Singularity Function expression which represents\n814         the shear force curve of the Beam object.\n815 \n816         Examples\n817         ========\n818         There is a beam of length 30 meters. A moment of magnitude 120 Nm is\n819         applied in the clockwise direction at the end of the beam. A pointload\n820         of magnitude 8 N is applied from the top of the beam at the starting\n821         point. There are two simple supports below the beam. One at the end\n822         and another one at a distance of 10 meters from the start. The\n823         deflection is restricted at both the supports.\n824 \n825         Using the sign convention of upward forces and clockwise moment\n826         being positive.\n827 \n828         >>> from sympy.physics.continuum_mechanics.beam import Beam\n829         >>> from sympy import symbols\n830         >>> E, I = symbols('E, I')\n831         >>> R1, R2 = symbols('R1, R2')\n832         >>> b = Beam(30, E, I)\n833         >>> b.apply_load(-8, 0, -1)\n834         >>> b.apply_load(R1, 10, -1)\n835         >>> b.apply_load(R2, 30, -1)\n836         >>> b.apply_load(120, 30, -2)\n837         >>> b.bc_deflection = [(10, 0), (30, 0)]\n838         >>> b.solve_for_reaction_loads(R1, R2)\n839         >>> b.shear_force()\n840         8*SingularityFunction(x, 0, 0) - 6*SingularityFunction(x, 10, 0) - 120*SingularityFunction(x, 30, -1) - 2*SingularityFunction(x, 30, 0)\n841         \"\"\"\n842         x = self.variable\n843         return -integrate(self.load, x)\n844 \n845     def max_shear_force(self):\n846         \"\"\"Returns maximum Shear force and its coordinate\n847         in the Beam object.\"\"\"\n848         from sympy import solve, Mul, Interval\n849         shear_curve = self.shear_force()\n850         x = self.variable\n851 \n852         terms = shear_curve.args\n853         singularity = []        # Points at which shear function changes\n854         for term in terms:\n855             if isinstance(term, Mul):\n856                 term = term.args[-1]    # SingularityFunction in the term\n857             singularity.append(term.args[1])\n858         singularity.sort()\n859         singularity = list(set(singularity))\n860 \n861         intervals = []    # List of Intervals with discrete value of shear force\n862         shear_values = []   # List of values of shear force in each interval\n863         for i, s in enumerate(singularity):\n864             if s == 0:\n865                 continue\n866             try:\n867                 shear_slope = Piecewise((float(\"nan\"), x<=singularity[i-1]),(self._load.rewrite(Piecewise), x<s), (float(\"nan\"), True))\n868                 points = solve(shear_slope, x)\n869                 val = []\n870                 for point in points:\n871                     val.append(shear_curve.subs(x, point))\n872                 points.extend([singularity[i-1], s])\n873                 val.extend([limit(shear_curve, x, singularity[i-1], '+'), limit(shear_curve, x, s, '-')])\n874                 val = list(map(abs, val))\n875                 max_shear = max(val)\n876                 shear_values.append(max_shear)\n877                 intervals.append(points[val.index(max_shear)])\n878             # If shear force in a particular Interval has zero or constant\n879             # slope, then above block gives NotImplementedError as\n880             # solve can't represent Interval solutions.\n881             except NotImplementedError:\n882                 initial_shear = limit(shear_curve, x, singularity[i-1], '+')\n883                 final_shear = limit(shear_curve, x, s, '-')\n884                 # If shear_curve has a constant slope(it is a line).\n885                 if shear_curve.subs(x, (singularity[i-1] + s)/2) == (initial_shear + final_shear)/2 and initial_shear != final_shear:\n886                     shear_values.extend([initial_shear, final_shear])\n887                     intervals.extend([singularity[i-1], s])\n888                 else:    # shear_curve has same value in whole Interval\n889                     shear_values.append(final_shear)\n890                     intervals.append(Interval(singularity[i-1], s))\n891 \n892         shear_values = list(map(abs, shear_values))\n893         maximum_shear = max(shear_values)\n894         point = intervals[shear_values.index(maximum_shear)]\n895         return (point, maximum_shear)\n896 \n897     def bending_moment(self):\n898         \"\"\"\n899         Returns a Singularity Function expression which represents\n900         the bending moment curve of the Beam object.\n901 \n902         Examples\n903         ========\n904         There is a beam of length 30 meters. A moment of magnitude 120 Nm is\n905         applied in the clockwise direction at the end of the beam. A pointload\n906         of magnitude 8 N is applied from the top of the beam at the starting\n907         point. There are two simple supports below the beam. One at the end\n908         and another one at a distance of 10 meters from the start. The\n909         deflection is restricted at both the supports.\n910 \n911         Using the sign convention of upward forces and clockwise moment\n912         being positive.\n913 \n914         >>> from sympy.physics.continuum_mechanics.beam import Beam\n915         >>> from sympy import symbols\n916         >>> E, I = symbols('E, I')\n917         >>> R1, R2 = symbols('R1, R2')\n918         >>> b = Beam(30, E, I)\n919         >>> b.apply_load(-8, 0, -1)\n920         >>> b.apply_load(R1, 10, -1)\n921         >>> b.apply_load(R2, 30, -1)\n922         >>> b.apply_load(120, 30, -2)\n923         >>> b.bc_deflection = [(10, 0), (30, 0)]\n924         >>> b.solve_for_reaction_loads(R1, R2)\n925         >>> b.bending_moment()\n926         8*SingularityFunction(x, 0, 1) - 6*SingularityFunction(x, 10, 1) - 120*SingularityFunction(x, 30, 0) - 2*SingularityFunction(x, 30, 1)\n927         \"\"\"\n928         x = self.variable\n929         return integrate(self.shear_force(), x)\n930 \n931     def max_bmoment(self):\n932         \"\"\"Returns maximum Shear force and its coordinate\n933         in the Beam object.\"\"\"\n934         from sympy import solve, Mul, Interval\n935         bending_curve = self.bending_moment()\n936         x = self.variable\n937 \n938         terms = bending_curve.args\n939         singularity = []        # Points at which bending moment changes\n940         for term in terms:\n941             if isinstance(term, Mul):\n942                 term = term.args[-1]    # SingularityFunction in the term\n943             singularity.append(term.args[1])\n944         singularity.sort()\n945         singularity = list(set(singularity))\n946 \n947         intervals = []    # List of Intervals with discrete value of bending moment\n948         moment_values = []   # List of values of bending moment in each interval\n949         for i, s in enumerate(singularity):\n950             if s == 0:\n951                 continue\n952             try:\n953                 moment_slope = Piecewise((float(\"nan\"), x<=singularity[i-1]),(self.shear_force().rewrite(Piecewise), x<s), (float(\"nan\"), True))\n954                 points = solve(moment_slope, x)\n955                 val = []\n956                 for point in points:\n957                     val.append(bending_curve.subs(x, point))\n958                 points.extend([singularity[i-1], s])\n959                 val.extend([limit(bending_curve, x, singularity[i-1], '+'), limit(bending_curve, x, s, '-')])\n960                 val = list(map(abs, val))\n961                 max_moment = max(val)\n962                 moment_values.append(max_moment)\n963                 intervals.append(points[val.index(max_moment)])\n964             # If bending moment in a particular Interval has zero or constant\n965             # slope, then above block gives NotImplementedError as solve\n966             # can't represent Interval solutions.\n967             except NotImplementedError:\n968                 initial_moment = limit(bending_curve, x, singularity[i-1], '+')\n969                 final_moment = limit(bending_curve, x, s, '-')\n970                 # If bending_curve has a constant slope(it is a line).\n971                 if bending_curve.subs(x, (singularity[i-1] + s)/2) == (initial_moment + final_moment)/2 and initial_moment != final_moment:\n972                     moment_values.extend([initial_moment, final_moment])\n973                     intervals.extend([singularity[i-1], s])\n974                 else:    # bending_curve has same value in whole Interval\n975                     moment_values.append(final_moment)\n976                     intervals.append(Interval(singularity[i-1], s))\n977 \n978         moment_values = list(map(abs, moment_values))\n979         maximum_moment = max(moment_values)\n980         point = intervals[moment_values.index(maximum_moment)]\n981         return (point, maximum_moment)\n982 \n983     def point_cflexure(self):\n984         \"\"\"\n985         Returns a Set of point(s) with zero bending moment and\n986         where bending moment curve of the beam object changes\n987         its sign from negative to positive or vice versa.\n988 \n989         Examples\n990         ========\n991         There is is 10 meter long overhanging beam. There are\n992         two simple supports below the beam. One at the start\n993         and another one at a distance of 6 meters from the start.\n994         Point loads of magnitude 10KN and 20KN are applied at\n995         2 meters and 4 meters from start respectively. A Uniformly\n996         distribute load of magnitude of magnitude 3KN/m is also\n997         applied on top starting from 6 meters away from starting\n998         point till end.\n999         Using the sign convention of upward forces and clockwise moment\n1000         being positive.\n1001 \n1002         >>> from sympy.physics.continuum_mechanics.beam import Beam\n1003         >>> from sympy import symbols\n1004         >>> E, I = symbols('E, I')\n1005         >>> b = Beam(10, E, I)\n1006         >>> b.apply_load(-4, 0, -1)\n1007         >>> b.apply_load(-46, 6, -1)\n1008         >>> b.apply_load(10, 2, -1)\n1009         >>> b.apply_load(20, 4, -1)\n1010         >>> b.apply_load(3, 6, 0)\n1011         >>> b.point_cflexure()\n1012         [10/3]\n1013         \"\"\"\n1014         from sympy import solve, Piecewise\n1015 \n1016         # To restrict the range within length of the Beam\n1017         moment_curve = Piecewise((float(\"nan\"), self.variable<=0),\n1018                 (self.bending_moment(), self.variable<self.length),\n1019                 (float(\"nan\"), True))\n1020 \n1021         points = solve(moment_curve.rewrite(Piecewise), self.variable,\n1022                         domain=S.Reals)\n1023         return points\n1024 \n1025     def slope(self):\n1026         \"\"\"\n1027         Returns a Singularity Function expression which represents\n1028         the slope the elastic curve of the Beam object.\n1029 \n1030         Examples\n1031         ========\n1032         There is a beam of length 30 meters. A moment of magnitude 120 Nm is\n1033         applied in the clockwise direction at the end of the beam. A pointload\n1034         of magnitude 8 N is applied from the top of the beam at the starting\n1035         point. There are two simple supports below the beam. One at the end\n1036         and another one at a distance of 10 meters from the start. The\n1037         deflection is restricted at both the supports.\n1038 \n1039         Using the sign convention of upward forces and clockwise moment\n1040         being positive.\n1041 \n1042         >>> from sympy.physics.continuum_mechanics.beam import Beam\n1043         >>> from sympy import symbols\n1044         >>> E, I = symbols('E, I')\n1045         >>> R1, R2 = symbols('R1, R2')\n1046         >>> b = Beam(30, E, I)\n1047         >>> b.apply_load(-8, 0, -1)\n1048         >>> b.apply_load(R1, 10, -1)\n1049         >>> b.apply_load(R2, 30, -1)\n1050         >>> b.apply_load(120, 30, -2)\n1051         >>> b.bc_deflection = [(10, 0), (30, 0)]\n1052         >>> b.solve_for_reaction_loads(R1, R2)\n1053         >>> b.slope()\n1054         (-4*SingularityFunction(x, 0, 2) + 3*SingularityFunction(x, 10, 2)\n1055             + 120*SingularityFunction(x, 30, 1) + SingularityFunction(x, 30, 2) + 4000/3)/(E*I)\n1056         \"\"\"\n1057         x = self.variable\n1058         E = self.elastic_modulus\n1059         I = self.second_moment\n1060 \n1061         if self._composite_type == \"hinge\":\n1062             return self._hinge_beam_slope\n1063         if not self._boundary_conditions['slope']:\n1064             return diff(self.deflection(), x)\n1065         if isinstance(I, Piecewise) and self._composite_type == \"fixed\":\n1066             args = I.args\n1067             slope = 0\n1068             prev_slope = 0\n1069             prev_end = 0\n1070             for i in range(len(args)):\n1071                 if i != 0:\n1072                     prev_end = args[i-1][1].args[1]\n1073                 slope_value = -S.One/E*integrate(self.bending_moment()/args[i][0], (x, prev_end, x))\n1074                 if i != len(args) - 1:\n1075                     slope += (prev_slope + slope_value)*SingularityFunction(x, prev_end, 0) - \\\n1076                         (prev_slope + slope_value)*SingularityFunction(x, args[i][1].args[1], 0)\n1077                 else:\n1078                     slope += (prev_slope + slope_value)*SingularityFunction(x, prev_end, 0)\n1079                 prev_slope = slope_value.subs(x, args[i][1].args[1])\n1080             return slope\n1081 \n1082         C3 = Symbol('C3')\n1083         slope_curve = -integrate(S.One/(E*I)*self.bending_moment(), x) + C3\n1084 \n1085         bc_eqs = []\n1086         for position, value in self._boundary_conditions['slope']:\n1087             eqs = slope_curve.subs(x, position) - value\n1088             bc_eqs.append(eqs)\n1089         constants = list(linsolve(bc_eqs, C3))\n1090         slope_curve = slope_curve.subs({C3: constants[0][0]})\n1091         return slope_curve\n1092 \n1093     def deflection(self):\n1094         \"\"\"\n1095         Returns a Singularity Function expression which represents\n1096         the elastic curve or deflection of the Beam object.\n1097 \n1098         Examples\n1099         ========\n1100         There is a beam of length 30 meters. A moment of magnitude 120 Nm is\n1101         applied in the clockwise direction at the end of the beam. A pointload\n1102         of magnitude 8 N is applied from the top of the beam at the starting\n1103         point. There are two simple supports below the beam. One at the end\n1104         and another one at a distance of 10 meters from the start. The\n1105         deflection is restricted at both the supports.\n1106 \n1107         Using the sign convention of upward forces and clockwise moment\n1108         being positive.\n1109 \n1110         >>> from sympy.physics.continuum_mechanics.beam import Beam\n1111         >>> from sympy import symbols\n1112         >>> E, I = symbols('E, I')\n1113         >>> R1, R2 = symbols('R1, R2')\n1114         >>> b = Beam(30, E, I)\n1115         >>> b.apply_load(-8, 0, -1)\n1116         >>> b.apply_load(R1, 10, -1)\n1117         >>> b.apply_load(R2, 30, -1)\n1118         >>> b.apply_load(120, 30, -2)\n1119         >>> b.bc_deflection = [(10, 0), (30, 0)]\n1120         >>> b.solve_for_reaction_loads(R1, R2)\n1121         >>> b.deflection()\n1122         (4000*x/3 - 4*SingularityFunction(x, 0, 3)/3 + SingularityFunction(x, 10, 3)\n1123             + 60*SingularityFunction(x, 30, 2) + SingularityFunction(x, 30, 3)/3 - 12000)/(E*I)\n1124         \"\"\"\n1125         x = self.variable\n1126         E = self.elastic_modulus\n1127         I = self.second_moment\n1128         if self._composite_type == \"hinge\":\n1129             return self._hinge_beam_deflection\n1130         if not self._boundary_conditions['deflection'] and not self._boundary_conditions['slope']:\n1131             if isinstance(I, Piecewise) and self._composite_type == \"fixed\":\n1132                 args = I.args\n1133                 prev_slope = 0\n1134                 prev_def = 0\n1135                 prev_end = 0\n1136                 deflection = 0\n1137                 for i in range(len(args)):\n1138                     if i != 0:\n1139                         prev_end = args[i-1][1].args[1]\n1140                     slope_value = -S.One/E*integrate(self.bending_moment()/args[i][0], (x, prev_end, x))\n1141                     recent_segment_slope = prev_slope + slope_value\n1142                     deflection_value = integrate(recent_segment_slope, (x, prev_end, x))\n1143                     if i != len(args) - 1:\n1144                         deflection += (prev_def + deflection_value)*SingularityFunction(x, prev_end, 0) \\\n1145                             - (prev_def + deflection_value)*SingularityFunction(x, args[i][1].args[1], 0)\n1146                     else:\n1147                         deflection += (prev_def + deflection_value)*SingularityFunction(x, prev_end, 0)\n1148                     prev_slope = slope_value.subs(x, args[i][1].args[1])\n1149                     prev_def = deflection_value.subs(x, args[i][1].args[1])\n1150                 return deflection\n1151             base_char = self._base_char\n1152             constants = symbols(base_char + '3:5')\n1153             return S.One/(E*I)*integrate(-integrate(self.bending_moment(), x), x) + constants[0]*x + constants[1]\n1154         elif not self._boundary_conditions['deflection']:\n1155             base_char = self._base_char\n1156             constant = symbols(base_char + '4')\n1157             return integrate(self.slope(), x) + constant\n1158         elif not self._boundary_conditions['slope'] and self._boundary_conditions['deflection']:\n1159             if isinstance(I, Piecewise) and self._composite_type == \"fixed\":\n1160                 args = I.args\n1161                 prev_slope = 0\n1162                 prev_def = 0\n1163                 prev_end = 0\n1164                 deflection = 0\n1165                 for i in range(len(args)):\n1166                     if i != 0:\n1167                         prev_end = args[i-1][1].args[1]\n1168                     slope_value = -S.One/E*integrate(self.bending_moment()/args[i][0], (x, prev_end, x))\n1169                     recent_segment_slope = prev_slope + slope_value\n1170                     deflection_value = integrate(recent_segment_slope, (x, prev_end, x))\n1171                     if i != len(args) - 1:\n1172                         deflection += (prev_def + deflection_value)*SingularityFunction(x, prev_end, 0) \\\n1173                             - (prev_def + deflection_value)*SingularityFunction(x, args[i][1].args[1], 0)\n1174                     else:\n1175                         deflection += (prev_def + deflection_value)*SingularityFunction(x, prev_end, 0)\n1176                     prev_slope = slope_value.subs(x, args[i][1].args[1])\n1177                     prev_def = deflection_value.subs(x, args[i][1].args[1])\n1178                 return deflection\n1179             base_char = self._base_char\n1180             C3, C4 = symbols(base_char + '3:5')    # Integration constants\n1181             slope_curve = -integrate(self.bending_moment(), x) + C3\n1182             deflection_curve = integrate(slope_curve, x) + C4\n1183             bc_eqs = []\n1184             for position, value in self._boundary_conditions['deflection']:\n1185                 eqs = deflection_curve.subs(x, position) - value\n1186                 bc_eqs.append(eqs)\n1187             constants = list(linsolve(bc_eqs, (C3, C4)))\n1188             deflection_curve = deflection_curve.subs({C3: constants[0][0], C4: constants[0][1]})\n1189             return S.One/(E*I)*deflection_curve\n1190 \n1191         if isinstance(I, Piecewise) and self._composite_type == \"fixed\":\n1192             args = I.args\n1193             prev_slope = 0\n1194             prev_def = 0\n1195             prev_end = 0\n1196             deflection = 0\n1197             for i in range(len(args)):\n1198                 if i != 0:\n1199                     prev_end = args[i-1][1].args[1]\n1200                 slope_value = S.One/E*integrate(self.bending_moment()/args[i][0], (x, prev_end, x))\n1201                 recent_segment_slope = prev_slope + slope_value\n1202                 deflection_value = integrate(recent_segment_slope, (x, prev_end, x))\n1203                 if i != len(args) - 1:\n1204                     deflection += (prev_def + deflection_value)*SingularityFunction(x, prev_end, 0) \\\n1205                         - (prev_def + deflection_value)*SingularityFunction(x, args[i][1].args[1], 0)\n1206                 else:\n1207                     deflection += (prev_def + deflection_value)*SingularityFunction(x, prev_end, 0)\n1208                 prev_slope = slope_value.subs(x, args[i][1].args[1])\n1209                 prev_def = deflection_value.subs(x, args[i][1].args[1])\n1210             return deflection\n1211 \n1212         C4 = Symbol('C4')\n1213         deflection_curve = integrate(self.slope(), x) + C4\n1214 \n1215         bc_eqs = []\n1216         for position, value in self._boundary_conditions['deflection']:\n1217             eqs = deflection_curve.subs(x, position) - value\n1218             bc_eqs.append(eqs)\n1219 \n1220         constants = list(linsolve(bc_eqs, C4))\n1221         deflection_curve = deflection_curve.subs({C4: constants[0][0]})\n1222         return deflection_curve\n1223 \n1224     def max_deflection(self):\n1225         \"\"\"\n1226         Returns point of max deflection and its corresponding deflection value\n1227         in a Beam object.\n1228         \"\"\"\n1229         from sympy import solve, Piecewise\n1230 \n1231         # To restrict the range within length of the Beam\n1232         slope_curve = Piecewise((float(\"nan\"), self.variable<=0),\n1233                 (self.slope(), self.variable<self.length),\n1234                 (float(\"nan\"), True))\n1235 \n1236         points = solve(slope_curve.rewrite(Piecewise), self.variable,\n1237                         domain=S.Reals)\n1238         deflection_curve = self.deflection()\n1239         deflections = [deflection_curve.subs(self.variable, x) for x in points]\n1240         deflections = list(map(abs, deflections))\n1241         if len(deflections) != 0:\n1242             max_def = max(deflections)\n1243             return (points[deflections.index(max_def)], max_def)\n1244         else:\n1245             return None\n1246 \n1247     def shear_stress(self):\n1248         \"\"\"\n1249         Returns an expression representing the Shear Stress\n1250         curve of the Beam object.\n1251         \"\"\"\n1252         return self.shear_force()/self._area\n1253 \n1254     def plot_shear_force(self, subs=None):\n1255         \"\"\"\n1256 \n1257         Returns a plot for Shear force present in the Beam object.\n1258 \n1259         Parameters\n1260         ==========\n1261         subs : dictionary\n1262             Python dictionary containing Symbols as key and their\n1263             corresponding values.\n1264 \n1265         Examples\n1266         ========\n1267         There is a beam of length 8 meters. A constant distributed load of 10 KN/m\n1268         is applied from half of the beam till the end. There are two simple supports\n1269         below the beam, one at the starting point and another at the ending point\n1270         of the beam. A pointload of magnitude 5 KN is also applied from top of the\n1271         beam, at a distance of 4 meters from the starting point.\n1272         Take E = 200 GPa and I = 400*(10**-6) meter**4.\n1273 \n1274         Using the sign convention of downwards forces being positive.\n1275 \n1276         .. plot::\n1277             :context: close-figs\n1278             :format: doctest\n1279             :include-source: True\n1280 \n1281             >>> from sympy.physics.continuum_mechanics.beam import Beam\n1282             >>> from sympy import symbols\n1283             >>> R1, R2 = symbols('R1, R2')\n1284             >>> b = Beam(8, 200*(10**9), 400*(10**-6))\n1285             >>> b.apply_load(5000, 2, -1)\n1286             >>> b.apply_load(R1, 0, -1)\n1287             >>> b.apply_load(R2, 8, -1)\n1288             >>> b.apply_load(10000, 4, 0, end=8)\n1289             >>> b.bc_deflection = [(0, 0), (8, 0)]\n1290             >>> b.solve_for_reaction_loads(R1, R2)\n1291             >>> b.plot_shear_force()\n1292             Plot object containing:\n1293             [0]: cartesian line: 13750*SingularityFunction(x, 0, 0) - 5000*SingularityFunction(x, 2, 0)\n1294             - 10000*SingularityFunction(x, 4, 1) + 31250*SingularityFunction(x, 8, 0)\n1295             + 10000*SingularityFunction(x, 8, 1) for x over (0.0, 8.0)\n1296         \"\"\"\n1297         shear_force = self.shear_force()\n1298         if subs is None:\n1299             subs = {}\n1300         for sym in shear_force.atoms(Symbol):\n1301             if sym == self.variable:\n1302                 continue\n1303             if sym not in subs:\n1304                 raise ValueError('Value of %s was not passed.' %sym)\n1305         if self.length in subs:\n1306             length = subs[self.length]\n1307         else:\n1308             length = self.length\n1309         return plot(shear_force.subs(subs), (self.variable, 0, length), title='Shear Force',\n1310                 xlabel=r'$\\mathrm{x}$', ylabel=r'$\\mathrm{V}$', line_color='g')\n1311 \n1312     def plot_bending_moment(self, subs=None):\n1313         \"\"\"\n1314 \n1315         Returns a plot for Bending moment present in the Beam object.\n1316 \n1317         Parameters\n1318         ==========\n1319         subs : dictionary\n1320             Python dictionary containing Symbols as key and their\n1321             corresponding values.\n1322 \n1323         Examples\n1324         ========\n1325         There is a beam of length 8 meters. A constant distributed load of 10 KN/m\n1326         is applied from half of the beam till the end. There are two simple supports\n1327         below the beam, one at the starting point and another at the ending point\n1328         of the beam. A pointload of magnitude 5 KN is also applied from top of the\n1329         beam, at a distance of 4 meters from the starting point.\n1330         Take E = 200 GPa and I = 400*(10**-6) meter**4.\n1331 \n1332         Using the sign convention of downwards forces being positive.\n1333 \n1334         .. plot::\n1335             :context: close-figs\n1336             :format: doctest\n1337             :include-source: True\n1338 \n1339             >>> from sympy.physics.continuum_mechanics.beam import Beam\n1340             >>> from sympy import symbols\n1341             >>> R1, R2 = symbols('R1, R2')\n1342             >>> b = Beam(8, 200*(10**9), 400*(10**-6))\n1343             >>> b.apply_load(5000, 2, -1)\n1344             >>> b.apply_load(R1, 0, -1)\n1345             >>> b.apply_load(R2, 8, -1)\n1346             >>> b.apply_load(10000, 4, 0, end=8)\n1347             >>> b.bc_deflection = [(0, 0), (8, 0)]\n1348             >>> b.solve_for_reaction_loads(R1, R2)\n1349             >>> b.plot_bending_moment()\n1350             Plot object containing:\n1351             [0]: cartesian line: 13750*SingularityFunction(x, 0, 1) - 5000*SingularityFunction(x, 2, 1)\n1352             - 5000*SingularityFunction(x, 4, 2) + 31250*SingularityFunction(x, 8, 1)\n1353             + 5000*SingularityFunction(x, 8, 2) for x over (0.0, 8.0)\n1354         \"\"\"\n1355         bending_moment = self.bending_moment()\n1356         if subs is None:\n1357             subs = {}\n1358         for sym in bending_moment.atoms(Symbol):\n1359             if sym == self.variable:\n1360                 continue\n1361             if sym not in subs:\n1362                 raise ValueError('Value of %s was not passed.' %sym)\n1363         if self.length in subs:\n1364             length = subs[self.length]\n1365         else:\n1366             length = self.length\n1367         return plot(bending_moment.subs(subs), (self.variable, 0, length), title='Bending Moment',\n1368                 xlabel=r'$\\mathrm{x}$', ylabel=r'$\\mathrm{M}$', line_color='b')\n1369 \n1370     def plot_slope(self, subs=None):\n1371         \"\"\"\n1372 \n1373         Returns a plot for slope of deflection curve of the Beam object.\n1374 \n1375         Parameters\n1376         ==========\n1377         subs : dictionary\n1378             Python dictionary containing Symbols as key and their\n1379             corresponding values.\n1380 \n1381         Examples\n1382         ========\n1383         There is a beam of length 8 meters. A constant distributed load of 10 KN/m\n1384         is applied from half of the beam till the end. There are two simple supports\n1385         below the beam, one at the starting point and another at the ending point\n1386         of the beam. A pointload of magnitude 5 KN is also applied from top of the\n1387         beam, at a distance of 4 meters from the starting point.\n1388         Take E = 200 GPa and I = 400*(10**-6) meter**4.\n1389 \n1390         Using the sign convention of downwards forces being positive.\n1391 \n1392         .. plot::\n1393             :context: close-figs\n1394             :format: doctest\n1395             :include-source: True\n1396 \n1397             >>> from sympy.physics.continuum_mechanics.beam import Beam\n1398             >>> from sympy import symbols\n1399             >>> R1, R2 = symbols('R1, R2')\n1400             >>> b = Beam(8, 200*(10**9), 400*(10**-6))\n1401             >>> b.apply_load(5000, 2, -1)\n1402             >>> b.apply_load(R1, 0, -1)\n1403             >>> b.apply_load(R2, 8, -1)\n1404             >>> b.apply_load(10000, 4, 0, end=8)\n1405             >>> b.bc_deflection = [(0, 0), (8, 0)]\n1406             >>> b.solve_for_reaction_loads(R1, R2)\n1407             >>> b.plot_slope()\n1408             Plot object containing:\n1409             [0]: cartesian line: -8.59375e-5*SingularityFunction(x, 0, 2) + 3.125e-5*SingularityFunction(x, 2, 2)\n1410             + 2.08333333333333e-5*SingularityFunction(x, 4, 3) - 0.0001953125*SingularityFunction(x, 8, 2)\n1411             - 2.08333333333333e-5*SingularityFunction(x, 8, 3) + 0.00138541666666667 for x over (0.0, 8.0)\n1412         \"\"\"\n1413         slope = self.slope()\n1414         if subs is None:\n1415             subs = {}\n1416         for sym in slope.atoms(Symbol):\n1417             if sym == self.variable:\n1418                 continue\n1419             if sym not in subs:\n1420                 raise ValueError('Value of %s was not passed.' %sym)\n1421         if self.length in subs:\n1422             length = subs[self.length]\n1423         else:\n1424             length = self.length\n1425         return plot(slope.subs(subs), (self.variable, 0, length), title='Slope',\n1426                 xlabel=r'$\\mathrm{x}$', ylabel=r'$\\theta$', line_color='m')\n1427 \n1428     def plot_deflection(self, subs=None):\n1429         \"\"\"\n1430 \n1431         Returns a plot for deflection curve of the Beam object.\n1432 \n1433         Parameters\n1434         ==========\n1435         subs : dictionary\n1436             Python dictionary containing Symbols as key and their\n1437             corresponding values.\n1438 \n1439         Examples\n1440         ========\n1441         There is a beam of length 8 meters. A constant distributed load of 10 KN/m\n1442         is applied from half of the beam till the end. There are two simple supports\n1443         below the beam, one at the starting point and another at the ending point\n1444         of the beam. A pointload of magnitude 5 KN is also applied from top of the\n1445         beam, at a distance of 4 meters from the starting point.\n1446         Take E = 200 GPa and I = 400*(10**-6) meter**4.\n1447 \n1448         Using the sign convention of downwards forces being positive.\n1449 \n1450         .. plot::\n1451             :context: close-figs\n1452             :format: doctest\n1453             :include-source: True\n1454 \n1455             >>> from sympy.physics.continuum_mechanics.beam import Beam\n1456             >>> from sympy import symbols\n1457             >>> R1, R2 = symbols('R1, R2')\n1458             >>> b = Beam(8, 200*(10**9), 400*(10**-6))\n1459             >>> b.apply_load(5000, 2, -1)\n1460             >>> b.apply_load(R1, 0, -1)\n1461             >>> b.apply_load(R2, 8, -1)\n1462             >>> b.apply_load(10000, 4, 0, end=8)\n1463             >>> b.bc_deflection = [(0, 0), (8, 0)]\n1464             >>> b.solve_for_reaction_loads(R1, R2)\n1465             >>> b.plot_deflection()\n1466             Plot object containing:\n1467             [0]: cartesian line: 0.00138541666666667*x - 2.86458333333333e-5*SingularityFunction(x, 0, 3)\n1468             + 1.04166666666667e-5*SingularityFunction(x, 2, 3) + 5.20833333333333e-6*SingularityFunction(x, 4, 4)\n1469             - 6.51041666666667e-5*SingularityFunction(x, 8, 3) - 5.20833333333333e-6*SingularityFunction(x, 8, 4)\n1470             for x over (0.0, 8.0)\n1471         \"\"\"\n1472         deflection = self.deflection()\n1473         if subs is None:\n1474             subs = {}\n1475         for sym in deflection.atoms(Symbol):\n1476             if sym == self.variable:\n1477                 continue\n1478             if sym not in subs:\n1479                 raise ValueError('Value of %s was not passed.' %sym)\n1480         if self.length in subs:\n1481             length = subs[self.length]\n1482         else:\n1483             length = self.length\n1484         return plot(deflection.subs(subs), (self.variable, 0, length),\n1485                     title='Deflection', xlabel=r'$\\mathrm{x}$', ylabel=r'$\\delta$',\n1486                     line_color='r')\n1487 \n1488 \n1489     def plot_loading_results(self, subs=None):\n1490         \"\"\"\n1491         Returns a subplot of Shear Force, Bending Moment,\n1492         Slope and Deflection of the Beam object.\n1493 \n1494         Parameters\n1495         ==========\n1496 \n1497         subs : dictionary\n1498                Python dictionary containing Symbols as key and their\n1499                corresponding values.\n1500 \n1501         Examples\n1502         ========\n1503 \n1504         There is a beam of length 8 meters. A constant distributed load of 10 KN/m\n1505         is applied from half of the beam till the end. There are two simple supports\n1506         below the beam, one at the starting point and another at the ending point\n1507         of the beam. A pointload of magnitude 5 KN is also applied from top of the\n1508         beam, at a distance of 4 meters from the starting point.\n1509         Take E = 200 GPa and I = 400*(10**-6) meter**4.\n1510 \n1511         Using the sign convention of downwards forces being positive.\n1512 \n1513         .. plot::\n1514             :context: close-figs\n1515             :format: doctest\n1516             :include-source: True\n1517 \n1518             >>> from sympy.physics.continuum_mechanics.beam import Beam\n1519             >>> from sympy import symbols\n1520             >>> R1, R2 = symbols('R1, R2')\n1521             >>> b = Beam(8, 200*(10**9), 400*(10**-6))\n1522             >>> b.apply_load(5000, 2, -1)\n1523             >>> b.apply_load(R1, 0, -1)\n1524             >>> b.apply_load(R2, 8, -1)\n1525             >>> b.apply_load(10000, 4, 0, end=8)\n1526             >>> b.bc_deflection = [(0, 0), (8, 0)]\n1527             >>> b.solve_for_reaction_loads(R1, R2)\n1528             >>> axes = b.plot_loading_results()\n1529         \"\"\"\n1530         length = self.length\n1531         variable = self.variable\n1532         if subs is None:\n1533             subs = {}\n1534         for sym in self.deflection().atoms(Symbol):\n1535             if sym == self.variable:\n1536                 continue\n1537             if sym not in subs:\n1538                 raise ValueError('Value of %s was not passed.' %sym)\n1539         if self.length in subs:\n1540             length = subs[self.length]\n1541         else:\n1542             length = self.length\n1543 \n1544         ax1 = plot(self.shear_force().subs(subs), (variable, 0, length),\n1545                    title=\"Shear Force\", xlabel=r'$\\mathrm{x}$', ylabel=r'$\\mathrm{V}$',\n1546                    line_color='g', show=False)\n1547         ax2 = plot(self.bending_moment().subs(subs), (variable, 0, length),\n1548                    title=\"Bending Moment\", xlabel=r'$\\mathrm{x}$', ylabel=r'$\\mathrm{M}$',\n1549                    line_color='b', show=False)\n1550         ax3 = plot(self.slope().subs(subs), (variable, 0, length),\n1551                    title=\"Slope\", xlabel=r'$\\mathrm{x}$', ylabel=r'$\\theta$',\n1552                    line_color='m', show=False)\n1553         ax4 = plot(self.deflection().subs(subs), (variable, 0, length),\n1554                    title=\"Deflection\", xlabel=r'$\\mathrm{x}$', ylabel=r'$\\delta$',\n1555                    line_color='r', show=False)\n1556 \n1557         return PlotGrid(4, 1, ax1, ax2, ax3, ax4)\n1558 \n1559 \n1560     @doctest_depends_on(modules=('numpy',))\n1561     def draw(self, pictorial=True):\n1562         \"\"\"\n1563         Returns a plot object representing the beam diagram of the beam.\n1564 \n1565         .. note::\n1566             The user must be careful while entering load values.\n1567             The draw function assumes a sign convention which is used\n1568             for plotting loads.\n1569             Given a right handed coordinate system with XYZ coordinates,\n1570             the beam's length is assumed to be along the positive X axis.\n1571             The draw function recognizes positve loads(with n>-2) as loads\n1572             acting along negative Y direction and positve moments acting\n1573             along positive Z direction.\n1574 \n1575         Parameters\n1576         ==========\n1577 \n1578         pictorial: Boolean (default=True)\n1579             Setting ``pictorial=True`` would simply create a pictorial (scaled) view\n1580             of the beam diagram not with the exact dimensions.\n1581             Although setting ``pictorial=False`` would create a beam diagram with\n1582             the exact dimensions on the plot\n1583 \n1584         Examples\n1585         ========\n1586 \n1587         .. plot::\n1588             :context: close-figs\n1589             :format: doctest\n1590             :include-source: True\n1591 \n1592             >>> from sympy.physics.continuum_mechanics.beam import Beam\n1593             >>> from sympy import symbols\n1594             >>> R1, R2 = symbols('R1, R2')\n1595             >>> E, I = symbols('E, I')\n1596             >>> b = Beam(50, 20, 30)\n1597             >>> b.apply_load(10, 2, -1)\n1598             >>> b.apply_load(R1, 10, -1)\n1599             >>> b.apply_load(R2, 30, -1)\n1600             >>> b.apply_load(90, 5, 0, 23)\n1601             >>> b.apply_load(10, 30, 1, 50)\n1602             >>> b.apply_support(50, \"pin\")\n1603             >>> b.apply_support(0, \"fixed\")\n1604             >>> b.apply_support(20, \"roller\")\n1605             >>> p = b.draw()\n1606             >>> p\n1607             Plot object containing:\n1608             [0]: cartesian line: 25*SingularityFunction(x, 5, 0) - 25*SingularityFunction(x, 23, 0)\n1609             + SingularityFunction(x, 30, 1) - 20*SingularityFunction(x, 50, 0)\n1610             - SingularityFunction(x, 50, 1) + 5 for x over (0.0, 50.0)\n1611             [1]: cartesian line: 5 for x over (0.0, 50.0)\n1612             >>> p.show()\n1613 \n1614         \"\"\"\n1615         if not numpy:\n1616             raise ImportError(\"To use this function numpy module is required\")\n1617 \n1618         x = self.variable\n1619 \n1620         # checking whether length is an expression in terms of any Symbol.\n1621         from sympy import Expr\n1622         if isinstance(self.length, Expr):\n1623             l = list(self.length.atoms(Symbol))\n1624             # assigning every Symbol a default value of 10\n1625             l = {i:10 for i in l}\n1626             length = self.length.subs(l)\n1627         else:\n1628             l = {}\n1629             length = self.length\n1630         height = length/10\n1631 \n1632         rectangles = []\n1633         rectangles.append({'xy':(0, 0), 'width':length, 'height': height, 'facecolor':\"brown\"})\n1634         annotations, markers, load_eq,load_eq1, fill = self._draw_load(pictorial, length, l)\n1635         support_markers, support_rectangles = self._draw_supports(length, l)\n1636 \n1637         rectangles += support_rectangles\n1638         markers += support_markers\n1639 \n1640         sing_plot = plot(height + load_eq, height + load_eq1, (x, 0, length),\n1641          xlim=(-height, length + height), ylim=(-length, 1.25*length), annotations=annotations,\n1642           markers=markers, rectangles=rectangles, line_color='brown', fill=fill, axis=False, show=False)\n1643 \n1644         return sing_plot\n1645 \n1646 \n1647     def _draw_load(self, pictorial, length, l):\n1648         loads = list(set(self.applied_loads) - set(self._support_as_loads))\n1649         height = length/10\n1650         x = self.variable\n1651 \n1652         annotations = []\n1653         markers = []\n1654         load_args = []\n1655         scaled_load = 0\n1656         load_args1 = []\n1657         scaled_load1 = 0\n1658         load_eq = 0     # For positive valued higher order loads\n1659         load_eq1 = 0    # For negative valued higher order loads\n1660         fill = None\n1661         plus = 0        # For positive valued higher order loads\n1662         minus = 0       # For negative valued higher order loads\n1663         for load in loads:\n1664 \n1665             # check if the position of load is in terms of the beam length.\n1666             if l:\n1667                 pos =  load[1].subs(l)\n1668             else:\n1669                 pos = load[1]\n1670 \n1671             # point loads\n1672             if load[2] == -1:\n1673                 if isinstance(load[0], Symbol) or load[0].is_negative:\n1674                     annotations.append({'s':'', 'xy':(pos, 0), 'xytext':(pos, height - 4*height), 'arrowprops':dict(width= 1.5, headlength=5, headwidth=5, facecolor='black')})\n1675                 else:\n1676                     annotations.append({'s':'', 'xy':(pos, height),  'xytext':(pos, height*4), 'arrowprops':dict(width= 1.5, headlength=4, headwidth=4, facecolor='black')})\n1677             # moment loads\n1678             elif load[2] == -2:\n1679                 if load[0].is_negative:\n1680                     markers.append({'args':[[pos], [height/2]], 'marker': r'$\\circlearrowright$', 'markersize':15})\n1681                 else:\n1682                     markers.append({'args':[[pos], [height/2]], 'marker': r'$\\circlearrowleft$', 'markersize':15})\n1683             # higher order loads\n1684             elif load[2] >= 0:\n1685                 # `fill` will be assigned only when higher order loads are present\n1686                 value, start, order, end = load\n1687                 # Positive loads have their seperate equations\n1688                 if(value>0):\n1689                     plus = 1\n1690                 # if pictorial is True we remake the load equation again with\n1691                 # some constant magnitude values.\n1692                     if pictorial:\n1693                         value = 10**(1-order) if order > 0 else length/2\n1694                         scaled_load += value*SingularityFunction(x, start, order)\n1695                         if end:\n1696                             f2 = 10**(1-order)*x**order if order > 0 else length/2*x**order\n1697                             for i in range(0, order + 1):\n1698                                 scaled_load -= (f2.diff(x, i).subs(x, end - start)*\n1699                                                SingularityFunction(x, end, i)/factorial(i))\n1700 \n1701                     if pictorial:\n1702                         if isinstance(scaled_load, Add):\n1703                             load_args = scaled_load.args\n1704                         else:\n1705                             # when the load equation consists of only a single term\n1706                             load_args = (scaled_load,)\n1707                         load_eq = [i.subs(l) for i in load_args]\n1708                     else:\n1709                         if isinstance(self.load, Add):\n1710                             load_args = self.load.args\n1711                         else:\n1712                             load_args = (self.load,)\n1713                         load_eq = [i.subs(l) for i in load_args if list(i.atoms(SingularityFunction))[0].args[2] >= 0]\n1714                     load_eq = Add(*load_eq)\n1715 \n1716                     # filling higher order loads with colour\n1717                     expr = height + load_eq.rewrite(Piecewise)\n1718                     y1 = lambdify(x, expr, 'numpy')\n1719 \n1720                 # For loads with negative value\n1721                 else:\n1722                     minus = 1\n1723                     # if pictorial is True we remake the load equation again with\n1724                     # some constant magnitude values.\n1725                     if pictorial:\n1726                         value = 10**(1-order) if order > 0 else length/2\n1727                         scaled_load1 += value*SingularityFunction(x, start, order)\n1728                         if end:\n1729                             f2 = 10**(1-order)*x**order if order > 0 else length/2*x**order\n1730                             for i in range(0, order + 1):\n1731                                 scaled_load1 -= (f2.diff(x, i).subs(x, end - start)*\n1732                                                SingularityFunction(x, end, i)/factorial(i))\n1733 \n1734                     if pictorial:\n1735                         if isinstance(scaled_load1, Add):\n1736                             load_args1 = scaled_load1.args\n1737                         else:\n1738                             # when the load equation consists of only a single term\n1739                             load_args1 = (scaled_load1,)\n1740                         load_eq1 = [i.subs(l) for i in load_args1]\n1741                     else:\n1742                         if isinstance(self.load, Add):\n1743                             load_args1 = self.load.args1\n1744                         else:\n1745                             load_args1 = (self.load,)\n1746                         load_eq1 = [i.subs(l) for i in load_args if list(i.atoms(SingularityFunction))[0].args[2] >= 0]\n1747                     load_eq1 = -Add(*load_eq1)-height\n1748 \n1749                     # filling higher order loads with colour\n1750                     expr = height + load_eq1.rewrite(Piecewise)\n1751                     y1_ = lambdify(x, expr, 'numpy')\n1752 \n1753                 y = numpy.arange(0, float(length), 0.001)\n1754                 y2 = float(height)\n1755 \n1756                 if(plus == 1 and minus == 1):\n1757                     fill = {'x': y, 'y1': y1(y), 'y2': y1_(y), 'color':'darkkhaki'}\n1758                 elif(plus == 1):\n1759                     fill = {'x': y, 'y1': y1(y), 'y2': y2, 'color':'darkkhaki'}\n1760                 else:\n1761                     fill = {'x': y, 'y1': y1_(y), 'y2': y2 , 'color':'darkkhaki'}\n1762         return annotations, markers, load_eq, load_eq1, fill\n1763 \n1764 \n1765     def _draw_supports(self, length, l):\n1766         height = float(length/10)\n1767 \n1768         support_markers = []\n1769         support_rectangles = []\n1770         for support in self._applied_supports:\n1771             if l:\n1772                 pos =  support[0].subs(l)\n1773             else:\n1774                 pos = support[0]\n1775 \n1776             if support[1] == \"pin\":\n1777                 support_markers.append({'args':[pos, [0]], 'marker':6, 'markersize':13, 'color':\"black\"})\n1778 \n1779             elif support[1] == \"roller\":\n1780                 support_markers.append({'args':[pos, [-height/2.5]], 'marker':'o', 'markersize':11, 'color':\"black\"})\n1781 \n1782             elif support[1] == \"fixed\":\n1783                 if pos == 0:\n1784                     support_rectangles.append({'xy':(0, -3*height), 'width':-length/20, 'height':6*height + height, 'fill':False, 'hatch':'/////'})\n1785                 else:\n1786                     support_rectangles.append({'xy':(length, -3*height), 'width':length/20, 'height': 6*height + height, 'fill':False, 'hatch':'/////'})\n1787 \n1788         return support_markers, support_rectangles\n1789 \n\nThought:\n", "system_response": "Based on the query, here is the relevant source code:\n\nAction:\n```\n{\n  \"action\": \"open_file\",\n  \"action_input\": {\n    \"relative_file_path\": \"sympy/physics/continuum_mechanics/beam.py\",\n    \"start_line\": 22,\n    \"end_line\": 842,\n    \"keywords\": [\"Beam\", \"shear_force\"]\n  }\n}\n```\n\n"}