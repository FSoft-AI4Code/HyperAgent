{"system_prompt": "You are an expert in programming, you're so good at code navigation inside large repository. Try to combine different tools to seek related information to the query inside the project. Some good combinations of tools could be get_folder_structure -> find symbols of each file inside the directory. Semantic search -> exact code search -> go to definition and etc. If you know exactly the name of the symbol, you can use code_search tool or if you know the line and the name of the symbol, you can use go_to_definition tool. Try to avoid using open_file tool frequently (use the get all symbols instead). Respond to the human as helpfully and accurately as possible. Consider use other tools if the results returned is not cleared enough or failed for the query. You have access to the following tools:\n\ncode_search: Useful when you want to find all matched identifiers (variable, function, class name) from a python repository, primarily used for class, function search. The results\n    are mixed and not sorted by any criteria. So considered using this when you want to find all possible candidates for a given name. Otherwise, consider using other tools for more precise results, args: {'names': {'title': 'Names', 'description': 'The names of the identifiers to search', 'type': 'array', 'items': {'type': 'string'}}}\nSemantic Code Search: useful for when the query is a sentance, semantic and vague. If exact search such as code search failed after multiple tries, try this, args: {'tool_input': {'type': 'string'}}\ngo_to_definition: Useful when you want to find the definition of a symbol inside a code snippet if the current context is not cleared enough such as \n    0 import matplotlib.pyplot as plt\n    1 class Directory(object):\n    2\n    3    def add_member(self, id, name):\n    4        self.members[id] = plt.figure() we might want to find the definition of plt.figure() invoke with params (\"figure\", 4, 'test.py'), args: {'word': {'title': 'Word', 'type': 'string'}, 'line': {'title': 'Line', 'type': 'integer'}, 'relative_path': {'title': 'Relative Path', 'type': 'string'}}\nfind_all_references: Given a code snippet that contains target symbol, find all references of this symbol inside the project.\n    , args: {'word': {'title': 'Word', 'type': 'string'}, 'line': {'title': 'Line', 'type': 'integer'}, 'relative_path': {'title': 'Relative Path', 'type': 'string'}, 'reranking': {'title': 'Reranking', 'default': False, 'type': 'boolean'}, 'query': {'title': 'Query', 'default': '', 'type': 'string'}}\nget_all_symbols: Useful when you want to find all symbols (functions, classes, methods) of a python file, args: {'path_to_file': {'title': 'Path To File', 'type': 'string'}, 'verbose_level': {'title': 'Verbose Level', 'default': 1, 'type': 'integer'}}\nget_folder_structure: Useful when you want to explore the tree structure of a folder, good for initial exploration with knowing the parent folder name. Remember to provide the relative path correctly.\n    , args: {'relative_path': {'title': 'Relative Path', 'type': 'string'}, 'level': {'title': 'Level', 'default': 2, 'type': 'integer'}}\nopen_file: Useful when you want to open a file inside a repo, use this tool only when it's very necessary, usually a main or server or training script. Consider combinining other alternative tools such as GetAllSymbols and CodeSearch to save the number of tokens for other cases., args: {'relative_file_path': {'title': 'Relative File Path', 'type': 'string'}, 'max_new_line': {'title': 'Max New Line', 'default': 500, 'type': 'integer'}}\n\nUse a json blob to specify a tool by providing an action key (tool name) and an action_input key (tool input).\n\nValid \"action\" values: \"Final Answer\" or code_search, Semantic Code Search, go_to_definition, find_all_references, get_all_symbols, get_folder_structure, open_file\n\nProvide only ONE action per $JSON_BLOB, as shown:\n\n```\n{\n  \"action\": $TOOL_NAME,\n  \"action_input\": $INPUT\n}\n```\n\nFollow this format:\n\nQuestion: input question to answer\nThought: consider previous and subsequent steps, notes down some useful information (like code snippet) from observation\nAction:\n```\n$JSON_BLOB\n```\nObservation: action result\n... (repeat Thought/Action/Observation N times)\nThought: I know what to respond\nAction:\n```\n{\n  \"action\": \"Final Answer\",\n  \"action_input\": \"Final response to human\"\n}\n```\n\nBegin! Reminder to ALWAYS respond with a valid json blob of a single action. Use tools if necessary. Respond directly if you have gathered enough information from the repository. Format is Action:```$JSON_BLOB```then Observation:.", "human_message": "Human request: get the class hierarchy of the IO registry module\n\nPrevious steps: steps=[]\n\nCurrent objective: value=\"Use the 'get_folder_structure' tool to explore the 'io' directory and identify the files that may contain the IO registry module.\"\n\nThis was your previous work (but I haven't seen any of it! I only see what you return as final answer):\nAction:\n```\n{\n  \"action\": \"get_folder_structure\",\n  \"action_input\": {\n    \"relative_path\": \"io\",\n    \"level\": 2\n  }\n}\n```\n\nObservation: Execution failed, please check the relative path again, likely the relative path lacks of prefix directory name\nThought:The previous attempt to get the folder structure of the 'io' directory failed due to an incorrect relative path. I need to find the correct path to the 'io' directory.\n\nAction:\n```\n{\n  \"action\": \"get_folder_structure\",\n  \"action_input\": {\n    \"relative_path\": \"\",\n    \"level\": 1\n  }\n}\n```\nObservation: The tree structure of  is: \nrepo__astropy__astropy__commit__\n\u251c\u2500\u2500 .git\n\u251c\u2500\u2500 .astropy-root\n\u251c\u2500\u2500 .circleci\n\u251c\u2500\u2500 .devcontainer\n\u251c\u2500\u2500 .flake8\n\u251c\u2500\u2500 .git-blame-ignore-revs\n\u251c\u2500\u2500 .gitattributes\n\u251c\u2500\u2500 .github\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 .mailmap\n\u251c\u2500\u2500 .pre-commit-config.yaml\n\u251c\u2500\u2500 .pycodestyle\n\u251c\u2500\u2500 .pyinstaller\n\u251c\u2500\u2500 .readthedocs.yaml\n\u251c\u2500\u2500 .ruff.toml\n\u251c\u2500\u2500 CHANGES.rst\n\u251c\u2500\u2500 CITATION\n\u251c\u2500\u2500 CODE_OF_CONDUCT.md\n\u251c\u2500\u2500 CONTRIBUTING.md\n\u251c\u2500\u2500 GOVERNANCE.md\n\u251c\u2500\u2500 LICENSE.rst\n\u251c\u2500\u2500 MANIFEST.in\n\u251c\u2500\u2500 README.rst\n\u251c\u2500\u2500 SECURITY.md\n\u251c\u2500\u2500 astropy\n\u251c\u2500\u2500 cextern\n\u251c\u2500\u2500 codecov.yml\n\u251c\u2500\u2500 conftest.py\n\u251c\u2500\u2500 docs\n\u251c\u2500\u2500 examples\n\u251c\u2500\u2500 licenses\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 tox.ini\n\n10 directories, 24 files\nThought:The 'io' directory is likely to be a subdirectory within the 'astropy' directory. I should explore the 'astropy' directory to find the 'io' subdirectory.\n\nAction:\n```\n{\n  \"action\": \"get_folder_structure\",\n  \"action_input\": {\n    \"relative_path\": \"astropy\",\n    \"level\": 2\n  }\n}\n```\n\nObservation: The tree structure of astropy is: \nastropy\n\u251c\u2500\u2500 CITATION\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 _dev\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 scm_version.py\n\u251c\u2500\u2500 config\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 configuration.py\n\u2502   \u251c\u2500\u2500 paths.py\n\u2502   \u2514\u2500\u2500 tests\n\u251c\u2500\u2500 conftest.py\n\u251c\u2500\u2500 constants\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 astropyconst13.py\n\u2502   \u251c\u2500\u2500 astropyconst20.py\n\u2502   \u251c\u2500\u2500 astropyconst40.py\n\u2502   \u251c\u2500\u2500 cgs.py\n\u2502   \u251c\u2500\u2500 codata2010.py\n\u2502   \u251c\u2500\u2500 codata2014.py\n\u2502   \u251c\u2500\u2500 codata2018.py\n\u2502   \u251c\u2500\u2500 config.py\n\u2502   \u251c\u2500\u2500 constant.py\n\u2502   \u251c\u2500\u2500 iau2012.py\n\u2502   \u251c\u2500\u2500 iau2015.py\n\u2502   \u251c\u2500\u2500 si.py\n\u2502   \u251c\u2500\u2500 tests\n\u2502   \u2514\u2500\u2500 utils.py\n\u251c\u2500\u2500 convolution\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 _convolve.pyx\n\u2502   \u251c\u2500\u2500 convolve.py\n\u2502   \u251c\u2500\u2500 core.py\n\u2502   \u251c\u2500\u2500 kernels.py\n\u2502   \u251c\u2500\u2500 setup_package.py\n\u2502   \u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 tests\n\u2502   \u2514\u2500\u2500 utils.py\n\u251c\u2500\u2500 coordinates\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 angles\n\u2502   \u251c\u2500\u2500 attributes.py\n\u2502   \u251c\u2500\u2500 baseframe.py\n\u2502   \u251c\u2500\u2500 builtin_frames\n\u2502   \u251c\u2500\u2500 calculation.py\n\u2502   \u251c\u2500\u2500 data\n\u2502   \u251c\u2500\u2500 distances.py\n\u2502   \u251c\u2500\u2500 earth.py\n\u2502   \u251c\u2500\u2500 earth_orientation.py\n\u2502   \u251c\u2500\u2500 erfa_astrom.py\n\u2502   \u251c\u2500\u2500 errors.py\n\u2502   \u251c\u2500\u2500 funcs.py\n\u2502   \u251c\u2500\u2500 jparser.py\n\u2502   \u251c\u2500\u2500 matching.py\n\u2502   \u251c\u2500\u2500 matrix_utilities.py\n\u2502   \u251c\u2500\u2500 name_resolve.py\n\u2502   \u251c\u2500\u2500 polarization.py\n\u2502   \u251c\u2500\u2500 representation\n\u2502   \u251c\u2500\u2500 sites.py\n\u2502   \u251c\u2500\u2500 sky_coordinate.py\n\u2502   \u251c\u2500\u2500 sky_coordinate_parsers.py\n\u2502   \u251c\u2500\u2500 solar_system.py\n\u2502   \u251c\u2500\u2500 spectral_coordinate.py\n\u2502   \u251c\u2500\u2500 spectral_quantity.py\n\u2502   \u251c\u2500\u2500 tests\n\u2502   \u2514\u2500\u2500 transformations.py\n\u251c\u2500\u2500 cosmology\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 _io\n\u2502   \u251c\u2500\u2500 _utils.py\n\u2502   \u251c\u2500\u2500 connect.py\n\u2502   \u251c\u2500\u2500 core.py\n\u2502   \u251c\u2500\u2500 data\n\u2502   \u251c\u2500\u2500 flrw\n\u2502   \u251c\u2500\u2500 funcs\n\u2502   \u251c\u2500\u2500 parameter\n\u2502   \u251c\u2500\u2500 parameters.py\n\u2502   \u251c\u2500\u2500 realizations.py\n\u2502   \u251c\u2500\u2500 tests\n\u2502   \u251c\u2500\u2500 units.py\n\u2502   \u2514\u2500\u2500 utils.py\n\u251c\u2500\u2500 extern\n\u2502   \u251c\u2500\u2500 README.rst\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 _strptime.py\n\u2502   \u251c\u2500\u2500 configobj\n\u2502   \u251c\u2500\u2500 jquery\n\u2502   \u2514\u2500\u2500 ply\n\u251c\u2500\u2500 io\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 ascii\n\u2502   \u251c\u2500\u2500 fits\n\u2502   \u251c\u2500\u2500 misc\n\u2502   \u251c\u2500\u2500 registry\n\u2502   \u251c\u2500\u2500 tests\n\u2502   \u2514\u2500\u2500 votable\n\u251c\u2500\u2500 logger.py\n\u251c\u2500\u2500 modeling\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 bounding_box.py\n\u2502   \u251c\u2500\u2500 convolution.py\n\u2502   \u251c\u2500\u2500 core.py\n\u2502   \u251c\u2500\u2500 fitting.py\n\u2502   \u251c\u2500\u2500 functional_models.py\n\u2502   \u251c\u2500\u2500 mappings.py\n\u2502   \u251c\u2500\u2500 math_functions.py\n\u2502   \u251c\u2500\u2500 models\n\u2502   \u251c\u2500\u2500 optimizers.py\n\u2502   \u251c\u2500\u2500 parameters.py\n\u2502   \u251c\u2500\u2500 physical_models.py\n\u2502   \u251c\u2500\u2500 polynomial.py\n\u2502   \u251c\u2500\u2500 powerlaws.py\n\u2502   \u251c\u2500\u2500 projections.py\n\u2502   \u251c\u2500\u2500 rotations.py\n\u2502   \u251c\u2500\u2500 separable.py\n\u2502   \u251c\u2500\u2500 spline.py\n\u2502   \u251c\u2500\u2500 statistic.py\n\u2502   \u251c\u2500\u2500 tabular.py\n\u2502   \u251c\u2500\u2500 tests\n\u2502   \u2514\u2500\u2500 utils.py\n\u251c\u2500\u2500 nddata\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 _testing.py\n\u2502   \u251c\u2500\u2500 bitmask.py\n\u2502   \u251c\u2500\u2500 blocks.py\n\u2502   \u251c\u2500\u2500 ccddata.py\n\u2502   \u251c\u2500\u2500 compat.py\n\u2502   \u251c\u2500\u2500 decorators.py\n\u2502   \u251c\u2500\u2500 flag_collection.py\n\u2502   \u251c\u2500\u2500 mixins\n\u2502   \u251c\u2500\u2500 nddata.py\n\u2502   \u251c\u2500\u2500 nddata_base.py\n\u2502   \u251c\u2500\u2500 nddata_withmixins.py\n\u2502   \u251c\u2500\u2500 nduncertainty.py\n\u2502   \u251c\u2500\u2500 tests\n\u2502   \u2514\u2500\u2500 utils.py\n\u251c\u2500\u2500 samp\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 client.py\n\u2502   \u251c\u2500\u2500 constants.py\n\u2502   \u251c\u2500\u2500 data\n\u2502   \u251c\u2500\u2500 errors.py\n\u2502   \u251c\u2500\u2500 hub.py\n\u2502   \u251c\u2500\u2500 hub_proxy.py\n\u2502   \u251c\u2500\u2500 hub_script.py\n\u2502   \u251c\u2500\u2500 integrated_client.py\n\u2502   \u251c\u2500\u2500 lockfile_helpers.py\n\u2502   \u251c\u2500\u2500 setup_package.py\n\u2502   \u251c\u2500\u2500 standard_profile.py\n\u2502   \u251c\u2500\u2500 tests\n\u2502   \u251c\u2500\u2500 utils.py\n\u2502   \u2514\u2500\u2500 web_profile.py\n\u251c\u2500\u2500 stats\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 _stats.pyx\n\u2502   \u251c\u2500\u2500 bayesian_blocks.py\n\u2502   \u251c\u2500\u2500 biweight.py\n\u2502   \u251c\u2500\u2500 circstats.py\n\u2502   \u251c\u2500\u2500 funcs.py\n\u2502   \u251c\u2500\u2500 histogram.py\n\u2502   \u251c\u2500\u2500 info_theory.py\n\u2502   \u251c\u2500\u2500 jackknife.py\n\u2502   \u251c\u2500\u2500 setup_package.py\n\u2502   \u251c\u2500\u2500 sigma_clipping.py\n\u2502   \u251c\u2500\u2500 spatial.py\n\u2502   \u251c\u2500\u2500 src\n\u2502   \u2514\u2500\u2500 tests\n\u251c\u2500\u2500 table\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 _column_mixins.pyx\n\u2502   \u251c\u2500\u2500 _np_utils.pyx\n\u2502   \u251c\u2500\u2500 bst.py\n\u2502   \u251c\u2500\u2500 column.py\n\u2502   \u251c\u2500\u2500 connect.py\n\u2502   \u251c\u2500\u2500 groups.py\n\u2502   \u251c\u2500\u2500 index.py\n\u2502   \u251c\u2500\u2500 info.py\n\u2502   \u251c\u2500\u2500 jsviewer.py\n\u2502   \u251c\u2500\u2500 meta.py\n\u2502   \u251c\u2500\u2500 mixins\n\u2502   \u251c\u2500\u2500 ndarray_mixin.py\n\u2502   \u251c\u2500\u2500 np_utils.py\n\u2502   \u251c\u2500\u2500 operations.py\n\u2502   \u251c\u2500\u2500 pandas.py\n\u2502   \u251c\u2500\u2500 pprint.py\n\u2502   \u251c\u2500\u2500 row.py\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 serialize.py\n\u2502   \u251c\u2500\u2500 setup_package.py\n\u2502   \u251c\u2500\u2500 soco.py\n\u2502   \u251c\u2500\u2500 sorted_array.py\n\u2502   \u251c\u2500\u2500 table.py\n\u2502   \u251c\u2500\u2500 table_helpers.py\n\u2502   \u2514\u2500\u2500 tests\n\u251c\u2500\u2500 tests\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 command.py\n\u2502   \u251c\u2500\u2500 figures\n\u2502   \u251c\u2500\u2500 helper.py\n\u2502   \u251c\u2500\u2500 runner.py\n\u2502   \u251c\u2500\u2500 test_logger.py\n\u2502   \u2514\u2500\u2500 tests\n\u251c\u2500\u2500 time\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 core.py\n\u2502   \u251c\u2500\u2500 formats.py\n\u2502   \u251c\u2500\u2500 setup_package.py\n\u2502   \u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 tests\n\u2502   \u251c\u2500\u2500 time_helper\n\u2502   \u2514\u2500\u2500 utils.py\n\u251c\u2500\u2500 timeseries\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 binned.py\n\u2502   \u251c\u2500\u2500 core.py\n\u2502   \u251c\u2500\u2500 downsample.py\n\u2502   \u251c\u2500\u2500 io\n\u2502   \u251c\u2500\u2500 periodograms\n\u2502   \u251c\u2500\u2500 sampled.py\n\u2502   \u2514\u2500\u2500 tests\n\u251c\u2500\u2500 uncertainty\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 core.py\n\u2502   \u251c\u2500\u2500 distributions.py\n\u2502   \u251c\u2500\u2500 function_helpers.py\n\u2502   \u2514\u2500\u2500 tests\n\u251c\u2500\u2500 units\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 astrophys.py\n\u2502   \u251c\u2500\u2500 cds.py\n\u2502   \u251c\u2500\u2500 cgs.py\n\u2502   \u251c\u2500\u2500 core.py\n\u2502   \u251c\u2500\u2500 decorators.py\n\u2502   \u251c\u2500\u2500 deprecated.py\n\u2502   \u251c\u2500\u2500 equivalencies.py\n\u2502   \u251c\u2500\u2500 format\n\u2502   \u251c\u2500\u2500 function\n\u2502   \u251c\u2500\u2500 imperial.py\n\u2502   \u251c\u2500\u2500 misc.py\n\u2502   \u251c\u2500\u2500 photometric.py\n\u2502   \u251c\u2500\u2500 physical.py\n\u2502   \u251c\u2500\u2500 quantity.py\n\u2502   \u251c\u2500\u2500 quantity_helper\n\u2502   \u251c\u2500\u2500 required_by_vounit.py\n\u2502   \u251c\u2500\u2500 si.py\n\u2502   \u251c\u2500\u2500 structured.py\n\u2502   \u251c\u2500\u2500 tests\n\u2502   \u2514\u2500\u2500 utils.py\n\u251c\u2500\u2500 utils\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 argparse.py\n\u2502   \u251c\u2500\u2500 codegen.py\n\u2502   \u251c\u2500\u2500 collections.py\n\u2502   \u251c\u2500\u2500 compat\n\u2502   \u251c\u2500\u2500 console.py\n\u2502   \u251c\u2500\u2500 data.py\n\u2502   \u251c\u2500\u2500 data_info.py\n\u2502   \u251c\u2500\u2500 decorators.py\n\u2502   \u251c\u2500\u2500 diff.py\n\u2502   \u251c\u2500\u2500 exceptions.py\n\u2502   \u251c\u2500\u2500 iers\n\u2502   \u251c\u2500\u2500 introspection.py\n\u2502   \u251c\u2500\u2500 masked\n\u2502   \u251c\u2500\u2500 metadata\n\u2502   \u251c\u2500\u2500 misc.py\n\u2502   \u251c\u2500\u2500 parsing.py\n\u2502   \u251c\u2500\u2500 setup_package.py\n\u2502   \u251c\u2500\u2500 shapes.py\n\u2502   \u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 state.py\n\u2502   \u251c\u2500\u2500 tests\n\u2502   \u2514\u2500\u2500 xml\n\u251c\u2500\u2500 version.py\n\u251c\u2500\u2500 visualization\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 hist.py\n\u2502   \u251c\u2500\u2500 interval.py\n\u2502   \u251c\u2500\u2500 lupton_rgb.py\n\u2502   \u251c\u2500\u2500 mpl_normalize.py\n\u2502   \u251c\u2500\u2500 mpl_style.py\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 stretch.py\n\u2502   \u251c\u2500\u2500 tests\n\u2502   \u251c\u2500\u2500 time.py\n\u2502   \u251c\u2500\u2500 transform.py\n\u2502   \u251c\u2500\u2500 units.py\n\u2502   \u2514\u2500\u2500 wcsaxes\n\u2514\u2500\u2500 wcs\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 docstrings.py\n    \u251c\u2500\u2500 include\n    \u251c\u2500\u2500 setup_package.py\n    \u251c\u2500\u2500 src\n    \u251c\u2500\u2500 tests\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 wcs.py\n    \u251c\u2500\u2500 wcsapi\n    \u2514\u2500\u2500 wcslint.py\n\n83 directories, 214 files\nThought:The 'io' directory has been found within the 'astropy' directory. It contains several subdirectories, one of which is 'registry'. This is likely where the IO registry module is located. I should now list all the symbols in the 'registry.py' file to understand the class hierarchy within that module.\n\nAction:\n```\n{\n  \"action\": \"get_all_symbols\",\n  \"action_input\": {\n    \"path_to_file\": \"astropy/io/registry.py\",\n    \"verbose_level\": 2\n  }\n}\n```\n\nObservation: The tool cannot open the file, the file path astropy/io/registry.py is not correct.\nThought:The path provided for 'registry.py' within the 'io' directory seems to be incorrect. Since the 'io' directory contains a subdirectory named 'registry', the 'registry.py' file might be inside this subdirectory. I should adjust the path to include the 'registry' subdirectory and try to list all symbols again.\n\nAction:\n```\n{\n  \"action\": \"get_all_symbols\",\n  \"action_input\": {\n    \"path_to_file\": \"astropy/io/registry/registry.py\",\n    \"verbose_level\": 2\n  }\n}\n```\nObservation: The tool cannot open the file, the file path astropy/io/registry/registry.py is not correct.\nThought:The path to 'registry.py' is still incorrect. Since the 'registry' directory is listed under 'io', it may contain an '__init__.py' file or other Python files that define the IO registry module. I should explore the 'registry' directory to find the correct file that contains the class hierarchy.\n\nAction:\n```\n{\n  \"action\": \"get_folder_structure\",\n  \"action_input\": {\n    \"relative_path\": \"astropy/io/registry\",\n    \"level\": 1\n  }\n}\n```\nObservation: The tree structure of astropy/io/registry is: \nregistry\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 base.py\n\u251c\u2500\u2500 compat.py\n\u251c\u2500\u2500 core.py\n\u251c\u2500\u2500 interface.py\n\u2514\u2500\u2500 tests\n\n1 directories, 5 files\nThought:The 'registry' directory contains several Python files, including 'base.py', 'compat.py', 'core.py', and 'interface.py'. These files are likely to define the class hierarchy for the IO registry module. I should list all symbols in each of these files to understand the class hierarchy.\n\nAction:\n```\n{\n  \"action\": \"get_all_symbols\",\n  \"action_input\": {\n    \"path_to_file\": \"astropy/io/registry/core.py\",\n    \"verbose_level\": 2\n  }\n}\n```\nObservation: ['Name: os\\nType: Module\\nPreview: 2 import os\\nDocumentation: {\\'kind\\': \\'markdown\\', \\'value\\': \"```python\\\\nmodule os\\\\n```\\\\n---\\\\n```text\\\\nOS routines for NT or Posix depending on what system we\\'re on.\\\\n\\\\nThis exports:\\\\n  - all functions from posix or nt, e.g. unlink, stat, etc.\\\\n  - os.path is either posixpath or ntpath\\\\n  - os.name is either \\'posix\\' or \\'nt\\'\\\\n  - os.curdir is a string representing the current directory (always \\'.\\')\\\\n  - os.pardir is a string representing the parent directory (always \\'..\\')\\\\n  - os.sep is the (or a most common) pathname separator (\\'/\\' or \\'\\\\\\\\\\\\\\\\\\')\\\\n  - os.extsep is the extension separator (always \\'.\\')\\\\n  - os.altsep is the alternate pathname separator (None or \\'/\\')\\\\n  - os.pathsep is the component separator used in $PATH etc\\\\n  - os.linesep is the line separator in text files (\\'\\\\\\\\r\\' or \\'\\\\\\\\n\\' or \\'\\\\\\\\r\\\\\\\\n\\')\\\\n  - os.defpath is the default search path for executables\\\\n  - os.devnull is the file path of the null device (\\'/dev/null\\', etc.)\\\\n\\\\nPrograms that import and use \\'os\\' stand a better chance of being\\\\nportable between different platforms.  Of course, they must then\\\\nonly use functions that are defined by all platforms (e.g., unlink\\\\nand opendir), and leave all pathname manipulation to os.path\\\\n(e.g., split and join).\\\\n```\"}\\n', 'Name: sys\\nType: Module\\nPreview: 3 import sys\\nDocumentation: {\\'kind\\': \\'markdown\\', \\'value\\': \"```python\\\\nmodule sys\\\\n```\\\\n---\\\\n```text\\\\nThis module provides access to some objects used or maintained by the\\\\ninterpreter and to functions that interact strongly with the interpreter.\\\\n\\\\nDynamic objects:\\\\n\\\\nargv -- command line arguments; argv[0] is the script pathname if known\\\\npath -- module search path; path[0] is the script directory, else \\'\\'\\\\nmodules -- dictionary of loaded modules\\\\n\\\\ndisplayhook -- called to show results in an interactive session\\\\nexcepthook -- called to handle any uncaught exception other than SystemExit\\\\n  To customize printing in an interactive session or to install a custom\\\\n  top-level exception handler, assign other functions to replace these.\\\\n\\\\nstdin -- standard input file object; used by input()\\\\nstdout -- standard output file object; used by print()\\\\nstderr -- standard error object; used for error messages\\\\n  By assigning other file objects (or objects that behave like files)\\\\n  to these, it is possible to redirect all of the interpreter\\'s I/O.\\\\n\\\\nlast_type -- type of last uncaught exception\\\\nlast_value -- value of last uncaught exception\\\\nlast_traceback -- traceback of last uncaught exception\\\\n  These three are only available in an interactive session after a\\\\n  traceback has been printed.\\\\n\\\\nStatic objects:\\\\n\\\\nbuiltin_module_names -- tuple of module names built into this interpreter\\\\ncopyright -- copyright notice pertaining to this interpreter\\\\nexec_prefix -- prefix used to find the machine-specific Python library\\\\nexecutable -- absolute path of the executable binary of the Python interpreter\\\\nfloat_info -- a named tuple with information about the float implementation.\\\\nfloat_repr_style -- string indicating the style of repr() output for floats\\\\nhash_info -- a named tuple with information about the hash algorithm.\\\\nhexversion -- version information encoded as a single integer\\\\nimplementation -- Python implementation information.\\\\nint_info -- a named tuple with information about the int implementation.\\\\nmaxsize -- the largest supported length of containers.\\\\nmaxunicode -- the value of the largest Unicode code point\\\\nplatform -- platform identifier\\\\nprefix -- prefix used to find the Python library\\\\nthread_info -- a named tuple with information about the thread implementation.\\\\nversion -- the version of this interpreter as a string\\\\nversion_info -- version information as a named tuple\\\\n__stdin__ -- the original stdin; don\\'t touch!\\\\n__stdout__ -- the original stdout; don\\'t touch!\\\\n__stderr__ -- the original stderr; don\\'t touch!\\\\n__displayhook__ -- the original displayhook; don\\'t touch!\\\\n__excepthook__ -- the original excepthook; don\\'t touch!\\\\n\\\\nFunctions:\\\\n\\\\ndisplayhook() -- print an object to the screen, and save it in builtins._\\\\nexcepthook() -- print an exception and its traceback to sys.stderr\\\\nexc_info() -- return thread-safe information about the current exception\\\\nexit() -- exit the interpreter by raising SystemExit\\\\ngetdlopenflags() -- returns flags to be used for dlopen() calls\\\\ngetprofile() -- get the global profiling function\\\\ngetrefcount() -- return the reference count for an object (plus one :-)\\\\ngetrecursionlimit() -- return the max recursion depth for the interpreter\\\\ngetsizeof() -- return the size of an object in bytes\\\\ngettrace() -- get the global debug tracing function\\\\nsetdlopenflags() -- set the flags to be used for dlopen() calls\\\\nsetprofile() -- set the global profiling function\\\\nsetrecursionlimit() -- set the max recursion depth for the interpreter\\\\nsettrace() -- set the global debug tracing function\\\\n```\"}\\n', \"Name: IORegistryError\\nType: Class\\nPreview: 5 from .base import IORegistryError, _UnifiedIORegistryBase\\nDocumentation: {'kind': 'markdown', 'value': '```python\\\\nclass IORegistryError(*args: object)\\\\n```\\\\n---\\\\n```text\\\\nCustom error for registry clashes.\\\\n```\\\\n**Full name:** `astropy.io.registry.base.IORegistryError`'}\\n\", 'Name: _UnifiedIORegistryBase\\nType: Class\\nPreview: 5 from .base import IORegistryError, _UnifiedIORegistryBase\\nDocumentation: {\\'kind\\': \\'markdown\\', \\'value\\': \"```python\\\\nclass _UnifiedIORegistryBase()\\\\n```\\\\n---\\\\nBase class for registries in Astropy\\'s Unified IO.\\\\n\\\\nThis base class provides identification functions and miscellaneous\\\\nutilities. For an example how to build a registry subclass we suggest\\\\n`~astropy.io.registry.UnifiedInputRegistry`, which enables\\\\nread-only registries. These higher-level subclasses will probably serve\\\\nbetter as a baseclass, for instance\\\\n`~astropy.io.registry.UnifiedIORegistry` subclasses both\\\\n`~astropy.io.registry.UnifiedInputRegistry` and\\\\n`~astropy.io.registry.UnifiedOutputRegistry` to enable both\\\\nreading from and writing to files.\\\\n\\\\n*Added in 5.0*\\\\n**Full name:** `astropy.io.registry.base._UnifiedIORegistryBase`\"}\\n', \"Name: _expand_user_in_args\\nType: Function\\nPreview: 13 def _expand_user_in_args(args):\\n14     # Conservatively attempt to apply `os.path.expanduser` to the first\\n15     # argument, which can be either a path or the contents of a table.\\n16     if len(args) and isinstance(args[0], PATH_TYPES):\\n17         ex_user = os.path.expanduser(args[0])\\n18         if ex_user != args[0] and os.path.exists(os.path.dirname(ex_user)):\\n19             args = (ex_user,) + args[1:]\\n20     return args\\nDocumentation: {'kind': 'markdown', 'value': '```python\\\\ndef _expand_user_in_args(args)\\\\n```\\\\n---\\\\n**Full name:** `astropy.io.registry.core._expand_user_in_args`'}\\n\", 'Name: UnifiedInputRegistry\\nType: Class\\nPreview: 26 class UnifiedInputRegistry(_UnifiedIORegistryBase):\\n27     \"\"\"Read-only Unified Registry.\\n28 \\n29     .. versionadded:: 5.0\\n30 \\n31     Examples\\n32     --------\\n33     First let\\'s start by creating a read-only registry.\\n34 \\n35     .. code-block:: python\\nDocumentation: {\\'kind\\': \\'markdown\\', \\'value\\': \"```python\\\\nclass UnifiedInputRegistry()\\\\n```\\\\n---\\\\nRead-only Unified Registry.\\\\n\\\\n*Added in 5.0*\\\\n\\\\n#### Examples\\\\n\\\\nFirst let\\'s start by creating a read-only registry.\\\\n\\\\n```python\\\\n>>> from astropy.io.registry import UnifiedInputRegistry\\\\n>>> read_reg = UnifiedInputRegistry()\\\\n```\\\\n\\\\nThere is nothing in this registry. Let\\'s make a reader for the\\\\n`~astropy.table.Table` class\\\\n\\\\n```python\\\\nfrom astropy.table import Table\\\\n\\\\ndef my_table_reader(filename, some_option=1):\\\\n    # Read in the table by any means necessary\\\\n    return table  # should be an instance of Table\\\\n```\\\\n\\\\nSuch a function can then be registered with the I/O registry\\\\n\\\\n```python\\\\nread_reg.register_reader(\\'my-table-format\\', Table, my_table_reader)\\\\n```\\\\n\\\\nNote that we CANNOT then read in a table with\\\\n\\\\n```python\\\\nd = Table.read(\\'my_table_file.mtf\\', format=\\'my-table-format\\')\\\\n```\\\\n\\\\nWhy? because ``Table.read`` uses Astropy\\'s default global registry and this\\\\nis a separate registry.\\\\nInstead we can read by the read method on the registry\\\\n\\\\n```python\\\\nd = read_reg.read(Table, \\'my_table_file.mtf\\', format=\\'my-table-format\\')\\\\n```\\\\n**Full name:** `astropy.io.registry.core.UnifiedInputRegistry`\"}\\n', 'Name: __init__\\nType: Method\\nPreview: 65 def __init__(self):\\n66         super().__init__()  # set _identifiers\\n67         self._readers = {}\\n68         self._registries[\"read\"] = {\"attr\": \"_readers\", \"column\": \"Read\"}\\n69         self._registries_order = (\"read\", \"identify\")\\nDocumentation: {\\'kind\\': \\'markdown\\', \\'value\\': \\'```python\\\\ndef __init__(self)\\\\n```\\\\n---\\\\n**Full name:** `astropy.io.registry.base._UnifiedIORegistryBase.__init__`\\'}\\n', 'Name: register_reader\\nType: Method\\nPreview: 74 def register_reader(\\n75         self, data_format, data_class, function, force=False, priority=0\\n76     ):\\n77         \"\"\"\\n78         Register a reader function.\\n79 \\n80         Parameters\\n81         ----------\\n82         data_format : str\\n83             The data format identifier. This is the string that will be used to\\nDocumentation: {\\'kind\\': \\'markdown\\', \\'value\\': \\'```python\\\\nkeyword def\\\\n```\\\\n---\\\\n```text\\\\nFunction definitions\\\\n********************\\\\n\\\\nA function definition defines a user-defined function object (see\\\\nsection The standard type hierarchy):\\\\n\\\\n   funcdef                   ::= [decorators] \"def\" funcname \"(\" [parameter_list] \")\"\\\\n               [\"->\" expression] \":\" suite\\\\n   decorators                ::= decorator+\\\\n   decorator                 ::= \"@\" assignment_expression NEWLINE\\\\n   parameter_list            ::= defparameter (\",\" defparameter)* \",\" \"/\" [\",\" [parameter_list_no_posonly]]\\\\n                        | parameter_list_no_posonly\\\\n   parameter_list_no_posonly ::= defparameter (\",\" defparameter)* [\",\" [parameter_list_starargs]]\\\\n                                 | parameter_list_starargs\\\\n   parameter_list_starargs   ::= \"*\" [parameter] (\",\" defparameter)* [\",\" [\"**\" parameter [\",\"]]]\\\\n                               | \"**\" parameter [\",\"]\\\\n   parameter                 ::= identifier [\":\" expression]\\\\n   defparameter              ::= parameter [\"=\" expression]\\\\n   funcname                  ::= identifier\\\\n\\\\nA function definition is an executable statement.  Its execution binds\\\\nthe function name in the current local namespace to a function object\\\\n(a wrapper around the executable code for the function).  This\\\\nfunction object contains a reference to the current global namespace\\\\nas the global namespace to be used when the function is called.\\\\n\\\\nThe function definition does not execute the function body; this gets\\\\nexecuted only when the function is called. [4]\\\\n\\\\nA function definition may be wrapped by one or more *decorator*\\\\nexpressions. Decorator expressions are evaluated when the function is\\\\ndefined, in the scope that contains the function definition.  The\\\\nresult must be a callable, which is invoked with the function object\\\\nas the only argument. The returned value is bound to the function name\\\\ninstead of the function object.  Multiple decorators are applied in\\\\nnested fashion. For example, the following code\\\\n\\\\n   @f1(arg)\\\\n   @f2\\\\n   def func(): pass\\\\n\\\\nis roughly equivalent to\\\\n\\\\n   def func(): pass\\\\n   func = f1(arg)(f2(func))\\\\n\\\\nexcept that the original function is not temporarily bound to the name\\\\n\"func\".\\\\n\\\\nChanged in version 3.9: Functions may be decorated with any valid\\\\n\"assignment_expression\". Previously, the grammar was much more\\\\nrestrictive; see **PEP 614** for details.\\\\n\\\\nWhen one or more *parameters* have the form *parameter* \"=\"\\\\n*expression*, the function is said to have \u201cdefault parameter values.\u201d\\\\nFor a parameter with a default value, the corresponding *argument* may\\\\nbe omitted from a call, in which case the parameter\u2019s default value is\\\\nsubstituted.  If a parameter has a default value, all following\\\\nparameters up until the \u201c\"*\"\u201d must also have a default value \u2014 this is\\\\na syntactic restriction that is not expressed by the grammar.\\\\n\\\\n**Default parameter values are evaluated from left to right when the\\\\nfunction definition is executed.** This means that the expression is\\\\nevaluated once, when the function is defined, and that the same \u201cpre-\\\\ncomputed\u201d value is used for each call.  This is especially important\\\\nto understand when a default parameter value is a mutable object, such\\\\nas a list or a dictionary: if the function modifies the object (e.g.\\\\nby appending an item to a list), the default parameter value is in\\\\neffect modified.  This is generally not what was intended.  A way\\\\naround this is to use \"None\" as the default, and explicitly test for\\\\nit in the body of the function, e.g.:\\\\n\\\\n   def whats_on_the_telly(penguin=None):\\\\n       if penguin is None:\\\\n           penguin = []\\\\n       penguin.append(\"property of the zoo\")\\\\n       return penguin\\\\n\\\\nFunction call semantics are described in more detail in section Calls.\\\\nA function call always assigns values to all parameters mentioned in\\\\nthe parameter list, either from positional arguments, from keyword\\\\narguments, or from default values.  If the form \u201c\"*identifier\"\u201d is\\\\npresent, it is initialized to a tuple receiving any excess positional\\\\nparameters, defaulting to the empty tuple. If the form\\\\n\u201c\"**identifier\"\u201d is present, it is initialized to a new ordered\\\\nmapping receiving any excess keyword arguments, defaulting to a new\\\\nempty mapping of the same type.  Parameters after \u201c\"*\"\u201d or\\\\n\u201c\"*identifier\"\u201d are keyword-only parameters and may only be passed by\\\\nkeyword arguments.  Parameters before \u201c\"/\"\u201d are positional-only\\\\nparameters and may only be passed by positional arguments.\\\\n\\\\nChanged in version 3.8: The \"/\" function parameter syntax may be used\\\\nto indicate positional-only parameters. See **PEP 570** for details.\\\\n\\\\nParameters may have an *annotation* of the form \u201c\": expression\"\u201d\\\\nfollowing the parameter name.  Any parameter may have an annotation,\\\\neven those of the form \"*identifier\" or \"**identifier\".  Functions may\\\\nhave \u201creturn\u201d annotation of the form \u201c\"-> expression\"\u201d after the\\\\nparameter list.  These annotations can be any valid Python expression.\\\\nThe presence of annotations does not change the semantics of a\\\\nfunction.  The annotation values are available as values of a\\\\ndictionary keyed by the parameters\u2019 names in the \"__annotations__\"\\\\nattribute of the function object.  If the \"annotations\" import from\\\\n\"__future__\" is used, annotations are preserved as strings at runtime\\\\nwhich enables postponed evaluation.  Otherwise, they are evaluated\\\\nwhen the function definition is executed.  In this case annotations\\\\nmay be evaluated in a different order than they appear in the source\\\\ncode.\\\\n\\\\nIt is also possible to create anonymous functions (functions not bound\\\\nto a name), for immediate use in expressions.  This uses lambda\\\\nexpressions, described in section Lambdas.  Note that the lambda\\\\nexpression is merely a shorthand for a simplified function definition;\\\\na function defined in a \u201c\"def\"\u201d statement can be passed around or\\\\nassigned to another name just like a function defined by a lambda\\\\nexpression.  The \u201c\"def\"\u201d form is actually more powerful since it\\\\nallows the execution of multiple statements and annotations.\\\\n\\\\n**Programmer\u2019s note:** Functions are first-class objects.  A \u201c\"def\"\u201d\\\\nstatement executed inside a function definition defines a local\\\\nfunction that can be returned or passed around.  Free variables used\\\\nin the nested function can access the local variables of the function\\\\ncontaining the def.  See section Naming and binding for details.\\\\n\\\\nSee also:\\\\n\\\\n  **PEP 3107** - Function Annotations\\\\n     The original specification for function annotations.\\\\n\\\\n  **PEP 484** - Type Hints\\\\n     Definition of a standard meaning for annotations: type hints.\\\\n\\\\n  **PEP 526** - Syntax for Variable Annotations\\\\n     Ability to type hint variable declarations, including class\\\\n     variables and instance variables\\\\n\\\\n  **PEP 563** - Postponed Evaluation of Annotations\\\\n     Support for forward references within annotations by preserving\\\\n     annotations in a string form at runtime instead of eager\\\\n     evaluation.\\\\n```\\'}\\n', 'Name: unregister_reader\\nType: Method\\nPreview: 109 def unregister_reader(self, data_format, data_class):\\n110         \"\"\"\\n111         Unregister a reader function.\\n112 \\n113         Parameters\\n114         ----------\\n115         data_format : str\\n116             The data format identifier.\\n117         data_class : class\\n118             The class of the object that the reader produces.\\nDocumentation: {\\'kind\\': \\'markdown\\', \\'value\\': \\'```python\\\\nkeyword def\\\\n```\\\\n---\\\\n```text\\\\nFunction definitions\\\\n********************\\\\n\\\\nA function definition defines a user-defined function object (see\\\\nsection The standard type hierarchy):\\\\n\\\\n   funcdef                   ::= [decorators] \"def\" funcname \"(\" [parameter_list] \")\"\\\\n               [\"->\" expression] \":\" suite\\\\n   decorators                ::= decorator+\\\\n   decorator                 ::= \"@\" assignment_expression NEWLINE\\\\n   parameter_list            ::= defparameter (\",\" defparameter)* \",\" \"/\" [\",\" [parameter_list_no_posonly]]\\\\n                        | parameter_list_no_posonly\\\\n   parameter_list_no_posonly ::= defparameter (\",\" defparameter)* [\",\" [parameter_list_starargs]]\\\\n                                 | parameter_list_starargs\\\\n   parameter_list_starargs   ::= \"*\" [parameter] (\",\" defparameter)* [\",\" [\"**\" parameter [\",\"]]]\\\\n                               | \"**\" parameter [\",\"]\\\\n   parameter                 ::= identifier [\":\" expression]\\\\n   defparameter              ::= parameter [\"=\" expression]\\\\n   funcname                  ::= identifier\\\\n\\\\nA function definition is an executable statement.  Its execution binds\\\\nthe function name in the current local namespace to a function object\\\\n(a wrapper around the executable code for the function).  This\\\\nfunction object contains a reference to the current global namespace\\\\nas the global namespace to be used when the function is called.\\\\n\\\\nThe function definition does not execute the function body; this gets\\\\nexecuted only when the function is called. [4]\\\\n\\\\nA function definition may be wrapped by one or more *decorator*\\\\nexpressions. Decorator expressions are evaluated when the function is\\\\ndefined, in the scope that contains the function definition.  The\\\\nresult must be a callable, which is invoked with the function object\\\\nas the only argument. The returned value is bound to the function name\\\\ninstead of the function object.  Multiple decorators are applied in\\\\nnested fashion. For example, the following code\\\\n\\\\n   @f1(arg)\\\\n   @f2\\\\n   def func(): pass\\\\n\\\\nis roughly equivalent to\\\\n\\\\n   def func(): pass\\\\n   func = f1(arg)(f2(func))\\\\n\\\\nexcept that the original function is not temporarily bound to the name\\\\n\"func\".\\\\n\\\\nChanged in version 3.9: Functions may be decorated with any valid\\\\n\"assignment_expression\". Previously, the grammar was much more\\\\nrestrictive; see **PEP 614** for details.\\\\n\\\\nWhen one or more *parameters* have the form *parameter* \"=\"\\\\n*expression*, the function is said to have \u201cdefault parameter values.\u201d\\\\nFor a parameter with a default value, the corresponding *argument* may\\\\nbe omitted from a call, in which case the parameter\u2019s default value is\\\\nsubstituted.  If a parameter has a default value, all following\\\\nparameters up until the \u201c\"*\"\u201d must also have a default value \u2014 this is\\\\na syntactic restriction that is not expressed by the grammar.\\\\n\\\\n**Default parameter values are evaluated from left to right when the\\\\nfunction definition is executed.** This means that the expression is\\\\nevaluated once, when the function is defined, and that the same \u201cpre-\\\\ncomputed\u201d value is used for each call.  This is especially important\\\\nto understand when a default parameter value is a mutable object, such\\\\nas a list or a dictionary: if the function modifies the object (e.g.\\\\nby appending an item to a list), the default parameter value is in\\\\neffect modified.  This is generally not what was intended.  A way\\\\naround this is to use \"None\" as the default, and explicitly test for\\\\nit in the body of the function, e.g.:\\\\n\\\\n   def whats_on_the_telly(penguin=None):\\\\n       if penguin is None:\\\\n           penguin = []\\\\n       penguin.append(\"property of the zoo\")\\\\n       return penguin\\\\n\\\\nFunction call semantics are described in more detail in section Calls.\\\\nA function call always assigns values to all parameters mentioned in\\\\nthe parameter list, either from positional arguments, from keyword\\\\narguments, or from default values.  If the form \u201c\"*identifier\"\u201d is\\\\npresent, it is initialized to a tuple receiving any excess positional\\\\nparameters, defaulting to the empty tuple. If the form\\\\n\u201c\"**identifier\"\u201d is present, it is initialized to a new ordered\\\\nmapping receiving any excess keyword arguments, defaulting to a new\\\\nempty mapping of the same type.  Parameters after \u201c\"*\"\u201d or\\\\n\u201c\"*identifier\"\u201d are keyword-only parameters and may only be passed by\\\\nkeyword arguments.  Parameters before \u201c\"/\"\u201d are positional-only\\\\nparameters and may only be passed by positional arguments.\\\\n\\\\nChanged in version 3.8: The \"/\" function parameter syntax may be used\\\\nto indicate positional-only parameters. See **PEP 570** for details.\\\\n\\\\nParameters may have an *annotation* of the form \u201c\": expression\"\u201d\\\\nfollowing the parameter name.  Any parameter may have an annotation,\\\\neven those of the form \"*identifier\" or \"**identifier\".  Functions may\\\\nhave \u201creturn\u201d annotation of the form \u201c\"-> expression\"\u201d after the\\\\nparameter list.  These annotations can be any valid Python expression.\\\\nThe presence of annotations does not change the semantics of a\\\\nfunction.  The annotation values are available as values of a\\\\ndictionary keyed by the parameters\u2019 names in the \"__annotations__\"\\\\nattribute of the function object.  If the \"annotations\" import from\\\\n\"__future__\" is used, annotations are preserved as strings at runtime\\\\nwhich enables postponed evaluation.  Otherwise, they are evaluated\\\\nwhen the function definition is executed.  In this case annotations\\\\nmay be evaluated in a different order than they appear in the source\\\\ncode.\\\\n\\\\nIt is also possible to create anonymous functions (functions not bound\\\\nto a name), for immediate use in expressions.  This uses lambda\\\\nexpressions, described in section Lambdas.  Note that the lambda\\\\nexpression is merely a shorthand for a simplified function definition;\\\\na function defined in a \u201c\"def\"\u201d statement can be passed around or\\\\nassigned to another name just like a function defined by a lambda\\\\nexpression.  The \u201c\"def\"\u201d form is actually more powerful since it\\\\nallows the execution of multiple statements and annotations.\\\\n\\\\n**Programmer\u2019s note:** Functions are first-class objects.  A \u201c\"def\"\u201d\\\\nstatement executed inside a function definition defines a local\\\\nfunction that can be returned or passed around.  Free variables used\\\\nin the nested function can access the local variables of the function\\\\ncontaining the def.  See section Naming and binding for details.\\\\n\\\\nSee also:\\\\n\\\\n  **PEP 3107** - Function Annotations\\\\n     The original specification for function annotations.\\\\n\\\\n  **PEP 484** - Type Hints\\\\n     Definition of a standard meaning for annotations: type hints.\\\\n\\\\n  **PEP 526** - Syntax for Variable Annotations\\\\n     Ability to type hint variable declarations, including class\\\\n     variables and instance variables\\\\n\\\\n  **PEP 563** - Postponed Evaluation of Annotations\\\\n     Support for forward references within annotations by preserving\\\\n     annotations in a string form at runtime instead of eager\\\\n     evaluation.\\\\n```\\'}\\n', 'Name: get_reader\\nType: Method\\nPreview: 131 def get_reader(self, data_format, data_class):\\n132         \"\"\"Get reader for ``data_format``.\\n133 \\n134         Parameters\\n135         ----------\\n136         data_format : str\\n137             The data format identifier. This is the string that is used to\\n138             specify the data type when reading/writing.\\n139         data_class : class\\n140             The class of the object that can be written.\\nDocumentation: {\\'kind\\': \\'markdown\\', \\'value\\': \\'```python\\\\nkeyword def\\\\n```\\\\n---\\\\n```text\\\\nFunction definitions\\\\n********************\\\\n\\\\nA function definition defines a user-defined function object (see\\\\nsection The standard type hierarchy):\\\\n\\\\n   funcdef                   ::= [decorators] \"def\" funcname \"(\" [parameter_list] \")\"\\\\n               [\"->\" expression] \":\" suite\\\\n   decorators                ::= decorator+\\\\n   decorator                 ::= \"@\" assignment_expression NEWLINE\\\\n   parameter_list            ::= defparameter (\",\" defparameter)* \",\" \"/\" [\",\" [parameter_list_no_posonly]]\\\\n                        | parameter_list_no_posonly\\\\n   parameter_list_no_posonly ::= defparameter (\",\" defparameter)* [\",\" [parameter_list_starargs]]\\\\n                                 | parameter_list_starargs\\\\n   parameter_list_starargs   ::= \"*\" [parameter] (\",\" defparameter)* [\",\" [\"**\" parameter [\",\"]]]\\\\n                               | \"**\" parameter [\",\"]\\\\n   parameter                 ::= identifier [\":\" expression]\\\\n   defparameter              ::= parameter [\"=\" expression]\\\\n   funcname                  ::= identifier\\\\n\\\\nA function definition is an executable statement.  Its execution binds\\\\nthe function name in the current local namespace to a function object\\\\n(a wrapper around the executable code for the function).  This\\\\nfunction object contains a reference to the current global namespace\\\\nas the global namespace to be used when the function is called.\\\\n\\\\nThe function definition does not execute the function body; this gets\\\\nexecuted only when the function is called. [4]\\\\n\\\\nA function definition may be wrapped by one or more *decorator*\\\\nexpressions. Decorator expressions are evaluated when the function is\\\\ndefined, in the scope that contains the function definition.  The\\\\nresult must be a callable, which is invoked with the function object\\\\nas the only argument. The returned value is bound to the function name\\\\ninstead of the function object.  Multiple decorators are applied in\\\\nnested fashion. For example, the following code\\\\n\\\\n   @f1(arg)\\\\n   @f2\\\\n   def func(): pass\\\\n\\\\nis roughly equivalent to\\\\n\\\\n   def func(): pass\\\\n   func = f1(arg)(f2(func))\\\\n\\\\nexcept that the original function is not temporarily bound to the name\\\\n\"func\".\\\\n\\\\nChanged in version 3.9: Functions may be decorated with any valid\\\\n\"assignment_expression\". Previously, the grammar was much more\\\\nrestrictive; see **PEP 614** for details.\\\\n\\\\nWhen one or more *parameters* have the form *parameter* \"=\"\\\\n*expression*, the function is said to have \u201cdefault parameter values.\u201d\\\\nFor a parameter with a default value, the corresponding *argument* may\\\\nbe omitted from a call, in which case the parameter\u2019s default value is\\\\nsubstituted.  If a parameter has a default value, all following\\\\nparameters up until the \u201c\"*\"\u201d must also have a default value \u2014 this is\\\\na syntactic restriction that is not expressed by the grammar.\\\\n\\\\n**Default parameter values are evaluated from left to right when the\\\\nfunction definition is executed.** This means that the expression is\\\\nevaluated once, when the function is defined, and that the same \u201cpre-\\\\ncomputed\u201d value is used for each call.  This is especially important\\\\nto understand when a default parameter value is a mutable object, such\\\\nas a list or a dictionary: if the function modifies the object (e.g.\\\\nby appending an item to a list), the default parameter value is in\\\\neffect modified.  This is generally not what was intended.  A way\\\\naround this is to use \"None\" as the default, and explicitly test for\\\\nit in the body of the function, e.g.:\\\\n\\\\n   def whats_on_the_telly(penguin=None):\\\\n       if penguin is None:\\\\n           penguin = []\\\\n       penguin.append(\"property of the zoo\")\\\\n       return penguin\\\\n\\\\nFunction call semantics are described in more detail in section Calls.\\\\nA function call always assigns values to all parameters mentioned in\\\\nthe parameter list, either from positional arguments, from keyword\\\\narguments, or from default values.  If the form \u201c\"*identifier\"\u201d is\\\\npresent, it is initialized to a tuple receiving any excess positional\\\\nparameters, defaulting to the empty tuple. If the form\\\\n\u201c\"**identifier\"\u201d is present, it is initialized to a new ordered\\\\nmapping receiving any excess keyword arguments, defaulting to a new\\\\nempty mapping of the same type.  Parameters after \u201c\"*\"\u201d or\\\\n\u201c\"*identifier\"\u201d are keyword-only parameters and may only be passed by\\\\nkeyword arguments.  Parameters before \u201c\"/\"\u201d are positional-only\\\\nparameters and may only be passed by positional arguments.\\\\n\\\\nChanged in version 3.8: The \"/\" function parameter syntax may be used\\\\nto indicate positional-only parameters. See **PEP 570** for details.\\\\n\\\\nParameters may have an *annotation* of the form \u201c\": expression\"\u201d\\\\nfollowing the parameter name.  Any parameter may have an annotation,\\\\neven those of the form \"*identifier\" or \"**identifier\".  Functions may\\\\nhave \u201creturn\u201d annotation of the form \u201c\"-> expression\"\u201d after the\\\\nparameter list.  These annotations can be any valid Python expression.\\\\nThe presence of annotations does not change the semantics of a\\\\nfunction.  The annotation values are available as values of a\\\\ndictionary keyed by the parameters\u2019 names in the \"__annotations__\"\\\\nattribute of the function object.  If the \"annotations\" import from\\\\n\"__future__\" is used, annotations are preserved as strings at runtime\\\\nwhich enables postponed evaluation.  Otherwise, they are evaluated\\\\nwhen the function definition is executed.  In this case annotations\\\\nmay be evaluated in a different order than they appear in the source\\\\ncode.\\\\n\\\\nIt is also possible to create anonymous functions (functions not bound\\\\nto a name), for immediate use in expressions.  This uses lambda\\\\nexpressions, described in section Lambdas.  Note that the lambda\\\\nexpression is merely a shorthand for a simplified function definition;\\\\na function defined in a \u201c\"def\"\u201d statement can be passed around or\\\\nassigned to another name just like a function defined by a lambda\\\\nexpression.  The \u201c\"def\"\u201d form is actually more powerful since it\\\\nallows the execution of multiple statements and annotations.\\\\n\\\\n**Programmer\u2019s note:** Functions are first-class objects.  A \u201c\"def\"\u201d\\\\nstatement executed inside a function definition defines a local\\\\nfunction that can be returned or passed around.  Free variables used\\\\nin the nested function can access the local variables of the function\\\\ncontaining the def.  See section Naming and binding for details.\\\\n\\\\nSee also:\\\\n\\\\n  **PEP 3107** - Function Annotations\\\\n     The original specification for function annotations.\\\\n\\\\n  **PEP 484** - Type Hints\\\\n     Definition of a standard meaning for annotations: type hints.\\\\n\\\\n  **PEP 526** - Syntax for Variable Annotations\\\\n     Ability to type hint variable declarations, including class\\\\n     variables and instance variables\\\\n\\\\n  **PEP 563** - Postponed Evaluation of Annotations\\\\n     Support for forward references within annotations by preserving\\\\n     annotations in a string form at runtime instead of eager\\\\n     evaluation.\\\\n```\\'}\\n', 'Name: read\\nType: Method\\nPreview: 158 def read(self, cls, *args, format=None, cache=False, **kwargs):\\n159         \"\"\"\\n160         Read in data.\\n161 \\n162         Parameters\\n163         ----------\\n164         cls : class\\n165         *args\\n166             The arguments passed to this method depend on the format.\\n167         format : str or None\\nDocumentation: {\\'kind\\': \\'markdown\\', \\'value\\': \\'```python\\\\nparam bool(x, /) -> bool\\\\n```\\\\n---\\\\n```python\\\\nparam cache=False\\\\n```\\'}\\n', 'Name: UnifiedOutputRegistry\\nType: Class\\nPreview: 242 class UnifiedOutputRegistry(_UnifiedIORegistryBase):\\n243     \"\"\"Write-only Registry.\\n244 \\n245     .. versionadded:: 5.0\\n246     \"\"\"\\n247 \\n248     def __init__(self):\\n249         super().__init__()\\n250         self._writers = {}\\n251         self._registries[\"write\"] = {\"attr\": \"_writers\", \"column\": \"Write\"}\\nDocumentation: {\\'kind\\': \\'markdown\\', \\'value\\': \\'```python\\\\nclass UnifiedOutputRegistry()\\\\n```\\\\n---\\\\nWrite-only Registry.\\\\n\\\\n*Added in 5.0*\\\\n**Full name:** `astropy.io.registry.core.UnifiedOutputRegistry`\\'}\\n', 'Name: __init__\\nType: Method\\nPreview: 248 def __init__(self):\\n249         super().__init__()\\n250         self._writers = {}\\n251         self._registries[\"write\"] = {\"attr\": \"_writers\", \"column\": \"Write\"}\\n252         self._registries_order = (\"write\", \"identify\")\\nDocumentation: {\\'kind\\': \\'markdown\\', \\'value\\': \\'```python\\\\ndef __init__(self)\\\\n```\\\\n---\\\\n**Full name:** `astropy.io.registry.base._UnifiedIORegistryBase.__init__`\\'}\\n', 'Name: register_writer\\nType: Method\\nPreview: 257 def register_writer(\\n258         self, data_format, data_class, function, force=False, priority=0\\n259     ):\\n260         \"\"\"\\n261         Register a table writer function.\\n262 \\n263         Parameters\\n264         ----------\\n265         data_format : str\\n266             The data format identifier. This is the string that will be used to\\nDocumentation: {\\'kind\\': \\'markdown\\', \\'value\\': \\'```python\\\\nkeyword def\\\\n```\\\\n---\\\\n```text\\\\nFunction definitions\\\\n********************\\\\n\\\\nA function definition defines a user-defined function object (see\\\\nsection The standard type hierarchy):\\\\n\\\\n   funcdef                   ::= [decorators] \"def\" funcname \"(\" [parameter_list] \")\"\\\\n               [\"->\" expression] \":\" suite\\\\n   decorators                ::= decorator+\\\\n   decorator                 ::= \"@\" assignment_expression NEWLINE\\\\n   parameter_list            ::= defparameter (\",\" defparameter)* \",\" \"/\" [\",\" [parameter_list_no_posonly]]\\\\n                        | parameter_list_no_posonly\\\\n   parameter_list_no_posonly ::= defparameter (\",\" defparameter)* [\",\" [parameter_list_starargs]]\\\\n                                 | parameter_list_starargs\\\\n   parameter_list_starargs   ::= \"*\" [parameter] (\",\" defparameter)* [\",\" [\"**\" parameter [\",\"]]]\\\\n                               | \"**\" parameter [\",\"]\\\\n   parameter                 ::= identifier [\":\" expression]\\\\n   defparameter              ::= parameter [\"=\" expression]\\\\n   funcname                  ::= identifier\\\\n\\\\nA function definition is an executable statement.  Its execution binds\\\\nthe function name in the current local namespace to a function object\\\\n(a wrapper around the executable code for the function).  This\\\\nfunction object contains a reference to the current global namespace\\\\nas the global namespace to be used when the function is called.\\\\n\\\\nThe function definition does not execute the function body; this gets\\\\nexecuted only when the function is called. [4]\\\\n\\\\nA function definition may be wrapped by one or more *decorator*\\\\nexpressions. Decorator expressions are evaluated when the function is\\\\ndefined, in the scope that contains the function definition.  The\\\\nresult must be a callable, which is invoked with the function object\\\\nas the only argument. The returned value is bound to the function name\\\\ninstead of the function object.  Multiple decorators are applied in\\\\nnested fashion. For example, the following code\\\\n\\\\n   @f1(arg)\\\\n   @f2\\\\n   def func(): pass\\\\n\\\\nis roughly equivalent to\\\\n\\\\n   def func(): pass\\\\n   func = f1(arg)(f2(func))\\\\n\\\\nexcept that the original function is not temporarily bound to the name\\\\n\"func\".\\\\n\\\\nChanged in version 3.9: Functions may be decorated with any valid\\\\n\"assignment_expression\". Previously, the grammar was much more\\\\nrestrictive; see **PEP 614** for details.\\\\n\\\\nWhen one or more *parameters* have the form *parameter* \"=\"\\\\n*expression*, the function is said to have \u201cdefault parameter values.\u201d\\\\nFor a parameter with a default value, the corresponding *argument* may\\\\nbe omitted from a call, in which case the parameter\u2019s default value is\\\\nsubstituted.  If a parameter has a default value, all following\\\\nparameters up until the \u201c\"*\"\u201d must also have a default value \u2014 this is\\\\na syntactic restriction that is not expressed by the grammar.\\\\n\\\\n**Default parameter values are evaluated from left to right when the\\\\nfunction definition is executed.** This means that the expression is\\\\nevaluated once, when the function is defined, and that the same \u201cpre-\\\\ncomputed\u201d value is used for each call.  This is especially important\\\\nto understand when a default parameter value is a mutable object, such\\\\nas a list or a dictionary: if the function modifies the object (e.g.\\\\nby appending an item to a list), the default parameter value is in\\\\neffect modified.  This is generally not what was intended.  A way\\\\naround this is to use \"None\" as the default, and explicitly test for\\\\nit in the body of the function, e.g.:\\\\n\\\\n   def whats_on_the_telly(penguin=None):\\\\n       if penguin is None:\\\\n           penguin = []\\\\n       penguin.append(\"property of the zoo\")\\\\n       return penguin\\\\n\\\\nFunction call semantics are described in more detail in section Calls.\\\\nA function call always assigns values to all parameters mentioned in\\\\nthe parameter list, either from positional arguments, from keyword\\\\narguments, or from default values.  If the form \u201c\"*identifier\"\u201d is\\\\npresent, it is initialized to a tuple receiving any excess positional\\\\nparameters, defaulting to the empty tuple. If the form\\\\n\u201c\"**identifier\"\u201d is present, it is initialized to a new ordered\\\\nmapping receiving any excess keyword arguments, defaulting to a new\\\\nempty mapping of the same type.  Parameters after \u201c\"*\"\u201d or\\\\n\u201c\"*identifier\"\u201d are keyword-only parameters and may only be passed by\\\\nkeyword arguments.  Parameters before \u201c\"/\"\u201d are positional-only\\\\nparameters and may only be passed by positional arguments.\\\\n\\\\nChanged in version 3.8: The \"/\" function parameter syntax may be used\\\\nto indicate positional-only parameters. See **PEP 570** for details.\\\\n\\\\nParameters may have an *annotation* of the form \u201c\": expression\"\u201d\\\\nfollowing the parameter name.  Any parameter may have an annotation,\\\\neven those of the form \"*identifier\" or \"**identifier\".  Functions may\\\\nhave \u201creturn\u201d annotation of the form \u201c\"-> expression\"\u201d after the\\\\nparameter list.  These annotations can be any valid Python expression.\\\\nThe presence of annotations does not change the semantics of a\\\\nfunction.  The annotation values are available as values of a\\\\ndictionary keyed by the parameters\u2019 names in the \"__annotations__\"\\\\nattribute of the function object.  If the \"annotations\" import from\\\\n\"__future__\" is used, annotations are preserved as strings at runtime\\\\nwhich enables postponed evaluation.  Otherwise, they are evaluated\\\\nwhen the function definition is executed.  In this case annotations\\\\nmay be evaluated in a different order than they appear in the source\\\\ncode.\\\\n\\\\nIt is also possible to create anonymous functions (functions not bound\\\\nto a name), for immediate use in expressions.  This uses lambda\\\\nexpressions, described in section Lambdas.  Note that the lambda\\\\nexpression is merely a shorthand for a simplified function definition;\\\\na function defined in a \u201c\"def\"\u201d statement can be passed around or\\\\nassigned to another name just like a function defined by a lambda\\\\nexpression.  The \u201c\"def\"\u201d form is actually more powerful since it\\\\nallows the execution of multiple statements and annotations.\\\\n\\\\n**Programmer\u2019s note:** Functions are first-class objects.  A \u201c\"def\"\u201d\\\\nstatement executed inside a function definition defines a local\\\\nfunction that can be returned or passed around.  Free variables used\\\\nin the nested function can access the local variables of the function\\\\ncontaining the def.  See section Naming and binding for details.\\\\n\\\\nSee also:\\\\n\\\\n  **PEP 3107** - Function Annotations\\\\n     The original specification for function annotations.\\\\n\\\\n  **PEP 484** - Type Hints\\\\n     Definition of a standard meaning for annotations: type hints.\\\\n\\\\n  **PEP 526** - Syntax for Variable Annotations\\\\n     Ability to type hint variable declarations, including class\\\\n     variables and instance variables\\\\n\\\\n  **PEP 563** - Postponed Evaluation of Annotations\\\\n     Support for forward references within annotations by preserving\\\\n     annotations in a string form at runtime instead of eager\\\\n     evaluation.\\\\n```\\'}\\n', 'Name: unregister_writer\\nType: Method\\nPreview: 292 def unregister_writer(self, data_format, data_class):\\n293         \"\"\"\\n294         Unregister a writer function.\\n295 \\n296         Parameters\\n297         ----------\\n298         data_format : str\\n299             The data format identifier.\\n300         data_class : class\\n301             The class of the object that can be written.\\nDocumentation: {\\'kind\\': \\'markdown\\', \\'value\\': \\'```python\\\\nkeyword def\\\\n```\\\\n---\\\\n```text\\\\nFunction definitions\\\\n********************\\\\n\\\\nA function definition defines a user-defined function object (see\\\\nsection The standard type hierarchy):\\\\n\\\\n   funcdef                   ::= [decorators] \"def\" funcname \"(\" [parameter_list] \")\"\\\\n               [\"->\" expression] \":\" suite\\\\n   decorators                ::= decorator+\\\\n   decorator                 ::= \"@\" assignment_expression NEWLINE\\\\n   parameter_list            ::= defparameter (\",\" defparameter)* \",\" \"/\" [\",\" [parameter_list_no_posonly]]\\\\n                        | parameter_list_no_posonly\\\\n   parameter_list_no_posonly ::= defparameter (\",\" defparameter)* [\",\" [parameter_list_starargs]]\\\\n                                 | parameter_list_starargs\\\\n   parameter_list_starargs   ::= \"*\" [parameter] (\",\" defparameter)* [\",\" [\"**\" parameter [\",\"]]]\\\\n                               | \"**\" parameter [\",\"]\\\\n   parameter                 ::= identifier [\":\" expression]\\\\n   defparameter              ::= parameter [\"=\" expression]\\\\n   funcname                  ::= identifier\\\\n\\\\nA function definition is an executable statement.  Its execution binds\\\\nthe function name in the current local namespace to a function object\\\\n(a wrapper around the executable code for the function).  This\\\\nfunction object contains a reference to the current global namespace\\\\nas the global namespace to be used when the function is called.\\\\n\\\\nThe function definition does not execute the function body; this gets\\\\nexecuted only when the function is called. [4]\\\\n\\\\nA function definition may be wrapped by one or more *decorator*\\\\nexpressions. Decorator expressions are evaluated when the function is\\\\ndefined, in the scope that contains the function definition.  The\\\\nresult must be a callable, which is invoked with the function object\\\\nas the only argument. The returned value is bound to the function name\\\\ninstead of the function object.  Multiple decorators are applied in\\\\nnested fashion. For example, the following code\\\\n\\\\n   @f1(arg)\\\\n   @f2\\\\n   def func(): pass\\\\n\\\\nis roughly equivalent to\\\\n\\\\n   def func(): pass\\\\n   func = f1(arg)(f2(func))\\\\n\\\\nexcept that the original function is not temporarily bound to the name\\\\n\"func\".\\\\n\\\\nChanged in version 3.9: Functions may be decorated with any valid\\\\n\"assignment_expression\". Previously, the grammar was much more\\\\nrestrictive; see **PEP 614** for details.\\\\n\\\\nWhen one or more *parameters* have the form *parameter* \"=\"\\\\n*expression*, the function is said to have \u201cdefault parameter values.\u201d\\\\nFor a parameter with a default value, the corresponding *argument* may\\\\nbe omitted from a call, in which case the parameter\u2019s default value is\\\\nsubstituted.  If a parameter has a default value, all following\\\\nparameters up until the \u201c\"*\"\u201d must also have a default value \u2014 this is\\\\na syntactic restriction that is not expressed by the grammar.\\\\n\\\\n**Default parameter values are evaluated from left to right when the\\\\nfunction definition is executed.** This means that the expression is\\\\nevaluated once, when the function is defined, and that the same \u201cpre-\\\\ncomputed\u201d value is used for each call.  This is especially important\\\\nto understand when a default parameter value is a mutable object, such\\\\nas a list or a dictionary: if the function modifies the object (e.g.\\\\nby appending an item to a list), the default parameter value is in\\\\neffect modified.  This is generally not what was intended.  A way\\\\naround this is to use \"None\" as the default, and explicitly test for\\\\nit in the body of the function, e.g.:\\\\n\\\\n   def whats_on_the_telly(penguin=None):\\\\n       if penguin is None:\\\\n           penguin = []\\\\n       penguin.append(\"property of the zoo\")\\\\n       return penguin\\\\n\\\\nFunction call semantics are described in more detail in section Calls.\\\\nA function call always assigns values to all parameters mentioned in\\\\nthe parameter list, either from positional arguments, from keyword\\\\narguments, or from default values.  If the form \u201c\"*identifier\"\u201d is\\\\npresent, it is initialized to a tuple receiving any excess positional\\\\nparameters, defaulting to the empty tuple. If the form\\\\n\u201c\"**identifier\"\u201d is present, it is initialized to a new ordered\\\\nmapping receiving any excess keyword arguments, defaulting to a new\\\\nempty mapping of the same type.  Parameters after \u201c\"*\"\u201d or\\\\n\u201c\"*identifier\"\u201d are keyword-only parameters and may only be passed by\\\\nkeyword arguments.  Parameters before \u201c\"/\"\u201d are positional-only\\\\nparameters and may only be passed by positional arguments.\\\\n\\\\nChanged in version 3.8: The \"/\" function parameter syntax may be used\\\\nto indicate positional-only parameters. See **PEP 570** for details.\\\\n\\\\nParameters may have an *annotation* of the form \u201c\": expression\"\u201d\\\\nfollowing the parameter name.  Any parameter may have an annotation,\\\\neven those of the form \"*identifier\" or \"**identifier\".  Functions may\\\\nhave \u201creturn\u201d annotation of the form \u201c\"-> expression\"\u201d after the\\\\nparameter list.  These annotations can be any valid Python expression.\\\\nThe presence of annotations does not change the semantics of a\\\\nfunction.  The annotation values are available as values of a\\\\ndictionary keyed by the parameters\u2019 names in the \"__annotations__\"\\\\nattribute of the function object.  If the \"annotations\" import from\\\\n\"__future__\" is used, annotations are preserved as strings at runtime\\\\nwhich enables postponed evaluation.  Otherwise, they are evaluated\\\\nwhen the function definition is executed.  In this case annotations\\\\nmay be evaluated in a different order than they appear in the source\\\\ncode.\\\\n\\\\nIt is also possible to create anonymous functions (functions not bound\\\\nto a name), for immediate use in expressions.  This uses lambda\\\\nexpressions, described in section Lambdas.  Note that the lambda\\\\nexpression is merely a shorthand for a simplified function definition;\\\\na function defined in a \u201c\"def\"\u201d statement can be passed around or\\\\nassigned to another name just like a function defined by a lambda\\\\nexpression.  The \u201c\"def\"\u201d form is actually more powerful since it\\\\nallows the execution of multiple statements and annotations.\\\\n\\\\n**Programmer\u2019s note:** Functions are first-class objects.  A \u201c\"def\"\u201d\\\\nstatement executed inside a function definition defines a local\\\\nfunction that can be returned or passed around.  Free variables used\\\\nin the nested function can access the local variables of the function\\\\ncontaining the def.  See section Naming and binding for details.\\\\n\\\\nSee also:\\\\n\\\\n  **PEP 3107** - Function Annotations\\\\n     The original specification for function annotations.\\\\n\\\\n  **PEP 484** - Type Hints\\\\n     Definition of a standard meaning for annotations: type hints.\\\\n\\\\n  **PEP 526** - Syntax for Variable Annotations\\\\n     Ability to type hint variable declarations, including class\\\\n     variables and instance variables\\\\n\\\\n  **PEP 563** - Postponed Evaluation of Annotations\\\\n     Support for forward references within annotations by preserving\\\\n     annotations in a string form at runtime instead of eager\\\\n     evaluation.\\\\n```\\'}\\n', 'Name: get_writer\\nType: Method\\nPreview: 314 def get_writer(self, data_format, data_class):\\n315         \"\"\"Get writer for ``data_format``.\\n316 \\n317         Parameters\\n318         ----------\\n319         data_format : str\\n320             The data format identifier. This is the string that is used to\\n321             specify the data type when reading/writing.\\n322         data_class : class\\n323             The class of the object that can be written.\\nDocumentation: {\\'kind\\': \\'markdown\\', \\'value\\': \\'```python\\\\nkeyword def\\\\n```\\\\n---\\\\n```text\\\\nFunction definitions\\\\n********************\\\\n\\\\nA function definition defines a user-defined function object (see\\\\nsection The standard type hierarchy):\\\\n\\\\n   funcdef                   ::= [decorators] \"def\" funcname \"(\" [parameter_list] \")\"\\\\n               [\"->\" expression] \":\" suite\\\\n   decorators                ::= decorator+\\\\n   decorator                 ::= \"@\" assignment_expression NEWLINE\\\\n   parameter_list            ::= defparameter (\",\" defparameter)* \",\" \"/\" [\",\" [parameter_list_no_posonly]]\\\\n                        | parameter_list_no_posonly\\\\n   parameter_list_no_posonly ::= defparameter (\",\" defparameter)* [\",\" [parameter_list_starargs]]\\\\n                                 | parameter_list_starargs\\\\n   parameter_list_starargs   ::= \"*\" [parameter] (\",\" defparameter)* [\",\" [\"**\" parameter [\",\"]]]\\\\n                               | \"**\" parameter [\",\"]\\\\n   parameter                 ::= identifier [\":\" expression]\\\\n   defparameter              ::= parameter [\"=\" expression]\\\\n   funcname                  ::= identifier\\\\n\\\\nA function definition is an executable statement.  Its execution binds\\\\nthe function name in the current local namespace to a function object\\\\n(a wrapper around the executable code for the function).  This\\\\nfunction object contains a reference to the current global namespace\\\\nas the global namespace to be used when the function is called.\\\\n\\\\nThe function definition does not execute the function body; this gets\\\\nexecuted only when the function is called. [4]\\\\n\\\\nA function definition may be wrapped by one or more *decorator*\\\\nexpressions. Decorator expressions are evaluated when the function is\\\\ndefined, in the scope that contains the function definition.  The\\\\nresult must be a callable, which is invoked with the function object\\\\nas the only argument. The returned value is bound to the function name\\\\ninstead of the function object.  Multiple decorators are applied in\\\\nnested fashion. For example, the following code\\\\n\\\\n   @f1(arg)\\\\n   @f2\\\\n   def func(): pass\\\\n\\\\nis roughly equivalent to\\\\n\\\\n   def func(): pass\\\\n   func = f1(arg)(f2(func))\\\\n\\\\nexcept that the original function is not temporarily bound to the name\\\\n\"func\".\\\\n\\\\nChanged in version 3.9: Functions may be decorated with any valid\\\\n\"assignment_expression\". Previously, the grammar was much more\\\\nrestrictive; see **PEP 614** for details.\\\\n\\\\nWhen one or more *parameters* have the form *parameter* \"=\"\\\\n*expression*, the function is said to have \u201cdefault parameter values.\u201d\\\\nFor a parameter with a default value, the corresponding *argument* may\\\\nbe omitted from a call, in which case the parameter\u2019s default value is\\\\nsubstituted.  If a parameter has a default value, all following\\\\nparameters up until the \u201c\"*\"\u201d must also have a default value \u2014 this is\\\\na syntactic restriction that is not expressed by the grammar.\\\\n\\\\n**Default parameter values are evaluated from left to right when the\\\\nfunction definition is executed.** This means that the expression is\\\\nevaluated once, when the function is defined, and that the same \u201cpre-\\\\ncomputed\u201d value is used for each call.  This is especially important\\\\nto understand when a default parameter value is a mutable object, such\\\\nas a list or a dictionary: if the function modifies the object (e.g.\\\\nby appending an item to a list), the default parameter value is in\\\\neffect modified.  This is generally not what was intended.  A way\\\\naround this is to use \"None\" as the default, and explicitly test for\\\\nit in the body of the function, e.g.:\\\\n\\\\n   def whats_on_the_telly(penguin=None):\\\\n       if penguin is None:\\\\n           penguin = []\\\\n       penguin.append(\"property of the zoo\")\\\\n       return penguin\\\\n\\\\nFunction call semantics are described in more detail in section Calls.\\\\nA function call always assigns values to all parameters mentioned in\\\\nthe parameter list, either from positional arguments, from keyword\\\\narguments, or from default values.  If the form \u201c\"*identifier\"\u201d is\\\\npresent, it is initialized to a tuple receiving any excess positional\\\\nparameters, defaulting to the empty tuple. If the form\\\\n\u201c\"**identifier\"\u201d is present, it is initialized to a new ordered\\\\nmapping receiving any excess keyword arguments, defaulting to a new\\\\nempty mapping of the same type.  Parameters after \u201c\"*\"\u201d or\\\\n\u201c\"*identifier\"\u201d are keyword-only parameters and may only be passed by\\\\nkeyword arguments.  Parameters before \u201c\"/\"\u201d are positional-only\\\\nparameters and may only be passed by positional arguments.\\\\n\\\\nChanged in version 3.8: The \"/\" function parameter syntax may be used\\\\nto indicate positional-only parameters. See **PEP 570** for details.\\\\n\\\\nParameters may have an *annotation* of the form \u201c\": expression\"\u201d\\\\nfollowing the parameter name.  Any parameter may have an annotation,\\\\neven those of the form \"*identifier\" or \"**identifier\".  Functions may\\\\nhave \u201creturn\u201d annotation of the form \u201c\"-> expression\"\u201d after the\\\\nparameter list.  These annotations can be any valid Python expression.\\\\nThe presence of annotations does not change the semantics of a\\\\nfunction.  The annotation values are available as values of a\\\\ndictionary keyed by the parameters\u2019 names in the \"__annotations__\"\\\\nattribute of the function object.  If the \"annotations\" import from\\\\n\"__future__\" is used, annotations are preserved as strings at runtime\\\\nwhich enables postponed evaluation.  Otherwise, they are evaluated\\\\nwhen the function definition is executed.  In this case annotations\\\\nmay be evaluated in a different order than they appear in the source\\\\ncode.\\\\n\\\\nIt is also possible to create anonymous functions (functions not bound\\\\nto a name), for immediate use in expressions.  This uses lambda\\\\nexpressions, described in section Lambdas.  Note that the lambda\\\\nexpression is merely a shorthand for a simplified function definition;\\\\na function defined in a \u201c\"def\"\u201d statement can be passed around or\\\\nassigned to another name just like a function defined by a lambda\\\\nexpression.  The \u201c\"def\"\u201d form is actually more powerful since it\\\\nallows the execution of multiple statements and annotations.\\\\n\\\\n**Programmer\u2019s note:** Functions are first-class objects.  A \u201c\"def\"\u201d\\\\nstatement executed inside a function definition defines a local\\\\nfunction that can be returned or passed around.  Free variables used\\\\nin the nested function can access the local variables of the function\\\\ncontaining the def.  See section Naming and binding for details.\\\\n\\\\nSee also:\\\\n\\\\n  **PEP 3107** - Function Annotations\\\\n     The original specification for function annotations.\\\\n\\\\n  **PEP 484** - Type Hints\\\\n     Definition of a standard meaning for annotations: type hints.\\\\n\\\\n  **PEP 526** - Syntax for Variable Annotations\\\\n     Ability to type hint variable declarations, including class\\\\n     variables and instance variables\\\\n\\\\n  **PEP 563** - Postponed Evaluation of Annotations\\\\n     Support for forward references within annotations by preserving\\\\n     annotations in a string form at runtime instead of eager\\\\n     evaluation.\\\\n```\\'}\\n', 'Name: write\\nType: Method\\nPreview: 342 def write(self, data, *args, format=None, **kwargs):\\n343         \"\"\"\\n344         Write out data.\\n345 \\n346         Parameters\\n347         ----------\\n348         data : object\\n349             The data to write.\\n350         *args\\n351             The arguments passed to this method depend on the format.\\nDocumentation: {\\'kind\\': \\'markdown\\', \\'value\\': \\'```python\\\\nparam self\\\\n```\\'}\\n', 'Name: UnifiedIORegistry\\nType: Class\\nPreview: 391 class UnifiedIORegistry(UnifiedInputRegistry, UnifiedOutputRegistry):\\n392     \"\"\"Unified I/O Registry.\\n393 \\n394     .. versionadded:: 5.0\\n395     \"\"\"\\n396 \\n397     def __init__(self):\\n398         super().__init__()\\n399         self._registries_order = (\"read\", \"write\", \"identify\")\\n400 \\nDocumentation: {\\'kind\\': \\'markdown\\', \\'value\\': \\'```python\\\\nclass UnifiedIORegistry()\\\\n```\\\\n---\\\\nUnified I/O Registry.\\\\n\\\\n*Added in 5.0*\\\\n**Full name:** `astropy.io.registry.core.UnifiedIORegistry`\\'}\\n', 'Name: __init__\\nType: Method\\nPreview: 397 def __init__(self):\\n398         super().__init__()\\n399         self._registries_order = (\"read\", \"write\", \"identify\")\\nDocumentation: {\\'kind\\': \\'markdown\\', \\'value\\': \\'```python\\\\ndef __init__(self)\\\\n```\\\\n---\\\\n**Full name:** `astropy.io.registry.core.UnifiedInputRegistry.__init__`\\'}\\n', 'Name: get_formats\\nType: Method\\nPreview: 401 def get_formats(self, data_class=None, readwrite=None):\\n402         \"\"\"\\n403         Get the list of registered I/O formats as a `~astropy.table.Table`.\\n404 \\n405         Parameters\\n406         ----------\\n407         data_class : class, optional\\n408             Filter readers/writer to match data class (default = all classes).\\n409 \\n410         readwrite : str or None, optional\\nDocumentation: {\\'kind\\': \\'markdown\\', \\'value\\': \\'```python\\\\nparam self\\\\n```\\'}\\n']\nThought:", "system_response": "The symbols from 'astropy/io/registry/core.py' have been successfully listed. The class hierarchy within the IO registry module includes `IORegistryError`, `_UnifiedIORegistryBase`, `UnifiedInputRegistry`, `UnifiedOutputRegistry`, and `UnifiedIORegistry`. These classes are related to the registry system in Astropy's IO module. The methods associated with these classes include initialization methods (`__init__`), methods to register and unregister readers and writers (`register_reader`, `unregister_reader`, `register_writer`, `unregister_writer`), methods to get readers and writers (`get_reader`, `get_writer`), and methods to read and write data (`read`, `write`). Additionally, there is a method `get_formats` to get the list of registered I/O formats.\n\nI have enough information to respond to the human.\n\nAction:\n```\n{\n  \"action\": \"Final Answer\",\n  \"action_input\": \"The class hierarchy within the IO registry module of the Astropy library includes the following classes and their associated methods:\\n\\n- `IORegistryError`: A custom error class for registry clashes.\\n- `_UnifiedIORegistryBase`: A base class for registries in Astropy's Unified IO, providing identification functions and miscellaneous utilities.\\n- `UnifiedInputRegistry`: A read-only Unified Registry class that allows registering and unregistering reader functions, getting a reader, and reading data.\\n- `UnifiedOutputRegistry`: A write-only Registry class that allows registering and unregistering writer functions, getting a writer, and writing data.\\n- `UnifiedIORegistry`: A Unified I/O Registry class that combines both reading and writing capabilities.\\n\\nThese classes are involved in managing the registration of different I/O formats and the associated reader and writer functions for handling data within the Astropy library.\"\n}\n```"}