{"system_prompt": "You are an expert in programming, you're so good at code navigation inside large repository. Try to combine different tools to seek related information to the query inside the project. Some good combinations of tools could be get_folder_structure -> find symbols of each file inside the directory. Semantic search -> exact code search -> go to definition and etc. If you know exactly the name of the symbol, you can use code_search tool or if you know the line and the name of the symbol, you can use go_to_definition tool. Try to avoid using open_file tool frequently (use the get all symbols instead). Respond to the human as helpfully and accurately as possible. Consider use other tools if the results returned is not cleared enough or failed for the query. You have access to the following tools:\n\ncode_search: Useful when you want to find all matched identifiers (variable, function, class name) from a python repository, primarily used for class, function search. The results\n    are mixed and not sorted by any criteria. So considered using this when you want to find all possible candidates for a given name. Otherwise, consider using other tools for more precise results, args: {'names': {'title': 'Names', 'description': 'The names of the identifiers to search', 'type': 'array', 'items': {'type': 'string'}}}\nSemantic Code Search: useful for when the query is a sentance, semantic and vague. If exact search such as code search failed after multiple tries, try this, args: {'tool_input': {'type': 'string'}}\ngo_to_definition: Useful when you want to find the definition of a symbol inside a code snippet if the current context is not cleared enough such as \n    0 import matplotlib.pyplot as plt\n    1 class Directory(object):\n    2\n    3    def add_member(self, id, name):\n    4        self.members[id] = plt.figure() we might want to find the definition of plt.figure() invoke with params (\"figure\", 4, 'test.py'), args: {'word': {'title': 'Word', 'type': 'string'}, 'line': {'title': 'Line', 'type': 'integer'}, 'relative_path': {'title': 'Relative Path', 'type': 'string'}}\nfind_all_references: Given a code snippet that contains target symbol, find all references of this symbol inside the project.\n    , args: {'word': {'title': 'Word', 'type': 'string'}, 'line': {'title': 'Line', 'type': 'integer'}, 'relative_path': {'title': 'Relative Path', 'type': 'string'}, 'reranking': {'title': 'Reranking', 'default': False, 'type': 'boolean'}, 'query': {'title': 'Query', 'default': '', 'type': 'string'}}\nget_all_symbols: Useful when you want to find all symbols (functions, classes, methods) of a python file, args: {'path_to_file': {'title': 'Path To File', 'type': 'string'}, 'verbose_level': {'title': 'Verbose Level', 'default': 1, 'type': 'integer'}}\nget_folder_structure: Useful when you want to explore the tree structure of a folder, good for initial exploration with knowing the parent folder name. Remember to provide the relative path correctly.\n    , args: {'relative_path': {'title': 'Relative Path', 'type': 'string'}, 'level': {'title': 'Level', 'default': 2, 'type': 'integer'}}\nopen_file: Useful when you want to open a file inside a repo, use this tool only when it's very necessary, usually a main or server or training script. Consider combinining other alternative tools such as GetAllSymbols and CodeSearch to save the number of tokens for other cases., args: {'relative_file_path': {'title': 'Relative File Path', 'type': 'string'}, 'max_new_line': {'title': 'Max New Line', 'default': 500, 'type': 'integer'}}\n\nUse a json blob to specify a tool by providing an action key (tool name) and an action_input key (tool input).\n\nValid \"action\" values: \"Final Answer\" or code_search, Semantic Code Search, go_to_definition, find_all_references, get_all_symbols, get_folder_structure, open_file\n\nProvide only ONE action per $JSON_BLOB, as shown:\n\n```\n{\n  \"action\": $TOOL_NAME,\n  \"action_input\": $INPUT\n}\n```\n\nFollow this format:\n\nQuestion: input question to answer\nThought: consider previous and subsequent steps, notes down some useful information (like code snippet) from observation\nAction:\n```\n$JSON_BLOB\n```\nObservation: action result\n... (repeat Thought/Action/Observation N times)\nThought: I know what to respond\nAction:\n```\n{\n  \"action\": \"Final Answer\",\n  \"action_input\": \"Final response to human\"\n}\n```\n\nBegin! Reminder to ALWAYS respond with a valid json blob of a single action. Use tools if necessary. Respond directly if you have gathered enough information from the repository. Format is Action:```$JSON_BLOB```then Observation:.", "human_message": "Human request: I'm converting some positions and velocities from ICRS to Galactocentric, and then turning that into a spherical representation. The velocities are given as angular velocities, which is a little strange since I would have expected them in km/s.\n\nc = coord.SkyCoord(\n        ra = ra * u.deg, \n        dec = dec * u.deg, \n        pm_ra_cosdec = pmracosdec * u.mas/u.yr, \n        pm_dec = pmdec * u.mas / u.yr, \n        radial_velocity = vrad * u.km / u.s, \n        distance = dist * u.kpc,\n        frame = 'icrs',\n    )\ncg = c.transform_to(coord.Galactocentric())\ncgs = cg.represent_as('spherical')\ndiffs = cgs.differentials['s']\ndiffs\n<SphericalDifferential (d_lon, d_lat, d_distance) in (mas / yr, mas / yr, kpc mas / (rad yr))\n    (-0.17801241, -0.06221044, -12.62912254)>\n\nHow can I get these in km/s? For d_distance I can do\n\ncgs.differentials['s'].d_distance.to(u.km/u.s)\n\nbut for d_lon and d_lat I can't do the conversion, even when I multiply by the distance:\n\n(cgs.differentials['s'].d_lon * dist * u.kpc).to(u.km/u.s)\n\ngives the following error:\n\nUnitConversionError: 'kpc mas / yr' and 'km / s' (speed) are not convertible\n\nPrevious steps: steps=[]\n\nCurrent objective: value=\"Find the classes and methods related to the conversion of velocities from ICRS to Galactocentric and then to a spherical representation. This could be done by using the code_search tool with the names 'ICRS', 'Galactocentric', 'SphericalDifferential', 'SkyCoord', 'transform_to', 'represent_as', 'differentials', 'd_distance', 'd_lon', 'd_lat'.\"\n\nThis was your previous work (but I haven't seen any of it! I only see what you return as final answer):\nAction:\n```\n{\n  \"action\": \"code_search\",\n  \"action_input\": {\n    \"names\": [\n      \"ICRS\",\n      \"Galactocentric\",\n      \"SphericalDifferential\",\n      \"SkyCoord\",\n      \"transform_to\",\n      \"represent_as\",\n      \"differentials\",\n      \"d_distance\",\n      \"d_lon\",\n      \"d_lat\"\n    ]\n  }\n}\n```\n\nObservation: {'ICRS': [{'name': 'ICRS', 'full_name': 'astropy.coordinates.builtin_frames.icrs.ICRS', 'documentation': 'A coordinate or frame in the ICRS system.\\n\\nIf you\\'re looking for \"J2000\" coordinates, and aren\\'t sure if you want to\\nuse this or `~astropy.coordinates.FK5`, you probably want to use ICRS. It\\'s\\nmore well-defined as a catalog coordinate and is an inertial system, and is\\nvery close (within tens of milliarcseconds) to J2000 equatorial.\\n\\nFor more background on the ICRS and related coordinate transformations, see\\nthe references provided in the  :ref:`astropy:astropy-coordinates-seealso`\\nsection of the documentation.', 'implementation': '11 class ICRS(BaseRADecFrame):\\n12     \"\"\"\\n13     A coordinate or frame in the ICRS system.\\n14 \\n15     If you\\'re looking for \"J2000\" coordinates, and aren\\'t sure if you want to\\n16     use this or `~astropy.coordinates.FK5`, you probably want to use ICRS. It\\'s\\n17     more well-defined as a catalog coordinate and is an inertial system, and is\\n18     very close (within tens of milliarcseconds) to J2000 equatorial.\\n19 \\n20     For more background on the ICRS and related coordinate transformations, see\\n21     the references provided in the  :ref:`astropy:astropy-coordinates-seealso`\\n22     section of the documentation.\\n23     \"\"\"\\n24 '}, {'name': 'icrs', 'full_name': 'astropy.coordinates.solar_system.get_body.icrs', 'documentation': None, 'implementation': 'icrs = ICRS(cartrep)'}, {'name': 'ICRS', 'full_name': 'astropy.coordinates.builtin_frames.icrs.ICRS', 'documentation': None, 'implementation': 'class ICRS'}], 'Galactocentric': [{'name': 'Galactocentric', 'full_name': 'astropy.coordinates.builtin_frames.galactocentric.Galactocentric', 'documentation': 'A coordinate or frame in the Galactocentric system.\\n\\nThis frame allows specifying the Sun-Galactic center distance, the height of\\nthe Sun above the Galactic midplane, and the solar motion relative to the\\nGalactic center. However, as there is no modern standard definition of a\\nGalactocentric reference frame, it is important to pay attention to the\\ndefault values used in this class if precision is important in your code.\\nThe default values of the parameters of this frame are taken from the\\noriginal definition of the frame in 2014. As such, the defaults are somewhat\\nout of date relative to recent measurements made possible by, e.g., Gaia.\\nThe defaults can, however, be changed at runtime by setting the parameter\\nset name in `~astropy.coordinates.galactocentric_frame_defaults`.\\n\\nThe current default parameter set is ``\"pre-v4.0\"``, indicating that the\\nparameters were adopted before ``astropy`` version 4.0. A regularly-updated\\nparameter set can instead be used by setting\\n``galactocentric_frame_defaults.set (\\'latest\\')``, and other parameter set\\nnames may be added in future versions. To find out the scientific papers\\nthat the current default parameters are derived from, use\\n``galcen.frame_attribute_references`` (where ``galcen`` is an instance of\\nthis frame), which will update even if the default parameter set is changed.\\n\\nThe position of the Sun is assumed to be on the x axis of the final,\\nright-handed system. That is, the x axis points from the position of\\nthe Sun projected to the Galactic midplane to the Galactic center --\\nroughly towards :math:`(l,b) = (0^\\\\circ,0^\\\\circ)`. For the default\\ntransformation (:math:`{\\\\rm roll}=0^\\\\circ`), the y axis points roughly\\ntowards Galactic longitude :math:`l=90^\\\\circ`, and the z axis points\\nroughly towards the North Galactic Pole (:math:`b=90^\\\\circ`).\\n\\nFor a more detailed look at the math behind this transformation, see\\nthe document :ref:`astropy:coordinates-galactocentric`.\\n\\nThe frame attributes are listed under **Other Parameters**.', 'implementation': '424 class Galactocentric(BaseCoordinateFrame):\\n425     r\"\"\"\\n426     A coordinate or frame in the Galactocentric system.\\n427 \\n428     This frame allows specifying the Sun-Galactic center distance, the height of\\n429     the Sun above the Galactic midplane, and the solar motion relative to the\\n430     Galactic center. However, as there is no modern standard definition of a\\n431     Galactocentric reference frame, it is important to pay attention to the\\n432     default values used in this class if precision is important in your code.\\n433     The default values of the parameters of this frame are taken from the\\n434     original definition of the frame in 2014. As such, the defaults are somewhat\\n435     out of date relative to recent measurements made possible by, e.g., Gaia.\\n436     The defaults can, however, be changed at runtime by setting the parameter\\n437     set name in `~astropy.coordinates.galactocentric_frame_defaults`.\\n438 \\n439     The current default parameter set is ``\"pre-v4.0\"``, indicating that the\\n440     parameters were adopted before ``astropy`` version 4.0. A regularly-updated\\n441     parameter set can instead be used by setting\\n442     ``galactocentric_frame_defaults.set (\\'latest\\')``, and other parameter set\\n443     names may be added in future versions. To find out the scientific papers\\n444     that the current default parameters are derived from, use\\n445     ``galcen.frame_attribute_references`` (where ``galcen`` is an instance of\\n446     this frame), which will update even if the default parameter set is changed.\\n447 \\n448     The position of the Sun is assumed to be on the x axis of the final,\\n449     right-handed system. That is, the x axis points from the position of\\n450     the Sun projected to the Galactic midplane to the Galactic center --\\n451     roughly towards :math:`(l,b) = (0^\\\\circ,0^\\\\circ)`. For the default\\n452     transformation (:math:`{\\\\rm roll}=0^\\\\circ`), the y axis points roughly\\n453     towards Galactic longitude :math:`l=90^\\\\circ`, and the z axis points\\n454     roughly towards the North Galactic Pole (:math:`b=90^\\\\circ`).\\n455 \\n456     For a more detailed look at the math behind this transformation, see\\n457     the document :ref:`astropy:coordinates-galactocentric`.\\n458 \\n459     The frame attributes are listed under **Other Parameters**.\\n460     \"\"\"\\n461 \\n462     default_representation = r.CartesianRepresentation\\n463     default_differential = r.CartesianDifferential\\n464 \\n465     # frame attributes\\n466     galcen_coord = CoordinateAttribute(frame=ICRS)\\n467     galcen_distance = QuantityAttribute(unit=u.kpc)\\n468 \\n469     galcen_v_sun = DifferentialAttribute(allowed_classes=[r.CartesianDifferential])\\n470 \\n471     z_sun = QuantityAttribute(unit=u.pc)\\n472     roll = QuantityAttribute(unit=u.deg)\\n473 \\n474     def __init__(self, *args, **kwargs):\\n475         # Set default frame attribute values based on the ScienceState instance\\n476         # for the solar parameters defined above\\n477         default_params = galactocentric_frame_defaults.get()\\n478         self.frame_attribute_references = (\\n479             galactocentric_frame_defaults.references.copy()\\n480         )\\n481 \\n482         for k in default_params:\\n483             if k in kwargs:\\n484                 # If a frame attribute is set by the user, remove its reference\\n485                 self.frame_attribute_references.pop(k, None)\\n486 \\n487             # Keep the frame attribute if it is set by the user, otherwise use\\n488             # the default value\\n489             kwargs[k] = kwargs.get(k, default_params[k])\\n490 \\n491         super().__init__(*args, **kwargs)\\n492 \\n493     @classmethod\\n494     def get_roll0(cls):\\n495         \"\"\"The additional roll angle (about the final x axis) necessary to align the\\n496         final z axis to match the Galactic yz-plane.  Setting the ``roll``\\n497         frame attribute to -this method\\'s return value removes this rotation,\\n498         allowing the use of the `~astropy.coordinates.Galactocentric` frame\\n499         in more general contexts.\\n500 \\n501         \"\"\"\\n502         # note that the actual value is defined at the module level.  We make at\\n503         # a property here because this module isn\\'t actually part of the public\\n504         # API, so it\\'s better for it to be accessible from Galactocentric\\n505         return _ROLL0\\n506 '}, {'name': 'Galactocentric', 'full_name': 'astropy.coordinates.builtin_frames.galactocentric.Galactocentric', 'documentation': None, 'implementation': 'class Galactocentric'}], 'SphericalDifferential': [{'name': 'SphericalDifferential', 'full_name': 'astropy.coordinates.representation.spherical.SphericalDifferential', 'documentation': 'Differential(s) of points in 3D spherical coordinates.\\n\\nParameters\\n----------\\nd_lon, d_lat : `~astropy.units.Quantity`\\n    The differential longitude and latitude.\\nd_distance : `~astropy.units.Quantity`\\n    The differential distance.\\ncopy : bool, optional\\n    If `True` (default), arrays will be copied. If `False`, arrays will\\n    be references, though possibly broadcast to ensure matching shapes.', 'implementation': '1013 class SphericalDifferential(BaseSphericalDifferential):\\n1014     \"\"\"Differential(s) of points in 3D spherical coordinates.\\n1015 \\n1016     Parameters\\n1017     ----------\\n1018     d_lon, d_lat : `~astropy.units.Quantity`\\n1019         The differential longitude and latitude.\\n1020     d_distance : `~astropy.units.Quantity`\\n1021         The differential distance.\\n1022     copy : bool, optional\\n1023         If `True` (default), arrays will be copied. If `False`, arrays will\\n1024         be references, though possibly broadcast to ensure matching shapes.\\n1025     \"\"\"\\n1026 \\n1027     base_representation = SphericalRepresentation\\n1028     _unit_differential = UnitSphericalDifferential\\n1029 \\n1030     def __init__(self, d_lon, d_lat=None, d_distance=None, copy=True):\\n1031         super().__init__(d_lon, d_lat, d_distance, copy=copy)\\n1032         if not self._d_lon.unit.is_equivalent(self._d_lat.unit):\\n1033             raise u.UnitsError(\"d_lon and d_lat should have equivalent units.\")\\n1034 \\n1035     def represent_as(self, other_class, base=None):\\n1036         # All spherical differentials can be done without going to Cartesian,\\n1037         # though CosLat needs base for the latitude.\\n1038         if issubclass(other_class, UnitSphericalDifferential):\\n1039             return other_class(self.d_lon, self.d_lat)\\n1040         elif issubclass(other_class, RadialDifferential):\\n1041             return other_class(self.d_distance)\\n1042         elif issubclass(other_class, SphericalCosLatDifferential):\\n1043             return other_class(self._d_lon_coslat(base), self.d_lat, self.d_distance)\\n1044         elif issubclass(other_class, UnitSphericalCosLatDifferential):\\n1045             return other_class(self._d_lon_coslat(base), self.d_lat)\\n1046         elif issubclass(other_class, PhysicsSphericalDifferential):\\n1047             return other_class(self.d_lon, -self.d_lat, self.d_distance)\\n1048         else:\\n1049             return super().represent_as(other_class, base)\\n1050 \\n1051     @classmethod\\n1052     def from_representation(cls, representation, base=None):\\n1053         # Other spherical differentials can be done without going to Cartesian,\\n1054         # though CosLat needs base for the latitude.\\n1055         if isinstance(representation, SphericalCosLatDifferential):\\n1056             d_lon = cls._get_d_lon(representation.d_lon_coslat, base)\\n1057             return cls(d_lon, representation.d_lat, representation.d_distance)\\n1058         elif isinstance(representation, PhysicsSphericalDifferential):\\n1059             return cls(\\n1060                 representation.d_phi, -representation.d_theta, representation.d_r\\n1061             )\\n1062 \\n1063         return super().from_representation(representation, base)\\n1064 \\n1065     def _scale_operation(self, op, *args, scaled_base=False):\\n1066         if scaled_base:\\n1067             return self.__class__(self.d_lon, self.d_lat, op(self.d_distance, *args))\\n1068         else:\\n1069             return super()._scale_operation(op, *args)\\n1070 '}, {'name': 'SphericalDifferential', 'full_name': 'astropy.coordinates.representation.spherical.SphericalDifferential', 'documentation': None, 'implementation': 'class SphericalDifferential'}], 'SkyCoord': [{'name': 'SkyCoord', 'full_name': 'astropy.coordinates.sky_coordinate.SkyCoord', 'documentation': 'High-level object providing a flexible interface for celestial coordinate\\nrepresentation, manipulation, and transformation between systems.\\n\\nThe |SkyCoord| class accepts a wide variety of inputs for initialization. At\\na minimum these must provide one or more celestial coordinate values with\\nunambiguous units.  Inputs may be scalars or lists/tuples/arrays, yielding\\nscalar or array coordinates (can be checked via ``SkyCoord.isscalar``).\\nTypically one also specifies the coordinate frame, though this is not\\nrequired. The general pattern for spherical representations is::\\n\\n  SkyCoord(COORD, [FRAME], keyword_args ...)\\n  SkyCoord(LON, LAT, [FRAME], keyword_args ...)\\n  SkyCoord(LON, LAT, [DISTANCE], frame=FRAME, unit=UNIT, keyword_args ...)\\n  SkyCoord([FRAME], <lon_attr>=LON, <lat_attr>=LAT, keyword_args ...)\\n\\nIt is also possible to input coordinate values in other representations\\nsuch as cartesian or cylindrical.  In this case one includes the keyword\\nargument ``representation_type=\\'cartesian\\'`` (for example) along with data\\nin ``x``, ``y``, and ``z``.\\n\\nSee also: https://docs.astropy.org/en/stable/coordinates/\\n\\nExamples\\n--------\\nThe examples below illustrate common ways of initializing a |SkyCoord|\\nobject.  For a complete description of the allowed syntax see the\\nfull coordinates documentation.  First some imports::\\n\\n  >>> from astropy.coordinates import SkyCoord  # High-level coordinates\\n  >>> from astropy.coordinates import ICRS, Galactic, FK4, FK5  # Low-level frames\\n  >>> from astropy.coordinates import Angle, Latitude, Longitude  # Angles\\n  >>> import astropy.units as u\\n\\nThe coordinate values and frame specification can now be provided using\\npositional and keyword arguments::\\n\\n  >>> c = SkyCoord(10, 20, unit=\"deg\")  # defaults to ICRS frame\\n  >>> c = SkyCoord([1, 2, 3], [-30, 45, 8], frame=\"icrs\", unit=\"deg\")  # 3 coords\\n\\n  >>> coords = [\"1:12:43.2 +31:12:43\", \"1 12 43.2 +31 12 43\"]\\n  >>> c = SkyCoord(coords, frame=FK4, unit=(u.hourangle, u.deg), obstime=\"J1992.21\")\\n\\n  >>> c = SkyCoord(\"1h12m43.2s +1d12m43s\", frame=Galactic)  # Units from string\\n  >>> c = SkyCoord(frame=\"galactic\", l=\"1h12m43.2s\", b=\"+1d12m43s\")\\n\\n  >>> ra = Longitude([1, 2, 3], unit=u.deg)  # Could also use Angle\\n  >>> dec = np.array([4.5, 5.2, 6.3]) * u.deg  # Astropy Quantity\\n  >>> c = SkyCoord(ra, dec, frame=\\'icrs\\')\\n  >>> c = SkyCoord(frame=ICRS, ra=ra, dec=dec, obstime=\\'2001-01-02T12:34:56\\')\\n\\n  >>> c = FK4(1 * u.deg, 2 * u.deg)  # Uses defaults for obstime, equinox\\n  >>> c = SkyCoord(c, obstime=\\'J2010.11\\', equinox=\\'B1965\\')  # Override defaults\\n\\n  >>> c = SkyCoord(w=0, u=1, v=2, unit=\\'kpc\\', frame=\\'galactic\\',\\n  ...              representation_type=\\'cartesian\\')\\n\\n  >>> c = SkyCoord([ICRS(ra=1*u.deg, dec=2*u.deg), ICRS(ra=3*u.deg, dec=4*u.deg)])\\n\\nVelocity components (proper motions or radial velocities) can also be\\nprovided in a similar manner::\\n\\n  >>> c = SkyCoord(ra=1*u.deg, dec=2*u.deg, radial_velocity=10*u.km/u.s)\\n\\n  >>> c = SkyCoord(ra=1*u.deg, dec=2*u.deg, pm_ra_cosdec=2*u.mas/u.yr, pm_dec=1*u.mas/u.yr)\\n\\nAs shown, the frame can be a `~astropy.coordinates.BaseCoordinateFrame`\\nclass or the corresponding string alias -- lower-case versions of the\\nclass name that allow for creating a |SkyCoord| object and transforming\\nframes without explicitly importing the frame classes.\\n\\nParameters\\n----------\\nframe : `~astropy.coordinates.BaseCoordinateFrame` class or string, optional\\n    Type of coordinate frame this |SkyCoord| should represent. Defaults to\\n    to ICRS if not given or given as None.\\nunit : `~astropy.units.Unit`, string, or tuple of :class:`~astropy.units.Unit` or str, optional\\n    Units for supplied coordinate values.\\n    If only one unit is supplied then it applies to all values.\\n    Note that passing only one unit might lead to unit conversion errors\\n    if the coordinate values are expected to have mixed physical meanings\\n    (e.g., angles and distances).\\nobstime : time-like, optional\\n    Time(s) of observation.\\nequinox : time-like, optional\\n    Coordinate frame equinox time.\\nrepresentation_type : str or Representation class\\n    Specifies the representation, e.g. \\'spherical\\', \\'cartesian\\', or\\n    \\'cylindrical\\'.  This affects the positional args and other keyword args\\n    which must correspond to the given representation.\\ncopy : bool, optional\\n    If `True` (default), a copy of any coordinate data is made.  This\\n    argument can only be passed in as a keyword argument.\\n**keyword_args\\n    Other keyword arguments as applicable for user-defined coordinate frames.\\n    Common options include:\\n\\n    ra, dec : angle-like, optional\\n        RA and Dec for frames where ``ra`` and ``dec`` are keys in the\\n        frame\\'s ``representation_component_names``, including ``ICRS``,\\n        ``FK5``, ``FK4``, and ``FK4NoETerms``.\\n    pm_ra_cosdec, pm_dec  : `~astropy.units.Quantity` [\\'angular speed\\'], optional\\n        Proper motion components, in angle per time units.\\n    l, b : angle-like, optional\\n        Galactic ``l`` and ``b`` for for frames where ``l`` and ``b`` are\\n        keys in the frame\\'s ``representation_component_names``, including\\n        the ``Galactic`` frame.\\n    pm_l_cosb, pm_b : `~astropy.units.Quantity` [\\'angular speed\\'], optional\\n        Proper motion components in the `~astropy.coordinates.Galactic` frame,\\n        in angle per time units.\\n    x, y, z : float or `~astropy.units.Quantity` [\\'length\\'], optional\\n        Cartesian coordinates values\\n    u, v, w : float or `~astropy.units.Quantity` [\\'length\\'], optional\\n        Cartesian coordinates values for the Galactic frame.\\n    radial_velocity : `~astropy.units.Quantity` [\\'speed\\'], optional\\n        The component of the velocity along the line-of-sight (i.e., the\\n        radial direction), in velocity units.', 'implementation': '167 class SkyCoord(ShapedLikeNDArray):\\n168     \"\"\"High-level object providing a flexible interface for celestial coordinate\\n169     representation, manipulation, and transformation between systems.\\n170 \\n171     The |SkyCoord| class accepts a wide variety of inputs for initialization. At\\n172     a minimum these must provide one or more celestial coordinate values with\\n173     unambiguous units.  Inputs may be scalars or lists/tuples/arrays, yielding\\n174     scalar or array coordinates (can be checked via ``SkyCoord.isscalar``).\\n175     Typically one also specifies the coordinate frame, though this is not\\n176     required. The general pattern for spherical representations is::\\n177 \\n178       SkyCoord(COORD, [FRAME], keyword_args ...)\\n179       SkyCoord(LON, LAT, [FRAME], keyword_args ...)\\n180       SkyCoord(LON, LAT, [DISTANCE], frame=FRAME, unit=UNIT, keyword_args ...)\\n181       SkyCoord([FRAME], <lon_attr>=LON, <lat_attr>=LAT, keyword_args ...)\\n182 \\n183     It is also possible to input coordinate values in other representations\\n184     such as cartesian or cylindrical.  In this case one includes the keyword\\n185     argument ``representation_type=\\'cartesian\\'`` (for example) along with data\\n186     in ``x``, ``y``, and ``z``.\\n187 \\n188     See also: https://docs.astropy.org/en/stable/coordinates/\\n189 \\n190     Examples\\n191     --------\\n192     The examples below illustrate common ways of initializing a |SkyCoord|\\n193     object.  For a complete description of the allowed syntax see the\\n194     full coordinates documentation.  First some imports::\\n195 \\n196       >>> from astropy.coordinates import SkyCoord  # High-level coordinates\\n197       >>> from astropy.coordinates import ICRS, Galactic, FK4, FK5  # Low-level frames\\n198       >>> from astropy.coordinates import Angle, Latitude, Longitude  # Angles\\n199       >>> import astropy.units as u\\n200 \\n201     The coordinate values and frame specification can now be provided using\\n202     positional and keyword arguments::\\n203 \\n204       >>> c = SkyCoord(10, 20, unit=\"deg\")  # defaults to ICRS frame\\n205       >>> c = SkyCoord([1, 2, 3], [-30, 45, 8], frame=\"icrs\", unit=\"deg\")  # 3 coords\\n206 \\n207       >>> coords = [\"1:12:43.2 +31:12:43\", \"1 12 43.2 +31 12 43\"]\\n208       >>> c = SkyCoord(coords, frame=FK4, unit=(u.hourangle, u.deg), obstime=\"J1992.21\")\\n209 \\n210       >>> c = SkyCoord(\"1h12m43.2s +1d12m43s\", frame=Galactic)  # Units from string\\n211       >>> c = SkyCoord(frame=\"galactic\", l=\"1h12m43.2s\", b=\"+1d12m43s\")\\n212 \\n213       >>> ra = Longitude([1, 2, 3], unit=u.deg)  # Could also use Angle\\n214       >>> dec = np.array([4.5, 5.2, 6.3]) * u.deg  # Astropy Quantity\\n215       >>> c = SkyCoord(ra, dec, frame=\\'icrs\\')\\n216       >>> c = SkyCoord(frame=ICRS, ra=ra, dec=dec, obstime=\\'2001-01-02T12:34:56\\')\\n217 \\n218       >>> c = FK4(1 * u.deg, 2 * u.deg)  # Uses defaults for obstime, equinox\\n219       >>> c = SkyCoord(c, obstime=\\'J2010.11\\', equinox=\\'B1965\\')  # Override defaults\\n220 \\n221       >>> c = SkyCoord(w=0, u=1, v=2, unit=\\'kpc\\', frame=\\'galactic\\',\\n222       ...              representation_type=\\'cartesian\\')\\n223 \\n224       >>> c = SkyCoord([ICRS(ra=1*u.deg, dec=2*u.deg), ICRS(ra=3*u.deg, dec=4*u.deg)])\\n225 \\n226     Velocity components (proper motions or radial velocities) can also be\\n227     provided in a similar manner::\\n228 \\n229       >>> c = SkyCoord(ra=1*u.deg, dec=2*u.deg, radial_velocity=10*u.km/u.s)\\n230 \\n231       >>> c = SkyCoord(ra=1*u.deg, dec=2*u.deg, pm_ra_cosdec=2*u.mas/u.yr, pm_dec=1*u.mas/u.yr)\\n232 \\n233     As shown, the frame can be a `~astropy.coordinates.BaseCoordinateFrame`\\n234     class or the corresponding string alias -- lower-case versions of the\\n235     class name that allow for creating a |SkyCoord| object and transforming\\n236     frames without explicitly importing the frame classes.\\n237 \\n238     Parameters\\n239     ----------\\n240     frame : `~astropy.coordinates.BaseCoordinateFrame` class or string, optional\\n241         Type of coordinate frame this |SkyCoord| should represent. Defaults to\\n242         to ICRS if not given or given as None.\\n243     unit : `~astropy.units.Unit`, string, or tuple of :class:`~astropy.units.Unit` or str, optional\\n244         Units for supplied coordinate values.\\n245         If only one unit is supplied then it applies to all values.\\n246         Note that passing only one unit might lead to unit conversion errors\\n247         if the coordinate values are expected to have mixed physical meanings\\n248         (e.g., angles and distances).\\n249     obstime : time-like, optional\\n250         Time(s) of observation.\\n251     equinox : time-like, optional\\n252         Coordinate frame equinox time.\\n253     representation_type : str or Representation class\\n254         Specifies the representation, e.g. \\'spherical\\', \\'cartesian\\', or\\n255         \\'cylindrical\\'.  This affects the positional args and other keyword args\\n256         which must correspond to the given representation.\\n257     copy : bool, optional\\n258         If `True` (default), a copy of any coordinate data is made.  This\\n259         argument can only be passed in as a keyword argument.\\n260     **keyword_args\\n261         Other keyword arguments as applicable for user-defined coordinate frames.\\n262         Common options include:\\n263 \\n264         ra, dec : angle-like, optional\\n265             RA and Dec for frames where ``ra`` and ``dec`` are keys in the\\n266             frame\\'s ``representation_component_names``, including ``ICRS``,\\n267             ``FK5``, ``FK4``, and ``FK4NoETerms``.\\n268         pm_ra_cosdec, pm_dec  : `~astropy.units.Quantity` [\\'angular speed\\'], optional\\n269             Proper motion components, in angle per time units.\\n270         l, b : angle-like, optional\\n271             Galactic ``l`` and ``b`` for for frames where ``l`` and ``b`` are\\n272             keys in the frame\\'s ``representation_component_names``, including\\n273             the ``Galactic`` frame.\\n274         pm_l_cosb, pm_b : `~astropy.units.Quantity` [\\'angular speed\\'], optional\\n275             Proper motion components in the `~astropy.coordinates.Galactic` frame,\\n276             in angle per time units.\\n277         x, y, z : float or `~astropy.units.Quantity` [\\'length\\'], optional\\n278             Cartesian coordinates values\\n279         u, v, w : float or `~astropy.units.Quantity` [\\'length\\'], optional\\n280             Cartesian coordinates values for the Galactic frame.\\n281         radial_velocity : `~astropy.units.Quantity` [\\'speed\\'], optional\\n282             The component of the velocity along the line-of-sight (i.e., the\\n283             radial direction), in velocity units.\\n284     \"\"\"\\n285 \\n286     # Declare that SkyCoord can be used as a Table column by defining the\\n287     # info property.\\n288     info = SkyCoordInfo()\\n289 \\n290     def __init__(self, *args, copy=True, **kwargs):\\n291         # these are frame attributes set on this SkyCoord but *not* a part of\\n292         # the frame object this SkyCoord contains\\n293         self._extra_frameattr_names = set()\\n294 \\n295         # If all that is passed in is a frame instance that already has data,\\n296         # we should bypass all of the parsing and logic below. This is here\\n297         # to make this the fastest way to create a SkyCoord instance. Many of\\n298         # the classmethods implemented for performance enhancements will use\\n299         # this as the initialization path\\n300         if (\\n301             len(args) == 1\\n302             and len(kwargs) == 0\\n303             and isinstance(args[0], (BaseCoordinateFrame, SkyCoord))\\n304         ):\\n305             coords = args[0]\\n306             if isinstance(coords, SkyCoord):\\n307                 self._extra_frameattr_names = coords._extra_frameattr_names\\n308                 self.info = coords.info\\n309 \\n310                 # Copy over any extra frame attributes\\n311                 for attr_name in self._extra_frameattr_names:\\n312                     # Setting it will also validate it.\\n313                     setattr(self, attr_name, getattr(coords, attr_name))\\n314 \\n315                 coords = coords.frame\\n316 \\n317             if not coords.has_data:\\n318                 raise ValueError(\\n319                     \"Cannot initialize from a coordinate frame \"\\n320                     \"instance without coordinate data\"\\n321                 )\\n322 \\n323             if copy:\\n324                 self._sky_coord_frame = coords.copy()\\n325             else:\\n326                 self._sky_coord_frame = coords\\n327 \\n328         else:\\n329             # Get the frame instance without coordinate data but with all frame\\n330             # attributes set - these could either have been passed in with the\\n331             # frame as an instance, or passed in as kwargs here\\n332             frame_cls, frame_kwargs = _get_frame_without_data(args, kwargs)\\n333 \\n334             # Parse the args and kwargs to assemble a sanitized and validated\\n335             # kwargs dict for initializing attributes for this object and for\\n336             # creating the internal self._sky_coord_frame object\\n337             args = list(args)  # Make it mutable\\n338             skycoord_kwargs, components, info = _parse_coordinate_data(\\n339                 frame_cls(**frame_kwargs), args, kwargs\\n340             )\\n341 \\n342             # In the above two parsing functions, these kwargs were identified\\n343             # as valid frame attributes for *some* frame, but not the frame that\\n344             # this SkyCoord will have. We keep these attributes as special\\n345             # skycoord frame attributes:\\n346             for attr in skycoord_kwargs:\\n347                 # Setting it will also validate it.\\n348                 setattr(self, attr, skycoord_kwargs[attr])\\n349 \\n350             if info is not None:\\n351                 self.info = info\\n352 \\n353             # Finally make the internal coordinate object.\\n354             frame_kwargs.update(components)\\n355             self._sky_coord_frame = frame_cls(copy=copy, **frame_kwargs)\\n356 \\n357             if not self._sky_coord_frame.has_data:\\n358                 raise ValueError(\"Cannot create a SkyCoord without data\")\\n359 \\n360     @property\\n361     def frame(self):\\n362         return self._sky_coord_frame\\n363 \\n364     @property\\n365     def representation_type(self):\\n366         return self.frame.representation_type\\n367 \\n368     @representation_type.setter\\n369     def representation_type(self, value):\\n370         self.frame.representation_type = value\\n371 \\n372     @property\\n373     def shape(self):\\n374         return self.frame.shape\\n375 \\n376     def __eq__(self, value):\\n377         \"\"\"Equality operator for SkyCoord.\\n378 \\n379         This implements strict equality and requires that the frames are\\n380         equivalent, extra frame attributes are equivalent, and that the\\n381         representation data are exactly equal.\\n382         \"\"\"\\n383         if isinstance(value, BaseCoordinateFrame):\\n384             if value._data is None:\\n385                 raise ValueError(\"Can only compare SkyCoord to Frame with data\")\\n386 \\n387             return self.frame == value\\n388 \\n389         if not isinstance(value, SkyCoord):\\n390             return NotImplemented\\n391 \\n392         # Make sure that any extra frame attribute names are equivalent.\\n393         for attr in self._extra_frameattr_names | value._extra_frameattr_names:\\n394             if not self.frame._frameattr_equiv(\\n395                 getattr(self, attr), getattr(value, attr)\\n396             ):\\n397                 raise ValueError(\\n398                     f\"cannot compare: extra frame attribute \\'{attr}\\' is not equivalent\"\\n399                     \" (perhaps compare the frames directly to avoid this exception)\"\\n400                 )\\n401 \\n402         return self._sky_coord_frame == value._sky_coord_frame\\n403 \\n404     def __ne__(self, value):\\n405         return np.logical_not(self == value)\\n406 \\n407     def _apply(self, method, *args, **kwargs):\\n408         \"\"\"Create a new instance, applying a method to the underlying data.\\n409 \\n410         In typical usage, the method is any of the shape-changing methods for\\n411         `~numpy.ndarray` (``reshape``, ``swapaxes``, etc.), as well as those\\n412         picking particular elements (``__getitem__``, ``take``, etc.), which\\n413         are all defined in `~astropy.utils.shapes.ShapedLikeNDArray`. It will be\\n414         applied to the underlying arrays in the representation (e.g., ``x``,\\n415         ``y``, and ``z`` for `~astropy.coordinates.CartesianRepresentation`),\\n416         as well as to any frame attributes that have a shape, with the results\\n417         used to create a new instance.\\n418 \\n419         Internally, it is also used to apply functions to the above parts\\n420         (in particular, `~numpy.broadcast_to`).\\n421 \\n422         Parameters\\n423         ----------\\n424         method : str or callable\\n425             If str, it is the name of a method that is applied to the internal\\n426             ``components``. If callable, the function is applied.\\n427         *args\\n428             Any positional arguments for ``method``.\\n429         **kwargs : dict\\n430             Any keyword arguments for ``method``.\\n431         \"\"\"\\n432 \\n433         def apply_method(value):\\n434             if isinstance(value, ShapedLikeNDArray):\\n435                 return value._apply(method, *args, **kwargs)\\n436             else:\\n437                 if callable(method):\\n438                     return method(value, *args, **kwargs)\\n439                 else:\\n440                     return getattr(value, method)(*args, **kwargs)\\n441 \\n442         # create a new but empty instance, and copy over stuff\\n443         new = super().__new__(self.__class__)\\n444         new._sky_coord_frame = self._sky_coord_frame._apply(method, *args, **kwargs)\\n445         new._extra_frameattr_names = self._extra_frameattr_names.copy()\\n446         for attr in self._extra_frameattr_names:\\n447             value = getattr(self, attr)\\n448             if getattr(value, \"shape\", ()):\\n449                 value = apply_method(value)\\n450             elif method == \"copy\" or method == \"flatten\":\\n451                 # flatten should copy also for a single element array, but\\n452                 # we cannot use it directly for array scalars, since it\\n453                 # always returns a one-dimensional array. So, just copy.\\n454                 value = copy.copy(value)\\n455             setattr(new, \"_\" + attr, value)\\n456 \\n457         # Copy other \\'info\\' attr only if it has actually been defined.\\n458         # See PR #3898 for further explanation and justification, along\\n459         # with Quantity.__array_finalize__\\n460         if \"info\" in self.__dict__:\\n461             new.info = self.info\\n462 \\n463         return new\\n464 \\n465     def __setitem__(self, item, value):\\n466         \"\"\"Implement self[item] = value for SkyCoord.\\n467 \\n468         The right hand ``value`` must be strictly consistent with self:\\n469         - Identical class\\n470         - Equivalent frames\\n471         - Identical representation_types\\n472         - Identical representation differentials keys\\n473         - Identical frame attributes\\n474         - Identical \"extra\" frame attributes (e.g. obstime for an ICRS coord)\\n475 \\n476         With these caveats the setitem ends up as effectively a setitem on\\n477         the representation data.\\n478 \\n479           self.frame.data[item] = value.frame.data\\n480         \"\"\"\\n481         if self.__class__ is not value.__class__:\\n482             raise TypeError(\\n483                 \"can only set from object of same class: \"\\n484                 f\"{self.__class__.__name__} vs. {value.__class__.__name__}\"\\n485             )\\n486 \\n487         # Make sure that any extra frame attribute names are equivalent.\\n488         for attr in self._extra_frameattr_names | value._extra_frameattr_names:\\n489             if not self.frame._frameattr_equiv(\\n490                 getattr(self, attr), getattr(value, attr)\\n491             ):\\n492                 raise ValueError(f\"attribute {attr} is not equivalent\")\\n493 \\n494         # Set the frame values.  This checks frame equivalence and also clears\\n495         # the cache to ensure that the object is not in an inconsistent state.\\n496         self._sky_coord_frame[item] = value._sky_coord_frame\\n497 \\n498     def insert(self, obj, values, axis=0):\\n499         \"\"\"\\n500         Insert coordinate values before the given indices in the object and\\n501         return a new Frame object.\\n502 \\n503         The values to be inserted must conform to the rules for in-place setting\\n504         of |SkyCoord| objects.\\n505 \\n506         The API signature matches the ``np.insert`` API, but is more limited.\\n507         The specification of insert index ``obj`` must be a single integer,\\n508         and the ``axis`` must be ``0`` for simple insertion before the index.\\n509 \\n510         Parameters\\n511         ----------\\n512         obj : int\\n513             Integer index before which ``values`` is inserted.\\n514         values : array-like\\n515             Value(s) to insert.  If the type of ``values`` is different\\n516             from that of quantity, ``values`` is converted to the matching type.\\n517         axis : int, optional\\n518             Axis along which to insert ``values``.  Default is 0, which is the\\n519             only allowed value and will insert a row.\\n520 \\n521         Returns\\n522         -------\\n523         out : `~astropy.coordinates.SkyCoord` instance\\n524             New coordinate object with inserted value(s)\\n525 \\n526         \"\"\"\\n527         # Validate inputs: obj arg is integer, axis=0, self is not a scalar, and\\n528         # input index is in bounds.\\n529         try:\\n530             idx0 = operator.index(obj)\\n531         except TypeError:\\n532             raise TypeError(\"obj arg must be an integer\")\\n533 \\n534         if axis != 0:\\n535             raise ValueError(\"axis must be 0\")\\n536 \\n537         if not self.shape:\\n538             raise TypeError(\\n539                 f\"cannot insert into scalar {self.__class__.__name__} object\"\\n540             )\\n541 \\n542         if abs(idx0) > len(self):\\n543             raise IndexError(\\n544                 f\"index {idx0} is out of bounds for axis 0 with size {len(self)}\"\\n545             )\\n546 \\n547         # Turn negative index into positive\\n548         if idx0 < 0:\\n549             idx0 = len(self) + idx0\\n550 \\n551         n_values = len(values) if values.shape else 1\\n552 \\n553         # Finally make the new object with the correct length and set values for the\\n554         # three sections, before insert, the insert, and after the insert.\\n555         out = self.__class__.info.new_like(\\n556             [self], len(self) + n_values, name=self.info.name\\n557         )\\n558 \\n559         # Set the output values. This is where validation of `values` takes place to ensure\\n560         # that it can indeed be inserted.\\n561         out[:idx0] = self[:idx0]\\n562         out[idx0 : idx0 + n_values] = values\\n563         out[idx0 + n_values :] = self[idx0:]\\n564 \\n565         return out\\n566 \\n567     def is_transformable_to(self, new_frame):\\n568         \"\"\"\\n569         Determines if this coordinate frame can be transformed to another\\n570         given frame.\\n571 \\n572         Parameters\\n573         ----------\\n574         new_frame : frame class, frame object, or str\\n575             The proposed frame to transform into.\\n576 \\n577         Returns\\n578         -------\\n579         transformable : bool or str\\n580             `True` if this can be transformed to ``new_frame``, `False` if\\n581             not, or the string \\'same\\' if ``new_frame`` is the same system as\\n582             this object but no transformation is defined.\\n583 \\n584         Notes\\n585         -----\\n586         A return value of \\'same\\' means the transformation will work, but it will\\n587         just give back a copy of this object.  The intended usage is::\\n588 \\n589             if coord.is_transformable_to(some_unknown_frame):\\n590                 coord2 = coord.transform_to(some_unknown_frame)\\n591 \\n592         This will work even if ``some_unknown_frame``  turns out to be the same\\n593         frame class as ``coord``.  This is intended for cases where the frame\\n594         is the same regardless of the frame attributes (e.g. ICRS), but be\\n595         aware that it *might* also indicate that someone forgot to define the\\n596         transformation between two objects of the same frame class but with\\n597         different attributes.\\n598         \"\"\"\\n599         # TODO! like matplotlib, do string overrides for modified methods\\n600         new_frame = (\\n601             _get_frame_class(new_frame) if isinstance(new_frame, str) else new_frame\\n602         )\\n603         return self.frame.is_transformable_to(new_frame)\\n604 \\n605     def transform_to(self, frame, merge_attributes=True):\\n606         \"\"\"Transform this coordinate to a new frame.\\n607 \\n608         The precise frame transformed to depends on ``merge_attributes``.\\n609         If `False`, the destination frame is used exactly as passed in.\\n610         But this is often not quite what one wants.  E.g., suppose one wants to\\n611         transform an ICRS coordinate that has an obstime attribute to FK4; in\\n612         this case, one likely would want to use this information. Thus, the\\n613         default for ``merge_attributes`` is `True`, in which the precedence is\\n614         as follows: (1) explicitly set (i.e., non-default) values in the\\n615         destination frame; (2) explicitly set values in the source; (3) default\\n616         value in the destination frame.\\n617 \\n618         Note that in either case, any explicitly set attributes on the source\\n619         |SkyCoord| that are not part of the destination frame\\'s definition are\\n620         kept (stored on the resulting |SkyCoord|), and thus one can round-trip\\n621         (e.g., from FK4 to ICRS to FK4 without losing obstime).\\n622 \\n623         Parameters\\n624         ----------\\n625         frame : str, `~astropy.coordinates.BaseCoordinateFrame` class or instance, or |SkyCoord| instance\\n626             The frame to transform this coordinate into.  If a |SkyCoord|, the\\n627             underlying frame is extracted, and all other information ignored.\\n628         merge_attributes : bool, optional\\n629             Whether the default attributes in the destination frame are allowed\\n630             to be overridden by explicitly set attributes in the source\\n631             (see note above; default: `True`).\\n632 \\n633         Returns\\n634         -------\\n635         coord : |SkyCoord|\\n636             A new object with this coordinate represented in the `frame` frame.\\n637 \\n638         Raises\\n639         ------\\n640         ValueError\\n641             If there is no possible transformation route.\\n642 \\n643         \"\"\"\\n644         from astropy.coordinates.errors import ConvertError\\n645 \\n646         frame_kwargs = {}\\n647 \\n648         # Frame name (string) or frame class?  Coerce into an instance.\\n649         try:\\n650             frame = _get_frame_class(frame)()\\n651         except Exception:\\n652             pass\\n653 \\n654         if isinstance(frame, SkyCoord):\\n655             frame = frame.frame  # Change to underlying coord frame instance\\n656 \\n657         if isinstance(frame, BaseCoordinateFrame):\\n658             new_frame_cls = frame.__class__\\n659             # Get frame attributes, allowing defaults to be overridden by\\n660             # explicitly set attributes of the source if ``merge_attributes``.\\n661             for attr in frame_transform_graph.frame_attributes:\\n662                 self_val = getattr(self, attr, None)\\n663                 frame_val = getattr(frame, attr, None)\\n664                 if frame_val is not None and not (\\n665                     merge_attributes and frame.is_frame_attr_default(attr)\\n666                 ):\\n667                     frame_kwargs[attr] = frame_val\\n668                 elif self_val is not None and not self.is_frame_attr_default(attr):\\n669                     frame_kwargs[attr] = self_val\\n670                 elif frame_val is not None:\\n671                     frame_kwargs[attr] = frame_val\\n672         else:\\n673             raise ValueError(\\n674                 \"Transform `frame` must be a frame name, class, or instance\"\\n675             )\\n676 \\n677         # Get the composite transform to the new frame\\n678         trans = frame_transform_graph.get_transform(self.frame.__class__, new_frame_cls)\\n679         if trans is None:\\n680             raise ConvertError(\\n681                 f\"Cannot transform from {self.frame.__class__} to {new_frame_cls}\"\\n682             )\\n683 \\n684         # Make a generic frame which will accept all the frame kwargs that\\n685         # are provided and allow for transforming through intermediate frames\\n686         # which may require one or more of those kwargs.\\n687         generic_frame = GenericFrame(frame_kwargs)\\n688 \\n689         # Do the transformation, returning a coordinate frame of the desired\\n690         # final type (not generic).\\n691         new_coord = trans(self.frame, generic_frame)\\n692 \\n693         # Finally make the new SkyCoord object from the `new_coord` and\\n694         # remaining frame_kwargs that are not frame_attributes in `new_coord`.\\n695         for attr in set(new_coord.frame_attributes) & set(frame_kwargs.keys()):\\n696             frame_kwargs.pop(attr)\\n697 \\n698         # Always remove the origin frame attribute, as that attribute only makes\\n699         # sense with a SkyOffsetFrame (in which case it will be stored on the frame).\\n700         # See gh-11277.\\n701         # TODO: Should it be a property of the frame attribute that it can\\n702         # or cannot be stored on a SkyCoord?\\n703         frame_kwargs.pop(\"origin\", None)\\n704 \\n705         return self.__class__(new_coord, **frame_kwargs)\\n706 \\n707     def apply_space_motion(self, new_obstime=None, dt=None):\\n708         \"\"\"Compute the position to a new time using the velocities.\\n709 \\n710         Compute the position of the source represented by this coordinate object\\n711         to a new time using the velocities stored in this object and assuming\\n712         linear space motion (including relativistic corrections). This is\\n713         sometimes referred to as an \"epoch transformation\".\\n714 \\n715         The initial time before the evolution is taken from the ``obstime``\\n716         attribute of this coordinate.  Note that this method currently does not\\n717         support evolving coordinates where the *frame* has an ``obstime`` frame\\n718         attribute, so the ``obstime`` is only used for storing the before and\\n719         after times, not actually as an attribute of the frame. Alternatively,\\n720         if ``dt`` is given, an ``obstime`` need not be provided at all.\\n721 \\n722         Parameters\\n723         ----------\\n724         new_obstime : `~astropy.time.Time`, optional\\n725             The time at which to evolve the position to. Requires that the\\n726             ``obstime`` attribute be present on this frame.\\n727         dt : `~astropy.units.Quantity`, `~astropy.time.TimeDelta`, optional\\n728             An amount of time to evolve the position of the source. Cannot be\\n729             given at the same time as ``new_obstime``.\\n730 \\n731         Returns\\n732         -------\\n733         new_coord : |SkyCoord|\\n734             A new coordinate object with the evolved location of this coordinate\\n735             at the new time.  ``obstime`` will be set on this object to the new\\n736             time only if ``self`` also has ``obstime``.\\n737         \"\"\"\\n738         from .builtin_frames.icrs import ICRS\\n739 \\n740         if (new_obstime is None) == (dt is None):\\n741             raise ValueError(\\n742                 \"You must specify one of `new_obstime` or `dt`, but not both.\"\\n743             )\\n744 \\n745         # Validate that we have velocity info\\n746         if \"s\" not in self.frame.data.differentials:\\n747             raise ValueError(\"SkyCoord requires velocity data to evolve the position.\")\\n748 \\n749         if \"obstime\" in self.frame.frame_attributes:\\n750             raise NotImplementedError(\\n751                 \"Updating the coordinates in a frame with explicit time dependence is\"\\n752                 \" currently not supported. If you would like this functionality, please\"\\n753                 \" open an issue on github:\\\\nhttps://github.com/astropy/astropy\"\\n754             )\\n755 \\n756         if new_obstime is not None and self.obstime is None:\\n757             # If no obstime is already on this object, raise an error if a new\\n758             # obstime is passed: we need to know the time / epoch at which the\\n759             # the position / velocity were measured initially\\n760             raise ValueError(\\n761                 \"This object has no associated `obstime`. apply_space_motion() must\"\\n762                 \" receive a time difference, `dt`, and not a new obstime.\"\\n763             )\\n764 \\n765         # Compute t1 and t2, the times used in the starpm call, which *only*\\n766         # uses them to compute a delta-time\\n767         t1 = self.obstime\\n768         if dt is None:\\n769             # self.obstime is not None and new_obstime is not None b/c of above\\n770             # checks\\n771             t2 = new_obstime\\n772         else:\\n773             # new_obstime is definitely None b/c of the above checks\\n774             if t1 is None:\\n775                 # MAGIC NUMBER: if the current SkyCoord object has no obstime,\\n776                 # assume J2000 to do the dt offset. This is not actually used\\n777                 # for anything except a delta-t in starpm, so it\\'s OK that it\\'s\\n778                 # not necessarily the \"real\" obstime\\n779                 t1 = Time(\"J2000\")\\n780                 new_obstime = None  # we don\\'t actually know the initial obstime\\n781                 t2 = t1 + dt\\n782             else:\\n783                 t2 = t1 + dt\\n784                 new_obstime = t2\\n785         # starpm wants tdb time\\n786         t1 = t1.tdb\\n787         t2 = t2.tdb\\n788 \\n789         # proper motion in RA should not include the cos(dec) term, see the\\n790         # erfa function eraStarpv, comment (4).  So we convert to the regular\\n791         # spherical differentials.\\n792         icrsrep = self.icrs.represent_as(SphericalRepresentation, SphericalDifferential)\\n793         icrsvel = icrsrep.differentials[\"s\"]\\n794 \\n795         parallax_zero = False\\n796         try:\\n797             plx = icrsrep.distance.to_value(u.arcsecond, u.parallax())\\n798         except u.UnitConversionError:  # No distance: set to 0 by convention\\n799             plx = 0.0\\n800             parallax_zero = True\\n801 \\n802         try:\\n803             rv = icrsvel.d_distance.to_value(u.km / u.s)\\n804         except u.UnitConversionError:  # No RV\\n805             rv = 0.0\\n806 \\n807         starpm = erfa.pmsafe(\\n808             icrsrep.lon.radian,\\n809             icrsrep.lat.radian,\\n810             icrsvel.d_lon.to_value(u.radian / u.yr),\\n811             icrsvel.d_lat.to_value(u.radian / u.yr),\\n812             plx,\\n813             rv,\\n814             t1.jd1,\\n815             t1.jd2,\\n816             t2.jd1,\\n817             t2.jd2,\\n818         )\\n819 \\n820         if parallax_zero:\\n821             new_distance = None\\n822         else:\\n823             new_distance = Distance(parallax=starpm[4] << u.arcsec)\\n824 \\n825         icrs2 = ICRS(\\n826             ra=u.Quantity(starpm[0], u.radian, copy=False),\\n827             dec=u.Quantity(starpm[1], u.radian, copy=False),\\n828             pm_ra=u.Quantity(starpm[2], u.radian / u.yr, copy=False),\\n829             pm_dec=u.Quantity(starpm[3], u.radian / u.yr, copy=False),\\n830             distance=new_distance,\\n831             radial_velocity=u.Quantity(starpm[5], u.km / u.s, copy=False),\\n832             differential_type=SphericalDifferential,\\n833         )\\n834 \\n835         # Update the obstime of the returned SkyCoord, and need to carry along\\n836         # the frame attributes\\n837         frattrs = {\\n838             attrnm: getattr(self, attrnm) for attrnm in self._extra_frameattr_names\\n839         }\\n840         frattrs[\"obstime\"] = new_obstime\\n841         result = self.__class__(icrs2, **frattrs).transform_to(self.frame)\\n842 \\n843         # Without this the output might not have the right differential type.\\n844         # Not sure if this fixes the problem or just hides it.  See #11932\\n845         result.differential_type = self.differential_type\\n846 \\n847         return result\\n848 \\n849     def _is_name(self, string):\\n850         \"\"\"\\n851         Returns whether a string is one of the aliases for the frame.\\n852         \"\"\"\\n853         return self.frame.name == string or (\\n854             isinstance(self.frame.name, list) and string in self.frame.name\\n855         )\\n856 \\n857     def __getattr__(self, attr):\\n858         \"\"\"\\n859         Overrides getattr to return coordinates that this can be transformed\\n860         to, based on the alias attr in the primary transform graph.\\n861         \"\"\"\\n862         if \"_sky_coord_frame\" in self.__dict__:\\n863             if self._is_name(attr):\\n864                 return self  # Should this be a deepcopy of self?\\n865 \\n866             # Anything in the set of all possible frame_attr_names is handled\\n867             # here. If the attr is relevant for the current frame then delegate\\n868             # to self.frame otherwise get it from self._<attr>.\\n869             if attr in frame_transform_graph.frame_attributes:\\n870                 if attr in self.frame.frame_attributes:\\n871                     return getattr(self.frame, attr)\\n872                 else:\\n873                     return getattr(self, \"_\" + attr, None)\\n874 \\n875             # Some attributes might not fall in the above category but still\\n876             # are available through self._sky_coord_frame.\\n877             if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\\n878                 return getattr(self._sky_coord_frame, attr)\\n879 \\n880             # Try to interpret as a new frame for transforming.\\n881             frame_cls = frame_transform_graph.lookup_name(attr)\\n882             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\\n883                 return self.transform_to(attr)\\n884 \\n885         # Call __getattribute__; this will give correct exception.\\n886         return self.__getattribute__(attr)\\n887 \\n888     def __setattr__(self, attr, val):\\n889         # This is to make anything available through __getattr__ immutable\\n890         if \"_sky_coord_frame\" in self.__dict__:\\n891             if self._is_name(attr):\\n892                 raise AttributeError(f\"\\'{attr}\\' is immutable\")\\n893 \\n894             if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\\n895                 setattr(self._sky_coord_frame, attr, val)\\n896                 return\\n897 \\n898             frame_cls = frame_transform_graph.lookup_name(attr)\\n899             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\\n900                 raise AttributeError(f\"\\'{attr}\\' is immutable\")\\n901 \\n902         if attr in frame_transform_graph.frame_attributes:\\n903             # All possible frame attributes can be set, but only via a private\\n904             # variable.  See __getattr__ above.\\n905             super().__setattr__(\"_\" + attr, val)\\n906             # Validate it\\n907             frame_transform_graph.frame_attributes[attr].__get__(self)\\n908             # And add to set of extra attributes\\n909             self._extra_frameattr_names |= {attr}\\n910 \\n911         else:\\n912             # Otherwise, do the standard Python attribute setting\\n913             super().__setattr__(attr, val)\\n914 \\n915     def __delattr__(self, attr):\\n916         # mirror __setattr__ above\\n917         if \"_sky_coord_frame\" in self.__dict__:\\n918             if self._is_name(attr):\\n919                 raise AttributeError(f\"\\'{attr}\\' is immutable\")\\n920 \\n921             if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\\n922                 delattr(self._sky_coord_frame, attr)\\n923                 return\\n924 \\n925             frame_cls = frame_transform_graph.lookup_name(attr)\\n926             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\\n927                 raise AttributeError(f\"\\'{attr}\\' is immutable\")\\n928 \\n929         if attr in frame_transform_graph.frame_attributes:\\n930             # All possible frame attributes can be deleted, but need to remove\\n931             # the corresponding private variable.  See __getattr__ above.\\n932             super().__delattr__(\"_\" + attr)\\n933             # Also remove it from the set of extra attributes\\n934             self._extra_frameattr_names -= {attr}\\n935 \\n936         else:\\n937             # Otherwise, do the standard Python attribute setting\\n938             super().__delattr__(attr)\\n939 \\n940     def __dir__(self):\\n941         \"\"\"Original dir() behavior, plus frame attributes and transforms.\\n942 \\n943         This dir includes:\\n944         - All attributes of the SkyCoord class\\n945         - Coordinate transforms available by aliases\\n946         - Attribute / methods of the underlying self.frame objects\\n947         \"\"\"\\n948         dir_values = set(super().__dir__())\\n949 \\n950         # determine the aliases that this can be transformed to.\\n951         for name in frame_transform_graph.get_names():\\n952             frame_cls = frame_transform_graph.lookup_name(name)\\n953             if self.frame.is_transformable_to(frame_cls):\\n954                 dir_values.add(name)\\n955 \\n956         # Add public attributes of self.frame\\n957         dir_values.update(\\n958             {attr for attr in dir(self.frame) if not attr.startswith(\"_\")}\\n959         )\\n960 \\n961         # Add all possible frame attributes\\n962         dir_values.update(frame_transform_graph.frame_attributes.keys())\\n963 \\n964         return sorted(dir_values)\\n965 \\n966     def __repr__(self):\\n967         clsnm = self.__class__.__name__\\n968         coonm = self.frame.__class__.__name__\\n969         frameattrs = self.frame._frame_attrs_repr()\\n970         if frameattrs:\\n971             frameattrs = \": \" + frameattrs\\n972 \\n973         data = self.frame._data_repr()\\n974         if data:\\n975             data = \": \" + data\\n976 \\n977         return f\"<{clsnm} ({coonm}{frameattrs}){data}>\"\\n978 \\n979     def to_string(self, style=\"decimal\", **kwargs):\\n980         \"\"\"\\n981         A string representation of the coordinates.\\n982 \\n983         The default styles definitions are::\\n984 \\n985           \\'decimal\\': \\'lat\\': {\\'decimal\\': True, \\'unit\\': \"deg\"}\\n986                      \\'lon\\': {\\'decimal\\': True, \\'unit\\': \"deg\"}\\n987           \\'dms\\': \\'lat\\': {\\'unit\\': \"deg\"}\\n988                  \\'lon\\': {\\'unit\\': \"deg\"}\\n989           \\'hmsdms\\': \\'lat\\': {\\'alwayssign\\': True, \\'pad\\': True, \\'unit\\': \"deg\"}\\n990                     \\'lon\\': {\\'pad\\': True, \\'unit\\': \"hour\"}\\n991 \\n992         See :meth:`~astropy.coordinates.Angle.to_string` for details and\\n993         keyword arguments (the two angles forming the coordinates are are\\n994         both :class:`~astropy.coordinates.Angle` instances). Keyword\\n995         arguments have precedence over the style defaults and are passed\\n996         to :meth:`~astropy.coordinates.Angle.to_string`.\\n997 \\n998         Parameters\\n999         ----------\\n1000         style : {\\'hmsdms\\', \\'dms\\', \\'decimal\\'}\\n1001             The formatting specification to use. These encode the three most\\n1002             common ways to represent coordinates. The default is `decimal`.\\n1003         **kwargs\\n1004             Keyword args passed to :meth:`~astropy.coordinates.Angle.to_string`.\\n1005         \"\"\"\\n1006         sph_coord = self.frame.represent_as(SphericalRepresentation)\\n1007 \\n1008         styles = {\\n1009             \"hmsdms\": {\\n1010                 \"lonargs\": {\"unit\": u.hour, \"pad\": True},\\n1011                 \"latargs\": {\"unit\": u.degree, \"pad\": True, \"alwayssign\": True},\\n1012             },\\n1013             \"dms\": {\"lonargs\": {\"unit\": u.degree}, \"latargs\": {\"unit\": u.degree}},\\n1014             \"decimal\": {\\n1015                 \"lonargs\": {\"unit\": u.degree, \"decimal\": True},\\n1016                 \"latargs\": {\"unit\": u.degree, \"decimal\": True},\\n1017             },\\n1018         }\\n1019 \\n1020         lonargs = {}\\n1021         latargs = {}\\n1022 \\n1023         if style in styles:\\n1024             lonargs.update(styles[style][\"lonargs\"])\\n1025             latargs.update(styles[style][\"latargs\"])\\n1026         else:\\n1027             raise ValueError(f\"Invalid style.  Valid options are: {\\',\\'.join(styles)}\")\\n1028 \\n1029         lonargs.update(kwargs)\\n1030         latargs.update(kwargs)\\n1031 \\n1032         if np.isscalar(sph_coord.lon.value):\\n1033             coord_string = (\\n1034                 f\"{sph_coord.lon.to_string(**lonargs)}\"\\n1035                 f\" {sph_coord.lat.to_string(**latargs)}\"\\n1036             )\\n1037         else:\\n1038             coord_string = []\\n1039             for lonangle, latangle in zip(sph_coord.lon.ravel(), sph_coord.lat.ravel()):\\n1040                 coord_string += [\\n1041                     f\"{lonangle.to_string(**lonargs)} {latangle.to_string(**latargs)}\"\\n1042                 ]\\n1043             if len(sph_coord.shape) > 1:\\n1044                 coord_string = np.array(coord_string).reshape(sph_coord.shape)\\n1045 \\n1046         return coord_string\\n1047 \\n1048     def to_table(self):\\n1049         \"\"\"\\n1050         Convert this |SkyCoord| to a |QTable|.\\n1051 \\n1052         Any attributes that have the same length as the |SkyCoord| will be\\n1053         converted to columns of the |QTable|. All other attributes will be\\n1054         recorded as metadata.\\n1055 \\n1056         Returns\\n1057         -------\\n1058         `~astropy.table.QTable`\\n1059             A |QTable| containing the data of this |SkyCoord|.\\n1060 \\n1061         Examples\\n1062         --------\\n1063         >>> sc = SkyCoord(ra=[40, 70]*u.deg, dec=[0, -20]*u.deg,\\n1064         ...               obstime=Time([2000, 2010], format=\\'jyear\\'))\\n1065         >>> t =  sc.to_table()\\n1066         >>> t\\n1067         <QTable length=2>\\n1068            ra     dec   obstime\\n1069           deg     deg\\n1070         float64 float64   Time\\n1071         ------- ------- -------\\n1072            40.0     0.0  2000.0\\n1073            70.0   -20.0  2010.0\\n1074         >>> t.meta\\n1075         {\\'representation_type\\': \\'spherical\\', \\'frame\\': \\'icrs\\'}\\n1076         \"\"\"\\n1077         self_as_dict = self.info._represent_as_dict()\\n1078         tabledata = {}\\n1079         metadata = {}\\n1080         # Record attributes that have the same length as self as columns in the\\n1081         # table, and the other attributes as table metadata.  This matches\\n1082         # table.serialize._represent_mixin_as_column().\\n1083         for key, value in self_as_dict.items():\\n1084             if getattr(value, \"shape\", ())[:1] == (len(self),):\\n1085                 tabledata[key] = value\\n1086             else:\\n1087                 metadata[key] = value\\n1088         return QTable(tabledata, meta=metadata)\\n1089 \\n1090     def is_equivalent_frame(self, other):\\n1091         \"\"\"\\n1092         Checks if this object\\'s frame is the same as that of the ``other``\\n1093         object.\\n1094 \\n1095         To be the same frame, two objects must be the same frame class and have\\n1096         the same frame attributes. For two |SkyCoord| objects, *all* of the\\n1097         frame attributes have to match, not just those relevant for the object\\'s\\n1098         frame.\\n1099 \\n1100         Parameters\\n1101         ----------\\n1102         other : SkyCoord or BaseCoordinateFrame\\n1103             The other object to check.\\n1104 \\n1105         Returns\\n1106         -------\\n1107         isequiv : bool\\n1108             True if the frames are the same, False if not.\\n1109 \\n1110         Raises\\n1111         ------\\n1112         TypeError\\n1113             If ``other`` isn\\'t a |SkyCoord| or a subclass of\\n1114             `~astropy.coordinates.BaseCoordinateFrame`.\\n1115         \"\"\"\\n1116         if isinstance(other, BaseCoordinateFrame):\\n1117             return self.frame.is_equivalent_frame(other)\\n1118         elif isinstance(other, SkyCoord):\\n1119             if other.frame.name != self.frame.name:\\n1120                 return False\\n1121 \\n1122             for fattrnm in frame_transform_graph.frame_attributes:\\n1123                 if not BaseCoordinateFrame._frameattr_equiv(\\n1124                     getattr(self, fattrnm), getattr(other, fattrnm)\\n1125                 ):\\n1126                     return False\\n1127             return True\\n1128         else:\\n1129             # not a BaseCoordinateFrame nor a SkyCoord object\\n1130             raise TypeError(\\n1131                 \"Tried to do is_equivalent_frame on something that isn\\'t frame-like\"\\n1132             )\\n1133 \\n1134     # High-level convenience methods\\n1135     def separation(self, other):\\n1136         \"\"\"\\n1137         Computes on-sky separation between this coordinate and another.\\n1138 \\n1139         .. note::\\n1140 \\n1141             If the ``other`` coordinate object is in a different frame, it is\\n1142             first transformed to the frame of this object. This can lead to\\n1143             unintuitive behavior if not accounted for. Particularly of note is\\n1144             that ``self.separation(other)`` and ``other.separation(self)`` may\\n1145             not give the same answer in this case.\\n1146 \\n1147         For more on how to use this (and related) functionality, see the\\n1148         examples in :doc:`astropy:/coordinates/matchsep`.\\n1149 \\n1150         Parameters\\n1151         ----------\\n1152         other : `~astropy.coordinates.SkyCoord` or `~astropy.coordinates.BaseCoordinateFrame`\\n1153             The coordinate to get the separation to.\\n1154 \\n1155         Returns\\n1156         -------\\n1157         sep : `~astropy.coordinates.Angle`\\n1158             The on-sky separation between this and the ``other`` coordinate.\\n1159 \\n1160         Notes\\n1161         -----\\n1162         The separation is calculated using the Vincenty formula, which\\n1163         is stable at all locations, including poles and antipodes [1]_.\\n1164 \\n1165         .. [1] https://en.wikipedia.org/wiki/Great-circle_distance\\n1166 \\n1167         \"\"\"\\n1168         from .angles import Angle, angular_separation\\n1169 \\n1170         if not self.is_equivalent_frame(other):\\n1171             try:\\n1172                 kwargs = (\\n1173                     {\"merge_attributes\": False} if isinstance(other, SkyCoord) else {}\\n1174                 )\\n1175                 other = other.transform_to(self, **kwargs)\\n1176             except TypeError:\\n1177                 raise TypeError(\\n1178                     \"Can only get separation to another SkyCoord \"\\n1179                     \"or a coordinate frame with data\"\\n1180                 )\\n1181 \\n1182         lon1 = self.spherical.lon\\n1183         lat1 = self.spherical.lat\\n1184         lon2 = other.spherical.lon\\n1185         lat2 = other.spherical.lat\\n1186 \\n1187         # Get the separation as a Quantity, convert to Angle in degrees\\n1188         sep = angular_separation(lon1, lat1, lon2, lat2)\\n1189         return Angle(sep, unit=u.degree)\\n1190 \\n1191     def separation_3d(self, other):\\n1192         \"\"\"\\n1193         Computes three dimensional separation between this coordinate\\n1194         and another.\\n1195 \\n1196         For more on how to use this (and related) functionality, see the\\n1197         examples in :doc:`astropy:/coordinates/matchsep`.\\n1198 \\n1199         Parameters\\n1200         ----------\\n1201         other : `~astropy.coordinates.SkyCoord` or `~astropy.coordinates.BaseCoordinateFrame`\\n1202             The coordinate to get the separation to.\\n1203 \\n1204         Returns\\n1205         -------\\n1206         sep : `~astropy.coordinates.Distance`\\n1207             The real-space distance between these two coordinates.\\n1208 \\n1209         Raises\\n1210         ------\\n1211         ValueError\\n1212             If this or the other coordinate do not have distances.\\n1213         \"\"\"\\n1214         if not self.is_equivalent_frame(other):\\n1215             try:\\n1216                 kwargs = (\\n1217                     {\"merge_attributes\": False} if isinstance(other, SkyCoord) else {}\\n1218                 )\\n1219                 other = other.transform_to(self, **kwargs)\\n1220             except TypeError:\\n1221                 raise TypeError(\\n1222                     \"Can only get separation to another SkyCoord \"\\n1223                     \"or a coordinate frame with data\"\\n1224                 )\\n1225 \\n1226         if issubclass(self.data.__class__, UnitSphericalRepresentation):\\n1227             raise ValueError(\\n1228                 \"This object does not have a distance; cannot compute 3d separation.\"\\n1229             )\\n1230         if issubclass(other.data.__class__, UnitSphericalRepresentation):\\n1231             raise ValueError(\\n1232                 \"The other object does not have a distance; \"\\n1233                 \"cannot compute 3d separation.\"\\n1234             )\\n1235 \\n1236         c1 = self.cartesian.without_differentials()\\n1237         c2 = other.cartesian.without_differentials()\\n1238         return Distance((c1 - c2).norm())\\n1239 \\n1240     def spherical_offsets_to(self, tocoord):\\n1241         r\"\"\"\\n1242         Computes angular offsets to go *from* this coordinate *to* another.\\n1243 \\n1244         Parameters\\n1245         ----------\\n1246         tocoord : `~astropy.coordinates.BaseCoordinateFrame`\\n1247             The coordinate to find the offset to.\\n1248 \\n1249         Returns\\n1250         -------\\n1251         lon_offset : `~astropy.coordinates.Angle`\\n1252             The angular offset in the longitude direction. The definition of\\n1253             \"longitude\" depends on this coordinate\\'s frame (e.g., RA for\\n1254             equatorial coordinates).\\n1255         lat_offset : `~astropy.coordinates.Angle`\\n1256             The angular offset in the latitude direction. The definition of\\n1257             \"latitude\" depends on this coordinate\\'s frame (e.g., Dec for\\n1258             equatorial coordinates).\\n1259 \\n1260         Raises\\n1261         ------\\n1262         ValueError\\n1263             If the ``tocoord`` is not in the same frame as this one. This is\\n1264             different from the behavior of the `separation`/`separation_3d`\\n1265             methods because the offset components depend critically on the\\n1266             specific choice of frame.\\n1267 \\n1268         Notes\\n1269         -----\\n1270         This uses the sky offset frame machinery, and hence will produce a new\\n1271         sky offset frame if one does not already exist for this object\\'s frame\\n1272         class.\\n1273 \\n1274         See Also\\n1275         --------\\n1276         separation :\\n1277             for the *total* angular offset (not broken out into components).\\n1278         position_angle :\\n1279             for the direction of the offset.\\n1280 \\n1281         \"\"\"\\n1282         if not self.is_equivalent_frame(tocoord):\\n1283             raise ValueError(\\n1284                 \"Tried to use spherical_offsets_to with two non-matching frames!\"\\n1285             )\\n1286 \\n1287         aframe = self.skyoffset_frame()\\n1288         acoord = tocoord.transform_to(aframe)\\n1289 \\n1290         dlon = acoord.spherical.lon.view(Angle)\\n1291         dlat = acoord.spherical.lat.view(Angle)\\n1292         return dlon, dlat\\n1293 \\n1294     def spherical_offsets_by(self, d_lon, d_lat):\\n1295         \"\"\"\\n1296         Computes the coordinate that is a specified pair of angular offsets away\\n1297         from this coordinate.\\n1298 \\n1299         Parameters\\n1300         ----------\\n1301         d_lon : angle-like\\n1302             The angular offset in the longitude direction. The definition of\\n1303             \"longitude\" depends on this coordinate\\'s frame (e.g., RA for\\n1304             equatorial coordinates).\\n1305         d_lat : angle-like\\n1306             The angular offset in the latitude direction. The definition of\\n1307             \"latitude\" depends on this coordinate\\'s frame (e.g., Dec for\\n1308             equatorial coordinates).\\n1309 \\n1310         Returns\\n1311         -------\\n1312         newcoord : `~astropy.coordinates.SkyCoord`\\n1313             The coordinates for the location that corresponds to offsetting by\\n1314             ``d_lat`` in the latitude direction and ``d_lon`` in the longitude\\n1315             direction.\\n1316 \\n1317         Notes\\n1318         -----\\n1319         This internally uses `~astropy.coordinates.SkyOffsetFrame` to do the\\n1320         transformation. For a more complete set of transform offsets, use\\n1321         `~astropy.coordinates.SkyOffsetFrame` or `~astropy.wcs.WCS` manually.\\n1322         This specific method can be reproduced by doing\\n1323         ``SkyCoord(SkyOffsetFrame(d_lon, d_lat, origin=self.frame).transform_to(self))``.\\n1324 \\n1325         See Also\\n1326         --------\\n1327         spherical_offsets_to : compute the angular offsets to another coordinate\\n1328         directional_offset_by : offset a coordinate by an angle in a direction\\n1329         \"\"\"\\n1330         from .builtin_frames.skyoffset import SkyOffsetFrame\\n1331 \\n1332         return self.__class__(\\n1333             SkyOffsetFrame(d_lon, d_lat, origin=self.frame).transform_to(self)\\n1334         )\\n1335 \\n1336     def directional_offset_by(self, position_angle, separation):\\n1337         \"\"\"\\n1338         Computes coordinates at the given offset from this coordinate.\\n1339 \\n1340         Parameters\\n1341         ----------\\n1342         position_angle : `~astropy.coordinates.Angle`\\n1343             position_angle of offset\\n1344         separation : `~astropy.coordinates.Angle`\\n1345             offset angular separation\\n1346 \\n1347         Returns\\n1348         -------\\n1349         newpoints : `~astropy.coordinates.SkyCoord`\\n1350             The coordinates for the location that corresponds to offsetting by\\n1351             the given `position_angle` and `separation`.\\n1352 \\n1353         Notes\\n1354         -----\\n1355         Returned SkyCoord frame retains only the frame attributes that are for\\n1356         the resulting frame type.  (e.g. if the input frame is\\n1357         `~astropy.coordinates.ICRS`, an ``equinox`` value will be retained, but\\n1358         an ``obstime`` will not.)\\n1359 \\n1360         For a more complete set of transform offsets, use `~astropy.wcs.WCS`.\\n1361         `~astropy.coordinates.SkyCoord.skyoffset_frame()` can also be used to\\n1362         create a spherical frame with (lat=0, lon=0) at a reference point,\\n1363         approximating an xy cartesian system for small offsets. This method\\n1364         is distinct in that it is accurate on the sphere.\\n1365 \\n1366         See Also\\n1367         --------\\n1368         position_angle : inverse operation for the ``position_angle`` component\\n1369         separation : inverse operation for the ``separation`` component\\n1370 \\n1371         \"\"\"\\n1372         from .angles import offset_by\\n1373 \\n1374         slat = self.represent_as(UnitSphericalRepresentation).lat\\n1375         slon = self.represent_as(UnitSphericalRepresentation).lon\\n1376 \\n1377         newlon, newlat = offset_by(\\n1378             lon=slon, lat=slat, posang=position_angle, distance=separation\\n1379         )\\n1380 \\n1381         return SkyCoord(newlon, newlat, frame=self.frame)\\n1382 \\n1383     def match_to_catalog_sky(self, catalogcoord, nthneighbor=1):\\n1384         \"\"\"\\n1385         Finds the nearest on-sky matches of this coordinate in a set of\\n1386         catalog coordinates.\\n1387 \\n1388         For more on how to use this (and related) functionality, see the\\n1389         examples in :doc:`astropy:/coordinates/matchsep`.\\n1390 \\n1391         Parameters\\n1392         ----------\\n1393         catalogcoord : `~astropy.coordinates.SkyCoord` or `~astropy.coordinates.BaseCoordinateFrame`\\n1394             The base catalog in which to search for matches. Typically this\\n1395             will be a coordinate object that is an array (i.e.,\\n1396             ``catalogcoord.isscalar == False``)\\n1397         nthneighbor : int, optional\\n1398             Which closest neighbor to search for.  Typically ``1`` is\\n1399             desired here, as that is correct for matching one set of\\n1400             coordinates to another. The next likely use case is ``2``,\\n1401             for matching a coordinate catalog against *itself* (``1``\\n1402             is inappropriate because each point will find itself as the\\n1403             closest match).\\n1404 \\n1405         Returns\\n1406         -------\\n1407         idx : int array\\n1408             Indices into ``catalogcoord`` to get the matched points for\\n1409             each of this object\\'s coordinates. Shape matches this\\n1410             object.\\n1411         sep2d : `~astropy.coordinates.Angle`\\n1412             The on-sky separation between the closest match for each\\n1413             element in this object in ``catalogcoord``. Shape matches\\n1414             this object.\\n1415         dist3d : `~astropy.units.Quantity` [\\'length\\']\\n1416             The 3D distance between the closest match for each element\\n1417             in this object in ``catalogcoord``. Shape matches this\\n1418             object. Unless both this and ``catalogcoord`` have associated\\n1419             distances, this quantity assumes that all sources are at a\\n1420             distance of 1 (dimensionless).\\n1421 \\n1422         Notes\\n1423         -----\\n1424         This method requires `SciPy <https://www.scipy.org/>`_ to be\\n1425         installed or it will fail.\\n1426 \\n1427         See Also\\n1428         --------\\n1429         astropy.coordinates.match_coordinates_sky\\n1430         SkyCoord.match_to_catalog_3d\\n1431         \"\"\"\\n1432         from .matching import match_coordinates_sky\\n1433 \\n1434         if not (\\n1435             isinstance(catalogcoord, (SkyCoord, BaseCoordinateFrame))\\n1436             and catalogcoord.has_data\\n1437         ):\\n1438             raise TypeError(\\n1439                 \"Can only get separation to another SkyCoord or a \"\\n1440                 \"coordinate frame with data\"\\n1441             )\\n1442 \\n1443         res = match_coordinates_sky(\\n1444             self, catalogcoord, nthneighbor=nthneighbor, storekdtree=\"_kdtree_sky\"\\n1445         )\\n1446         return res\\n1447 \\n1448     def match_to_catalog_3d(self, catalogcoord, nthneighbor=1):\\n1449         \"\"\"\\n1450         Finds the nearest 3-dimensional matches of this coordinate to a set\\n1451         of catalog coordinates.\\n1452 \\n1453         This finds the 3-dimensional closest neighbor, which is only different\\n1454         from the on-sky distance if ``distance`` is set in this object or the\\n1455         ``catalogcoord`` object.\\n1456 \\n1457         For more on how to use this (and related) functionality, see the\\n1458         examples in :doc:`astropy:/coordinates/matchsep`.\\n1459 \\n1460         Parameters\\n1461         ----------\\n1462         catalogcoord : `~astropy.coordinates.SkyCoord` or `~astropy.coordinates.BaseCoordinateFrame`\\n1463             The base catalog in which to search for matches. Typically this\\n1464             will be a coordinate object that is an array (i.e.,\\n1465             ``catalogcoord.isscalar == False``)\\n1466         nthneighbor : int, optional\\n1467             Which closest neighbor to search for.  Typically ``1`` is\\n1468             desired here, as that is correct for matching one set of\\n1469             coordinates to another.  The next likely use case is\\n1470             ``2``, for matching a coordinate catalog against *itself*\\n1471             (``1`` is inappropriate because each point will find\\n1472             itself as the closest match).\\n1473 \\n1474         Returns\\n1475         -------\\n1476         idx : int array\\n1477             Indices into ``catalogcoord`` to get the matched points for\\n1478             each of this object\\'s coordinates. Shape matches this\\n1479             object.\\n1480         sep2d : `~astropy.coordinates.Angle`\\n1481             The on-sky separation between the closest match for each\\n1482             element in this object in ``catalogcoord``. Shape matches\\n1483             this object.\\n1484         dist3d : `~astropy.units.Quantity` [\\'length\\']\\n1485             The 3D distance between the closest match for each element\\n1486             in this object in ``catalogcoord``. Shape matches this\\n1487             object.\\n1488 \\n1489         Notes\\n1490         -----\\n1491         This method requires `SciPy <https://www.scipy.org/>`_ to be\\n1492         installed or it will fail.\\n1493 \\n1494         See Also\\n1495         --------\\n1496         astropy.coordinates.match_coordinates_3d\\n1497         SkyCoord.match_to_catalog_sky\\n1498         \"\"\"\\n1499         from .matching import match_coordinates_3d\\n1500 \\n1501         if not (\\n1502             isinstance(catalogcoord, (SkyCoord, BaseCoordinateFrame))\\n1503             and catalogcoord.has_data\\n1504         ):\\n1505             raise TypeError(\\n1506                 \"Can only get separation to another SkyCoord or a \"\\n1507                 \"coordinate frame with data\"\\n1508             )\\n1509 \\n1510         res = match_coordinates_3d(\\n1511             self, catalogcoord, nthneighbor=nthneighbor, storekdtree=\"_kdtree_3d\"\\n1512         )\\n1513 \\n1514         return res\\n1515 \\n1516     def search_around_sky(self, searcharoundcoords, seplimit):\\n1517         \"\"\"\\n1518         Searches for all coordinates in this object around a supplied set of\\n1519         points within a given on-sky separation.\\n1520 \\n1521         This is intended for use on `~astropy.coordinates.SkyCoord` objects\\n1522         with coordinate arrays, rather than a scalar coordinate.  For a scalar\\n1523         coordinate, it is better to use\\n1524         `~astropy.coordinates.SkyCoord.separation`.\\n1525 \\n1526         For more on how to use this (and related) functionality, see the\\n1527         examples in :doc:`astropy:/coordinates/matchsep`.\\n1528 \\n1529         Parameters\\n1530         ----------\\n1531         searcharoundcoords : coordinate-like\\n1532             The coordinates to search around to try to find matching points in\\n1533             this |SkyCoord|. This should be an object with array coordinates,\\n1534             not a scalar coordinate object.\\n1535         seplimit : `~astropy.units.Quantity` [\\'angle\\']\\n1536             The on-sky separation to search within.\\n1537 \\n1538         Returns\\n1539         -------\\n1540         idxsearcharound : int array\\n1541             Indices into ``searcharoundcoords`` that match the\\n1542             corresponding elements of ``idxself``. Shape matches\\n1543             ``idxself``.\\n1544         idxself : int array\\n1545             Indices into ``self`` that match the\\n1546             corresponding elements of ``idxsearcharound``. Shape matches\\n1547             ``idxsearcharound``.\\n1548         sep2d : `~astropy.coordinates.Angle`\\n1549             The on-sky separation between the coordinates. Shape matches\\n1550             ``idxsearcharound`` and ``idxself``.\\n1551         dist3d : `~astropy.units.Quantity` [\\'length\\']\\n1552             The 3D distance between the coordinates. Shape matches\\n1553             ``idxsearcharound`` and ``idxself``.\\n1554 \\n1555         Notes\\n1556         -----\\n1557         This method requires `SciPy <https://www.scipy.org/>`_ to be\\n1558         installed or it will fail.\\n1559 \\n1560         In the current implementation, the return values are always sorted in\\n1561         the same order as the ``searcharoundcoords`` (so ``idxsearcharound`` is\\n1562         in ascending order).  This is considered an implementation detail,\\n1563         though, so it could change in a future release.\\n1564 \\n1565         See Also\\n1566         --------\\n1567         astropy.coordinates.search_around_sky\\n1568         SkyCoord.search_around_3d\\n1569         \"\"\"\\n1570         from .matching import search_around_sky\\n1571 \\n1572         return search_around_sky(\\n1573             searcharoundcoords, self, seplimit, storekdtree=\"_kdtree_sky\"\\n1574         )\\n1575 \\n1576     def search_around_3d(self, searcharoundcoords, distlimit):\\n1577         \"\"\"\\n1578         Searches for all coordinates in this object around a supplied set of\\n1579         points within a given 3D radius.\\n1580 \\n1581         This is intended for use on `~astropy.coordinates.SkyCoord` objects\\n1582         with coordinate arrays, rather than a scalar coordinate.  For a scalar\\n1583         coordinate, it is better to use\\n1584         `~astropy.coordinates.SkyCoord.separation_3d`.\\n1585 \\n1586         For more on how to use this (and related) functionality, see the\\n1587         examples in :doc:`astropy:/coordinates/matchsep`.\\n1588 \\n1589         Parameters\\n1590         ----------\\n1591         searcharoundcoords : `~astropy.coordinates.SkyCoord` or `~astropy.coordinates.BaseCoordinateFrame`\\n1592             The coordinates to search around to try to find matching points in\\n1593             this |SkyCoord|. This should be an object with array coordinates,\\n1594             not a scalar coordinate object.\\n1595         distlimit : `~astropy.units.Quantity` [\\'length\\']\\n1596             The physical radius to search within.\\n1597 \\n1598         Returns\\n1599         -------\\n1600         idxsearcharound : int array\\n1601             Indices into ``searcharoundcoords`` that match the\\n1602             corresponding elements of ``idxself``. Shape matches\\n1603             ``idxself``.\\n1604         idxself : int array\\n1605             Indices into ``self`` that match the\\n1606             corresponding elements of ``idxsearcharound``. Shape matches\\n1607             ``idxsearcharound``.\\n1608         sep2d : `~astropy.coordinates.Angle`\\n1609             The on-sky separation between the coordinates. Shape matches\\n1610             ``idxsearcharound`` and ``idxself``.\\n1611         dist3d : `~astropy.units.Quantity` [\\'length\\']\\n1612             The 3D distance between the coordinates. Shape matches\\n1613             ``idxsearcharound`` and ``idxself``.\\n1614 \\n1615         Notes\\n1616         -----\\n1617         This method requires `SciPy <https://www.scipy.org/>`_ to be\\n1618         installed or it will fail.\\n1619 \\n1620         In the current implementation, the return values are always sorted in\\n1621         the same order as the ``searcharoundcoords`` (so ``idxsearcharound`` is\\n1622         in ascending order).  This is considered an implementation detail,\\n1623         though, so it could change in a future release.\\n1624 \\n1625         See Also\\n1626         --------\\n1627         astropy.coordinates.search_around_3d\\n1628         SkyCoord.search_around_sky\\n1629         \"\"\"\\n1630         from .matching import search_around_3d\\n1631 \\n1632         return search_around_3d(\\n1633             searcharoundcoords, self, distlimit, storekdtree=\"_kdtree_3d\"\\n1634         )\\n1635 \\n1636     def position_angle(self, other):\\n1637         \"\"\"\\n1638         Computes the on-sky position angle (East of North) between this\\n1639         SkyCoord and another.\\n1640 \\n1641         Parameters\\n1642         ----------\\n1643         other : |SkyCoord|\\n1644             The other coordinate to compute the position angle to.  It is\\n1645             treated as the \"head\" of the vector of the position angle.\\n1646 \\n1647         Returns\\n1648         -------\\n1649         pa : `~astropy.coordinates.Angle`\\n1650             The (positive) position angle of the vector pointing from ``self``\\n1651             to ``other``.  If either ``self`` or ``other`` contain arrays, this\\n1652             will be an array following the appropriate `numpy` broadcasting\\n1653             rules.\\n1654 \\n1655         Examples\\n1656         --------\\n1657         >>> c1 = SkyCoord(0*u.deg, 0*u.deg)\\n1658         >>> c2 = SkyCoord(1*u.deg, 0*u.deg)\\n1659         >>> c1.position_angle(c2).degree\\n1660         90.0\\n1661         >>> c3 = SkyCoord(1*u.deg, 1*u.deg)\\n1662         >>> c1.position_angle(c3).degree  # doctest: +FLOAT_CMP\\n1663         44.995636455344844\\n1664         \"\"\"\\n1665         from .angles import position_angle\\n1666 \\n1667         if not self.is_equivalent_frame(other):\\n1668             try:\\n1669                 other = other.transform_to(self, merge_attributes=False)\\n1670             except TypeError:\\n1671                 raise TypeError(\\n1672                     \"Can only get position_angle to another \"\\n1673                     \"SkyCoord or a coordinate frame with data\"\\n1674                 )\\n1675 \\n1676         slat = self.represent_as(UnitSphericalRepresentation).lat\\n1677         slon = self.represent_as(UnitSphericalRepresentation).lon\\n1678         olat = other.represent_as(UnitSphericalRepresentation).lat\\n1679         olon = other.represent_as(UnitSphericalRepresentation).lon\\n1680 \\n1681         return position_angle(slon, slat, olon, olat)\\n1682 \\n1683     def skyoffset_frame(self, rotation=None):\\n1684         \"\"\"\\n1685         Returns the sky offset frame with this SkyCoord at the origin.\\n1686 \\n1687         Parameters\\n1688         ----------\\n1689         rotation : angle-like\\n1690             The final rotation of the frame about the ``origin``. The sign of\\n1691             the rotation is the left-hand rule. That is, an object at a\\n1692             particular position angle in the un-rotated system will be sent to\\n1693             the positive latitude (z) direction in the final frame.\\n1694 \\n1695         Returns\\n1696         -------\\n1697         astrframe : `~astropy.coordinates.SkyOffsetFrame`\\n1698             A sky offset frame of the same type as this |SkyCoord| (e.g., if\\n1699             this object has an ICRS coordinate, the resulting frame is\\n1700             SkyOffsetICRS, with the origin set to this object)\\n1701         \"\"\"\\n1702         from .builtin_frames.skyoffset import SkyOffsetFrame\\n1703 \\n1704         return SkyOffsetFrame(origin=self, rotation=rotation)\\n1705 \\n1706     def get_constellation(self, short_name=False, constellation_list=\"iau\"):\\n1707         \"\"\"\\n1708         Determines the constellation(s) of the coordinates this SkyCoord contains.\\n1709 \\n1710         Parameters\\n1711         ----------\\n1712         short_name : bool\\n1713             If True, the returned names are the IAU-sanctioned abbreviated\\n1714             names.  Otherwise, full names for the constellations are used.\\n1715         constellation_list : str\\n1716             The set of constellations to use.  Currently only ``\\'iau\\'`` is\\n1717             supported, meaning the 88 \"modern\" constellations endorsed by the IAU.\\n1718 \\n1719         Returns\\n1720         -------\\n1721         constellation : str or string array\\n1722             If this is a scalar coordinate, returns the name of the\\n1723             constellation.  If it is an array |SkyCoord|, it returns an array of\\n1724             names.\\n1725 \\n1726         Notes\\n1727         -----\\n1728         To determine which constellation a point on the sky is in, this first\\n1729         precesses to B1875, and then uses the Delporte boundaries of the 88\\n1730         modern constellations, as tabulated by\\n1731         `Roman 1987 <https://cdsarc.cds.unistra.fr/viz-bin/Cat?VI/42>`_.\\n1732 \\n1733         See Also\\n1734         --------\\n1735         astropy.coordinates.get_constellation\\n1736         \"\"\"\\n1737         from .funcs import get_constellation\\n1738 \\n1739         # because of issue #7028, the conversion to a PrecessedGeocentric\\n1740         # system fails in some cases.  Work around is to  drop the velocities.\\n1741         # they are not needed here since only position information is used\\n1742         extra_frameattrs = {nm: getattr(self, nm) for nm in self._extra_frameattr_names}\\n1743         novel = SkyCoord(\\n1744             self.realize_frame(self.data.without_differentials()), **extra_frameattrs\\n1745         )\\n1746         return get_constellation(novel, short_name, constellation_list)\\n1747 \\n1748         # the simpler version below can be used when gh-issue #7028 is resolved\\n1749         # return get_constellation(self, short_name, constellation_list)\\n1750 \\n1751     # WCS pixel to/from sky conversions\\n1752     def to_pixel(self, wcs, origin=0, mode=\"all\"):\\n1753         \"\"\"\\n1754         Convert this coordinate to pixel coordinates using a `~astropy.wcs.WCS`\\n1755         object.\\n1756 \\n1757         Parameters\\n1758         ----------\\n1759         wcs : `~astropy.wcs.WCS`\\n1760             The WCS to use for convert\\n1761         origin : int\\n1762             Whether to return 0 or 1-based pixel coordinates.\\n1763         mode : \\'all\\' or \\'wcs\\'\\n1764             Whether to do the transformation including distortions (``\\'all\\'``) or\\n1765             only including only the core WCS transformation (``\\'wcs\\'``).\\n1766 \\n1767         Returns\\n1768         -------\\n1769         xp, yp : `numpy.ndarray`\\n1770             The pixel coordinates\\n1771 \\n1772         See Also\\n1773         --------\\n1774         astropy.wcs.utils.skycoord_to_pixel : the implementation of this method\\n1775         \"\"\"\\n1776         from astropy.wcs.utils import skycoord_to_pixel\\n1777 \\n1778         return skycoord_to_pixel(self, wcs=wcs, origin=origin, mode=mode)\\n1779 \\n1780     @classmethod\\n1781     def from_pixel(cls, xp, yp, wcs, origin=0, mode=\"all\"):\\n1782         \"\"\"\\n1783         Create a new SkyCoord from pixel coordinates using a World Coordinate System.\\n1784 \\n1785         Parameters\\n1786         ----------\\n1787         xp, yp : float or ndarray\\n1788             The coordinates to convert.\\n1789         wcs : `~astropy.wcs.WCS`\\n1790             The WCS to use for convert\\n1791         origin : int\\n1792             Whether to return 0 or 1-based pixel coordinates.\\n1793         mode : \\'all\\' or \\'wcs\\'\\n1794             Whether to do the transformation including distortions (``\\'all\\'``) or\\n1795             only including only the core WCS transformation (``\\'wcs\\'``).\\n1796 \\n1797         Returns\\n1798         -------\\n1799         coord : `~astropy.coordinates.SkyCoord`\\n1800             A new object with sky coordinates corresponding to the input ``xp``\\n1801             and ``yp``.\\n1802 \\n1803         See Also\\n1804         --------\\n1805         to_pixel : to do the inverse operation\\n1806         astropy.wcs.utils.pixel_to_skycoord : the implementation of this method\\n1807         \"\"\"\\n1808         from astropy.wcs.utils import pixel_to_skycoord\\n1809 \\n1810         return pixel_to_skycoord(xp, yp, wcs=wcs, origin=origin, mode=mode, cls=cls)\\n1811 \\n1812     def contained_by(self, wcs, image=None, **kwargs):\\n1813         \"\"\"\\n1814         Determines if the SkyCoord is contained in the given wcs footprint.\\n1815 \\n1816         Parameters\\n1817         ----------\\n1818         wcs : `~astropy.wcs.WCS`\\n1819             The coordinate to check if it is within the wcs coordinate.\\n1820         image : array\\n1821             Optional.  The image associated with the wcs object that the coordinate\\n1822             is being checked against. If not given the naxis keywords will be used\\n1823             to determine if the coordinate falls within the wcs footprint.\\n1824         **kwargs\\n1825             Additional arguments to pass to `~astropy.coordinates.SkyCoord.to_pixel`\\n1826 \\n1827         Returns\\n1828         -------\\n1829         response : bool\\n1830             True means the WCS footprint contains the coordinate, False means it does not.\\n1831         \"\"\"\\n1832         if image is not None:\\n1833             ymax, xmax = image.shape\\n1834         else:\\n1835             xmax, ymax = wcs._naxis\\n1836 \\n1837         import warnings\\n1838 \\n1839         with warnings.catch_warnings():\\n1840             #  Suppress warnings since they just mean we didn\\'t find the coordinate\\n1841             warnings.simplefilter(\"ignore\")\\n1842             try:\\n1843                 x, y = self.to_pixel(wcs, **kwargs)\\n1844             except Exception:\\n1845                 return False\\n1846 \\n1847         return (x < xmax) & (x > 0) & (y < ymax) & (y > 0)\\n1848 \\n1849     def radial_velocity_correction(\\n1850         self, kind=\"barycentric\", obstime=None, location=None\\n1851     ):\\n1852         \"\"\"\\n1853         Compute the correction required to convert a radial velocity at a given\\n1854         time and place on the Earth\\'s Surface to a barycentric or heliocentric\\n1855         velocity.\\n1856 \\n1857         Parameters\\n1858         ----------\\n1859         kind : str\\n1860             The kind of velocity correction.  Must be \\'barycentric\\' or\\n1861             \\'heliocentric\\'.\\n1862         obstime : `~astropy.time.Time` or None, optional\\n1863             The time at which to compute the correction.  If `None`, the\\n1864             ``obstime`` frame attribute on the |SkyCoord| will be used.\\n1865         location : `~astropy.coordinates.EarthLocation` or None, optional\\n1866             The observer location at which to compute the correction.  If\\n1867             `None`, the  ``location`` frame attribute on the passed-in\\n1868             ``obstime`` will be used, and if that is None, the ``location``\\n1869             frame attribute on the |SkyCoord| will be used.\\n1870 \\n1871         Raises\\n1872         ------\\n1873         ValueError\\n1874             If either ``obstime`` or ``location`` are passed in (not ``None``)\\n1875             when the frame attribute is already set on this |SkyCoord|.\\n1876         TypeError\\n1877             If ``obstime`` or ``location`` aren\\'t provided, either as arguments\\n1878             or as frame attributes.\\n1879 \\n1880         Returns\\n1881         -------\\n1882         vcorr : `~astropy.units.Quantity` [\\'speed\\']\\n1883             The  correction with a positive sign.  I.e., *add* this\\n1884             to an observed radial velocity to get the barycentric (or\\n1885             heliocentric) velocity. If m/s precision or better is needed,\\n1886             see the notes below.\\n1887 \\n1888         Notes\\n1889         -----\\n1890         The barycentric correction is calculated to higher precision than the\\n1891         heliocentric correction and includes additional physics (e.g time dilation).\\n1892         Use barycentric corrections if m/s precision is required.\\n1893 \\n1894         The algorithm here is sufficient to perform corrections at the mm/s level, but\\n1895         care is needed in application. The barycentric correction returned uses the optical\\n1896         approximation v = z * c. Strictly speaking, the barycentric correction is\\n1897         multiplicative and should be applied as::\\n1898 \\n1899           >>> from astropy.time import Time\\n1900           >>> from astropy.coordinates import SkyCoord, EarthLocation\\n1901           >>> from astropy.constants import c\\n1902           >>> t = Time(56370.5, format=\\'mjd\\', scale=\\'utc\\')\\n1903           >>> loc = EarthLocation(\\'149d33m00.5s\\',\\'-30d18m46.385s\\',236.87*u.m)\\n1904           >>> sc = SkyCoord(1*u.deg, 2*u.deg)\\n1905           >>> vcorr = sc.radial_velocity_correction(kind=\\'barycentric\\', obstime=t, location=loc)  # doctest: +REMOTE_DATA\\n1906           >>> rv = rv + vcorr + rv * vcorr / c  # doctest: +SKIP\\n1907 \\n1908         Also note that this method returns the correction velocity in the so-called\\n1909         *optical convention*::\\n1910 \\n1911           >>> vcorr = zb * c  # doctest: +SKIP\\n1912 \\n1913         where ``zb`` is the barycentric correction redshift as defined in section 3\\n1914         of Wright & Eastman (2014). The application formula given above follows from their\\n1915         equation (11) under assumption that the radial velocity ``rv`` has also been defined\\n1916         using the same optical convention. Note, this can be regarded as a matter of\\n1917         velocity definition and does not by itself imply any loss of accuracy, provided\\n1918         sufficient care has been taken during interpretation of the results. If you need\\n1919         the barycentric correction expressed as the full relativistic velocity (e.g., to provide\\n1920         it as the input to another software which performs the application), the\\n1921         following recipe can be used::\\n1922 \\n1923           >>> zb = vcorr / c  # doctest: +REMOTE_DATA\\n1924           >>> zb_plus_one_squared = (zb + 1) ** 2  # doctest: +REMOTE_DATA\\n1925           >>> vcorr_rel = c * (zb_plus_one_squared - 1) / (zb_plus_one_squared + 1)  # doctest: +REMOTE_DATA\\n1926 \\n1927         or alternatively using just equivalencies::\\n1928 \\n1929           >>> vcorr_rel = vcorr.to(u.Hz, u.doppler_optical(1*u.Hz)).to(vcorr.unit, u.doppler_relativistic(1*u.Hz))  # doctest: +REMOTE_DATA\\n1930 \\n1931         See also `~astropy.units.equivalencies.doppler_optical`,\\n1932         `~astropy.units.equivalencies.doppler_radio`, and\\n1933         `~astropy.units.equivalencies.doppler_relativistic` for more information on\\n1934         the velocity conventions.\\n1935 \\n1936         The default is for this method to use the builtin ephemeris for\\n1937         computing the sun and earth location.  Other ephemerides can be chosen\\n1938         by setting the `~astropy.coordinates.solar_system_ephemeris` variable,\\n1939         either directly or via ``with`` statement.  For example, to use the JPL\\n1940         ephemeris, do::\\n1941 \\n1942           >>> from astropy.coordinates import solar_system_ephemeris\\n1943           >>> sc = SkyCoord(1*u.deg, 2*u.deg)\\n1944           >>> with solar_system_ephemeris.set(\\'jpl\\'):  # doctest: +REMOTE_DATA\\n1945           ...     rv += sc.radial_velocity_correction(obstime=t, location=loc)  # doctest: +SKIP\\n1946 \\n1947         \"\"\"\\n1948         # has to be here to prevent circular imports\\n1949         from .solar_system import get_body_barycentric_posvel\\n1950 \\n1951         # location validation\\n1952         timeloc = getattr(obstime, \"location\", None)\\n1953         if location is None:\\n1954             if self.location is not None:\\n1955                 location = self.location\\n1956                 if timeloc is not None:\\n1957                     raise ValueError(\\n1958                         \"`location` cannot be in both the passed-in `obstime` and this\"\\n1959                         \" `SkyCoord` because it is ambiguous which is meant for the\"\\n1960                         \" radial_velocity_correction.\"\\n1961                     )\\n1962             elif timeloc is not None:\\n1963                 location = timeloc\\n1964             else:\\n1965                 raise TypeError(\\n1966                     \"Must provide a `location` to radial_velocity_correction, either as\"\\n1967                     \" a SkyCoord frame attribute, as an attribute on the passed in\"\\n1968                     \" `obstime`, or in the method call.\"\\n1969                 )\\n1970 \\n1971         elif self.location is not None or timeloc is not None:\\n1972             raise ValueError(\\n1973                 \"Cannot compute radial velocity correction if `location` argument is\"\\n1974                 \" passed in and there is also a  `location` attribute on this SkyCoord\"\\n1975                 \" or the passed-in `obstime`.\"\\n1976             )\\n1977 \\n1978         # obstime validation\\n1979         coo_at_rv_obstime = self  # assume we need no space motion for now\\n1980         if obstime is None:\\n1981             obstime = self.obstime\\n1982             if obstime is None:\\n1983                 raise TypeError(\\n1984                     \"Must provide an `obstime` to radial_velocity_correction, either as\"\\n1985                     \" a SkyCoord frame attribute or in the method call.\"\\n1986                 )\\n1987         elif self.obstime is not None and self.frame.data.differentials:\\n1988             # we do need space motion after all\\n1989             coo_at_rv_obstime = self.apply_space_motion(obstime)\\n1990         elif self.obstime is None:\\n1991             # warn the user if the object has differentials set\\n1992             if \"s\" in self.data.differentials:\\n1993                 warnings.warn(\\n1994                     \"SkyCoord has space motion, and therefore the specified \"\\n1995                     \"position of the SkyCoord may not be the same as \"\\n1996                     \"the `obstime` for the radial velocity measurement. \"\\n1997                     \"This may affect the rv correction at the order of km/s\"\\n1998                     \"for very high proper motions sources. If you wish to \"\\n1999                     \"apply space motion of the SkyCoord to correct for this\"\\n2000                     \"the `obstime` attribute of the SkyCoord must be set\",\\n2001                     AstropyUserWarning,\\n2002                 )\\n2003 \\n2004         pos_earth, v_earth = get_body_barycentric_posvel(\"earth\", obstime)\\n2005         if kind == \"barycentric\":\\n2006             v_origin_to_earth = v_earth\\n2007         elif kind == \"heliocentric\":\\n2008             v_sun = get_body_barycentric_posvel(\"sun\", obstime)[1]\\n2009             v_origin_to_earth = v_earth - v_sun\\n2010         else:\\n2011             raise ValueError(\\n2012                 \"`kind` argument to radial_velocity_correction must \"\\n2013                 f\"be \\'barycentric\\' or \\'heliocentric\\', but got \\'{kind}\\'\"\\n2014             )\\n2015 \\n2016         gcrs_p, gcrs_v = location.get_gcrs_posvel(obstime)\\n2017         # transforming to GCRS is not the correct thing to do here, since we don\\'t want to\\n2018         # include aberration (or light deflection)? Instead, only apply parallax if necessary\\n2019         icrs_cart = coo_at_rv_obstime.icrs.cartesian\\n2020         icrs_cart_novel = icrs_cart.without_differentials()\\n2021         if self.data.__class__ is UnitSphericalRepresentation:\\n2022             targcart = icrs_cart_novel\\n2023         else:\\n2024             # skycoord has distances so apply parallax\\n2025             obs_icrs_cart = pos_earth + gcrs_p\\n2026             targcart = icrs_cart_novel - obs_icrs_cart\\n2027             targcart /= targcart.norm()\\n2028 \\n2029         if kind == \"barycentric\":\\n2030             beta_obs = (v_origin_to_earth + gcrs_v) / speed_of_light\\n2031             gamma_obs = 1 / np.sqrt(1 - beta_obs.norm() ** 2)\\n2032             gr = location.gravitational_redshift(obstime)\\n2033             # barycentric redshift according to eq 28 in Wright & Eastmann (2014),\\n2034             # neglecting Shapiro delay and effects of the star\\'s own motion\\n2035             zb = gamma_obs * (1 + beta_obs.dot(targcart)) / (1 + gr / speed_of_light)\\n2036             # try and get terms corresponding to stellar motion.\\n2037             if icrs_cart.differentials:\\n2038                 try:\\n2039                     ro = self.icrs.cartesian\\n2040                     beta_star = ro.differentials[\"s\"].to_cartesian() / speed_of_light\\n2041                     # ICRS unit vector at coordinate epoch\\n2042                     ro = ro.without_differentials()\\n2043                     ro /= ro.norm()\\n2044                     zb *= (1 + beta_star.dot(ro)) / (1 + beta_star.dot(targcart))\\n2045                 except u.UnitConversionError:\\n2046                     warnings.warn(\\n2047                         \"SkyCoord contains some velocity information, but not enough to\"\\n2048                         \" calculate the full space motion of the source, and so this\"\\n2049                         \" has been ignored for the purposes of calculating the radial\"\\n2050                         \" velocity correction. This can lead to errors on the order of\"\\n2051                         \" metres/second.\",\\n2052                         AstropyUserWarning,\\n2053                     )\\n2054 \\n2055             zb = zb - 1\\n2056             return zb * speed_of_light\\n2057         else:\\n2058             # do a simpler correction ignoring time dilation and gravitational redshift\\n2059             # this is adequate since Heliocentric corrections shouldn\\'t be used if\\n2060             # cm/s precision is required.\\n2061             return targcart.dot(v_origin_to_earth + gcrs_v)\\n2062 \\n2063     # Table interactions\\n2064     @classmethod\\n2065     def guess_from_table(cls, table, **coord_kwargs):\\n2066         r\"\"\"\\n2067         A convenience method to create and return a new SkyCoord from the data\\n2068         in an astropy Table.\\n2069 \\n2070         This method matches table columns that start with the case-insensitive\\n2071         names of the components of the requested frames (including\\n2072         differentials), if they are also followed by a non-alphanumeric\\n2073         character. It will also match columns that *end* with the component name\\n2074         if a non-alphanumeric character is *before* it.\\n2075 \\n2076         For example, the first rule means columns with names like\\n2077         ``\\'RA[J2000]\\'`` or ``\\'ra\\'`` will be interpreted as ``ra`` attributes for\\n2078         `~astropy.coordinates.ICRS` frames, but ``\\'RAJ2000\\'`` or ``\\'radius\\'``\\n2079         are *not*. Similarly, the second rule applied to the\\n2080         `~astropy.coordinates.Galactic` frame means that a column named\\n2081         ``\\'gal_l\\'`` will be used as the ``l`` component, but ``gall`` or\\n2082         ``\\'fill\\'`` will not.\\n2083 \\n2084         The definition of alphanumeric here is based on Unicode\\'s definition\\n2085         of alphanumeric, except without ``_`` (which is normally considered\\n2086         alphanumeric).  So for ASCII, this means the non-alphanumeric characters\\n2087         are ``<space>_!\"#$%&\\'()*+,-./\\\\:;<=>?@[]^`{|}~``).\\n2088 \\n2089         Parameters\\n2090         ----------\\n2091         table : `~astropy.table.Table` or subclass\\n2092             The table to load data from.\\n2093         **coord_kwargs\\n2094             Any additional keyword arguments are passed directly to this class\\'s\\n2095             constructor.\\n2096 \\n2097         Returns\\n2098         -------\\n2099         newsc : `~astropy.coordinates.SkyCoord` or subclass\\n2100             The new instance.\\n2101 \\n2102         Raises\\n2103         ------\\n2104         ValueError\\n2105             If more than one match is found in the table for a component,\\n2106             unless the additional matches are also valid frame component names.\\n2107             If a \"coord_kwargs\" is provided for a value also found in the table.\\n2108 \\n2109         \"\"\"\\n2110         _frame_cls, _frame_kwargs = _get_frame_without_data([], coord_kwargs)\\n2111         frame = _frame_cls(**_frame_kwargs)\\n2112         coord_kwargs[\"frame\"] = coord_kwargs.get(\"frame\", frame)\\n2113 \\n2114         representation_component_names = set(\\n2115             frame.get_representation_component_names()\\n2116         ).union(set(frame.get_representation_component_names(\"s\")))\\n2117 \\n2118         comp_kwargs = {}\\n2119         for comp_name in representation_component_names:\\n2120             # this matches things like \\'ra[...]\\'\\' but *not* \\'rad\\'.\\n2121             # note that the \"_\" must be in there explicitly, because\\n2122             # \"alphanumeric\" usually includes underscores.\\n2123             starts_with_comp = comp_name + r\"(\\\\W|\\\\b|_)\"\\n2124             # this part matches stuff like \\'center_ra\\', but *not*\\n2125             # \\'aura\\'\\n2126             ends_with_comp = r\".*(\\\\W|\\\\b|_)\" + comp_name + r\"\\\\b\"\\n2127             # the final regex ORs together the two patterns\\n2128             rex = re.compile(\\n2129                 rf\"({starts_with_comp})|({ends_with_comp})\", re.IGNORECASE | re.UNICODE\\n2130             )\\n2131 \\n2132             # find all matches\\n2133             matches = {col_name for col_name in table.colnames if rex.match(col_name)}\\n2134 \\n2135             # now need to select among matches, also making sure we don\\'t have\\n2136             # an exact match with another component\\n2137             if len(matches) == 0:  # no matches\\n2138                 continue\\n2139             elif len(matches) == 1:  # only one match\\n2140                 col_name = matches.pop()\\n2141             else:  # more than 1 match\\n2142                 # try to sieve out other components\\n2143                 matches -= representation_component_names - {comp_name}\\n2144                 # if there\\'s only one remaining match, it worked.\\n2145                 if len(matches) == 1:\\n2146                     col_name = matches.pop()\\n2147                 else:\\n2148                     raise ValueError(\\n2149                         f\\'Found at least two matches for component \"{comp_name}\":\\'\\n2150                         f\\' \"{matches}\". Cannot guess coordinates from a table with this\\'\\n2151                         \" ambiguity.\"\\n2152                     )\\n2153 \\n2154             comp_kwargs[comp_name] = table[col_name]\\n2155 \\n2156         for k, v in comp_kwargs.items():\\n2157             if k in coord_kwargs:\\n2158                 raise ValueError(\\n2159                     f\\'Found column \"{v.name}\" in table, but it was already provided as\\'\\n2160                     \\' \"{k}\" keyword to guess_from_table function.\\'\\n2161                 )\\n2162             else:\\n2163                 coord_kwargs[k] = v\\n2164 \\n2165         return cls(**coord_kwargs)\\n2166 \\n2167     # Name resolve\\n2168     @classmethod\\n2169     def from_name(cls, name, frame=\"icrs\", parse=False, cache=True):\\n2170         \"\"\"\\n2171         Given a name, query the CDS name resolver to attempt to retrieve\\n2172         coordinate information for that object. The search database, sesame\\n2173         url, and  query timeout can be set through configuration items in\\n2174         ``astropy.coordinates.name_resolve`` -- see docstring for\\n2175         `~astropy.coordinates.get_icrs_coordinates` for more\\n2176         information.\\n2177 \\n2178         Parameters\\n2179         ----------\\n2180         name : str\\n2181             The name of the object to get coordinates for, e.g. ``\\'M42\\'``.\\n2182         frame : str or `BaseCoordinateFrame` class or instance\\n2183             The frame to transform the object to.\\n2184         parse : bool\\n2185             Whether to attempt extracting the coordinates from the name by\\n2186             parsing with a regex. For objects catalog names that have\\n2187             J-coordinates embedded in their names, e.g.,\\n2188             \\'CRTS SSS100805 J194428-420209\\', this may be much faster than a\\n2189             Sesame query for the same object name. The coordinates extracted\\n2190             in this way may differ from the database coordinates by a few\\n2191             deci-arcseconds, so only use this option if you do not need\\n2192             sub-arcsecond accuracy for coordinates.\\n2193         cache : bool, optional\\n2194             Determines whether to cache the results or not. To update or\\n2195             overwrite an existing value, pass ``cache=\\'update\\'``.\\n2196 \\n2197         Returns\\n2198         -------\\n2199         coord : SkyCoord\\n2200             Instance of the SkyCoord class.\\n2201         \"\"\"\\n2202         from .name_resolve import get_icrs_coordinates\\n2203 \\n2204         icrs_coord = get_icrs_coordinates(name, parse, cache=cache)\\n2205         icrs_sky_coord = cls(icrs_coord)\\n2206         if frame in (\"icrs\", icrs_coord.__class__):\\n2207             return icrs_sky_coord\\n2208         else:\\n2209             return icrs_sky_coord.transform_to(frame)\\n2210 '}, {'name': 'skycoord', 'full_name': 'astropy.coordinates.sky_coordinate.SkyCoordInfo.new_like.skycoord', 'documentation': None, 'implementation': 'for skycoord in skycoords[1:]: try: out[0] = skycoord[0] except Exception as err: raise ValueError(\"Input skycoords are inconsistent.\") from err'}, {'name': 'SkyCoord', 'full_name': 'astropy.coordinates.sky_coordinate.SkyCoord', 'documentation': None, 'implementation': 'class SkyCoord'}], 'transform_to': [{'name': 'transform_to', 'full_name': 'astropy.coordinates.baseframe.BaseCoordinateFrame.transform_to', 'documentation': \"Transform this object's coordinate data to a new frame.\\n\\nParameters\\n----------\\nnew_frame : coordinate-like\\n    The frame to transform this coordinate frame into.\\n\\nReturns\\n-------\\ntransframe : coordinate-like\\n    A new object with the coordinate data represented in the\\n    ``newframe`` system.\\n\\nRaises\\n------\\nValueError\\n    If there is no possible transformation route.\", 'implementation': '1222     def transform_to(self, new_frame):\\n1223         \"\"\"\\n1224         Transform this object\\'s coordinate data to a new frame.\\n1225 \\n1226         Parameters\\n1227         ----------\\n1228         new_frame : coordinate-like\\n1229             The frame to transform this coordinate frame into.\\n1230 \\n1231         Returns\\n1232         -------\\n1233         transframe : coordinate-like\\n1234             A new object with the coordinate data represented in the\\n1235             ``newframe`` system.\\n1236 \\n1237         Raises\\n1238         ------\\n1239         ValueError\\n1240             If there is no possible transformation route.\\n1241         \"\"\"\\n1242         from .errors import ConvertError\\n1243 \\n1244         if self._data is None:\\n1245             raise ValueError(\"Cannot transform a frame with no data\")\\n1246 \\n1247         if (\\n1248             getattr(self.data, \"differentials\", None)\\n1249             and hasattr(self, \"obstime\")\\n1250             and hasattr(new_frame, \"obstime\")\\n1251             and np.any(self.obstime != new_frame.obstime)\\n1252         ):\\n1253             raise NotImplementedError(\\n1254                 \"You cannot transform a frame that has velocities to another frame at a\"\\n1255                 \" different obstime. If you think this should (or should not) be\"\\n1256                 \" possible, please comment at\"\\n1257                 \" https://github.com/astropy/astropy/issues/6280\"\\n1258             )\\n1259 \\n1260         if hasattr(new_frame, \"_sky_coord_frame\"):\\n1261             # Input new_frame is not a frame instance or class and is most\\n1262             # likely a SkyCoord object.\\n1263             new_frame = new_frame._sky_coord_frame\\n1264 \\n1265         trans = frame_transform_graph.get_transform(self.__class__, new_frame.__class__)\\n1266         if trans is None:\\n1267             if new_frame is self.__class__:\\n1268                 # no special transform needed, but should update frame info\\n1269                 return new_frame.realize_frame(self.data)\\n1270             msg = \"Cannot transform from {0} to {1}\"\\n1271             raise ConvertError(msg.format(self.__class__, new_frame.__class__))\\n1272         return trans(self, new_frame)\\n1273 '}, {'name': 'transform_to', 'full_name': 'astropy.coordinates.sky_coordinate.SkyCoord.transform_to', 'documentation': \"Transform this coordinate to a new frame.\\n\\nThe precise frame transformed to depends on ``merge_attributes``.\\nIf `False`, the destination frame is used exactly as passed in.\\nBut this is often not quite what one wants.  E.g., suppose one wants to\\ntransform an ICRS coordinate that has an obstime attribute to FK4; in\\nthis case, one likely would want to use this information. Thus, the\\ndefault for ``merge_attributes`` is `True`, in which the precedence is\\nas follows: (1) explicitly set (i.e., non-default) values in the\\ndestination frame; (2) explicitly set values in the source; (3) default\\nvalue in the destination frame.\\n\\nNote that in either case, any explicitly set attributes on the source\\n|SkyCoord| that are not part of the destination frame's definition are\\nkept (stored on the resulting |SkyCoord|), and thus one can round-trip\\n(e.g., from FK4 to ICRS to FK4 without losing obstime).\\n\\nParameters\\n----------\\nframe : str, `~astropy.coordinates.BaseCoordinateFrame` class or instance, or |SkyCoord| instance\\n    The frame to transform this coordinate into.  If a |SkyCoord|, the\\n    underlying frame is extracted, and all other information ignored.\\nmerge_attributes : bool, optional\\n    Whether the default attributes in the destination frame are allowed\\n    to be overridden by explicitly set attributes in the source\\n    (see note above; default: `True`).\\n\\nReturns\\n-------\\ncoord : |SkyCoord|\\n    A new object with this coordinate represented in the `frame` frame.\\n\\nRaises\\n------\\nValueError\\n    If there is no possible transformation route.\", 'implementation': '605     def transform_to(self, frame, merge_attributes=True):\\n606         \"\"\"Transform this coordinate to a new frame.\\n607 \\n608         The precise frame transformed to depends on ``merge_attributes``.\\n609         If `False`, the destination frame is used exactly as passed in.\\n610         But this is often not quite what one wants.  E.g., suppose one wants to\\n611         transform an ICRS coordinate that has an obstime attribute to FK4; in\\n612         this case, one likely would want to use this information. Thus, the\\n613         default for ``merge_attributes`` is `True`, in which the precedence is\\n614         as follows: (1) explicitly set (i.e., non-default) values in the\\n615         destination frame; (2) explicitly set values in the source; (3) default\\n616         value in the destination frame.\\n617 \\n618         Note that in either case, any explicitly set attributes on the source\\n619         |SkyCoord| that are not part of the destination frame\\'s definition are\\n620         kept (stored on the resulting |SkyCoord|), and thus one can round-trip\\n621         (e.g., from FK4 to ICRS to FK4 without losing obstime).\\n622 \\n623         Parameters\\n624         ----------\\n625         frame : str, `~astropy.coordinates.BaseCoordinateFrame` class or instance, or |SkyCoord| instance\\n626             The frame to transform this coordinate into.  If a |SkyCoord|, the\\n627             underlying frame is extracted, and all other information ignored.\\n628         merge_attributes : bool, optional\\n629             Whether the default attributes in the destination frame are allowed\\n630             to be overridden by explicitly set attributes in the source\\n631             (see note above; default: `True`).\\n632 \\n633         Returns\\n634         -------\\n635         coord : |SkyCoord|\\n636             A new object with this coordinate represented in the `frame` frame.\\n637 \\n638         Raises\\n639         ------\\n640         ValueError\\n641             If there is no possible transformation route.\\n642 \\n643         \"\"\"\\n644         from astropy.coordinates.errors import ConvertError\\n645 \\n646         frame_kwargs = {}\\n647 \\n648         # Frame name (string) or frame class?  Coerce into an instance.\\n649         try:\\n650             frame = _get_frame_class(frame)()\\n651         except Exception:\\n652             pass\\n653 \\n654         if isinstance(frame, SkyCoord):\\n655             frame = frame.frame  # Change to underlying coord frame instance\\n656 \\n657         if isinstance(frame, BaseCoordinateFrame):\\n658             new_frame_cls = frame.__class__\\n659             # Get frame attributes, allowing defaults to be overridden by\\n660             # explicitly set attributes of the source if ``merge_attributes``.\\n661             for attr in frame_transform_graph.frame_attributes:\\n662                 self_val = getattr(self, attr, None)\\n663                 frame_val = getattr(frame, attr, None)\\n664                 if frame_val is not None and not (\\n665                     merge_attributes and frame.is_frame_attr_default(attr)\\n666                 ):\\n667                     frame_kwargs[attr] = frame_val\\n668                 elif self_val is not None and not self.is_frame_attr_default(attr):\\n669                     frame_kwargs[attr] = self_val\\n670                 elif frame_val is not None:\\n671                     frame_kwargs[attr] = frame_val\\n672         else:\\n673             raise ValueError(\\n674                 \"Transform `frame` must be a frame name, class, or instance\"\\n675             )\\n676 \\n677         # Get the composite transform to the new frame\\n678         trans = frame_transform_graph.get_transform(self.frame.__class__, new_frame_cls)\\n679         if trans is None:\\n680             raise ConvertError(\\n681                 f\"Cannot transform from {self.frame.__class__} to {new_frame_cls}\"\\n682             )\\n683 \\n684         # Make a generic frame which will accept all the frame kwargs that\\n685         # are provided and allow for transforming through intermediate frames\\n686         # which may require one or more of those kwargs.\\n687         generic_frame = GenericFrame(frame_kwargs)\\n688 \\n689         # Do the transformation, returning a coordinate frame of the desired\\n690         # final type (not generic).\\n691         new_coord = trans(self.frame, generic_frame)\\n692 \\n693         # Finally make the new SkyCoord object from the `new_coord` and\\n694         # remaining frame_kwargs that are not frame_attributes in `new_coord`.\\n695         for attr in set(new_coord.frame_attributes) & set(frame_kwargs.keys()):\\n696             frame_kwargs.pop(attr)\\n697 \\n698         # Always remove the origin frame attribute, as that attribute only makes\\n699         # sense with a SkyOffsetFrame (in which case it will be stored on the frame).\\n700         # See gh-11277.\\n701         # TODO: Should it be a property of the frame attribute that it can\\n702         # or cannot be stored on a SkyCoord?\\n703         frame_kwargs.pop(\"origin\", None)\\n704 \\n705         return self.__class__(new_coord, **frame_kwargs)\\n706 '}, {'name': 'transform_to', 'full_name': 'astropy.coordinates.baseframe.BaseCoordinateFrame.transform_to', 'documentation': None, 'implementation': 'def transform_to'}, {'name': 'transform_to', 'full_name': 'astropy.coordinates.sky_coordinate.SkyCoord.transform_to', 'documentation': None, 'implementation': 'def transform_to'}], 'represent_as': [{'name': 'represent_as', 'full_name': 'astropy.coordinates.baseframe.BaseCoordinateFrame.represent_as', 'documentation': \"Generate and return a new representation of this frame's `data`\\nas a Representation object.\\n\\nNote: In order to make an in-place change of the representation\\nof a Frame or SkyCoord object, set the ``representation``\\nattribute of that object to the desired new representation, or\\nuse the ``set_representation_cls`` method to also set the differential.\\n\\nParameters\\n----------\\nbase : subclass of BaseRepresentation or string\\n    The type of representation to generate.  Must be a *class*\\n    (not an instance), or the string name of the representation\\n    class.\\ns : subclass of `~astropy.coordinates.BaseDifferential`, str, optional\\n    Class in which any velocities should be represented. Must be\\n    a *class* (not an instance), or the string name of the\\n    differential class.  If equal to 'base' (default), inferred from\\n    the base class.  If `None`, all velocity information is dropped.\\nin_frame_units : bool, keyword-only\\n    Force the representation units to match the specified units\\n    particular to this frame\\n\\nReturns\\n-------\\nnewrep : BaseRepresentation-derived object\\n    A new representation object of this frame's `data`.\\n\\nRaises\\n------\\nAttributeError\\n    If this object had no `data`\\n\\nExamples\\n--------\\n>>> from astropy import units as u\\n>>> from astropy.coordinates import SkyCoord, CartesianRepresentation\\n>>> coord = SkyCoord(0*u.deg, 0*u.deg)\\n>>> coord.represent_as(CartesianRepresentation)  # doctest: +FLOAT_CMP\\n<CartesianRepresentation (x, y, z) [dimensionless]\\n        (1., 0., 0.)>\\n\\n>>> coord.representation_type = CartesianRepresentation\\n>>> coord  # doctest: +FLOAT_CMP\\n<SkyCoord (ICRS): (x, y, z) [dimensionless]\\n    (1., 0., 0.)>\", 'implementation': '1024     def represent_as(self, base, s=\"base\", in_frame_units=False):\\n1025         \"\"\"\\n1026         Generate and return a new representation of this frame\\'s `data`\\n1027         as a Representation object.\\n1028 \\n1029         Note: In order to make an in-place change of the representation\\n1030         of a Frame or SkyCoord object, set the ``representation``\\n1031         attribute of that object to the desired new representation, or\\n1032         use the ``set_representation_cls`` method to also set the differential.\\n1033 \\n1034         Parameters\\n1035         ----------\\n1036         base : subclass of BaseRepresentation or string\\n1037             The type of representation to generate.  Must be a *class*\\n1038             (not an instance), or the string name of the representation\\n1039             class.\\n1040         s : subclass of `~astropy.coordinates.BaseDifferential`, str, optional\\n1041             Class in which any velocities should be represented. Must be\\n1042             a *class* (not an instance), or the string name of the\\n1043             differential class.  If equal to \\'base\\' (default), inferred from\\n1044             the base class.  If `None`, all velocity information is dropped.\\n1045         in_frame_units : bool, keyword-only\\n1046             Force the representation units to match the specified units\\n1047             particular to this frame\\n1048 \\n1049         Returns\\n1050         -------\\n1051         newrep : BaseRepresentation-derived object\\n1052             A new representation object of this frame\\'s `data`.\\n1053 \\n1054         Raises\\n1055         ------\\n1056         AttributeError\\n1057             If this object had no `data`\\n1058 \\n1059         Examples\\n1060         --------\\n1061         >>> from astropy import units as u\\n1062         >>> from astropy.coordinates import SkyCoord, CartesianRepresentation\\n1063         >>> coord = SkyCoord(0*u.deg, 0*u.deg)\\n1064         >>> coord.represent_as(CartesianRepresentation)  # doctest: +FLOAT_CMP\\n1065         <CartesianRepresentation (x, y, z) [dimensionless]\\n1066                 (1., 0., 0.)>\\n1067 \\n1068         >>> coord.representation_type = CartesianRepresentation\\n1069         >>> coord  # doctest: +FLOAT_CMP\\n1070         <SkyCoord (ICRS): (x, y, z) [dimensionless]\\n1071             (1., 0., 0.)>\\n1072         \"\"\"\\n1073         # For backwards compatibility (because in_frame_units used to be the\\n1074         # 2nd argument), we check to see if `new_differential` is a boolean. If\\n1075         # it is, we ignore the value of `new_differential` and warn about the\\n1076         # position change\\n1077         if isinstance(s, bool):\\n1078             warnings.warn(\\n1079                 \"The argument position for `in_frame_units` in `represent_as` has\"\\n1080                 \" changed. Use as a keyword argument if needed.\",\\n1081                 AstropyWarning,\\n1082             )\\n1083             in_frame_units = s\\n1084             s = \"base\"\\n1085 \\n1086         # In the future, we may want to support more differentials, in which\\n1087         # case one probably needs to define **kwargs above and use it here.\\n1088         # But for now, we only care about the velocity.\\n1089         repr_classes = _get_repr_classes(base=base, s=s)\\n1090         representation_cls = repr_classes[\"base\"]\\n1091         # We only keep velocity information\\n1092         if \"s\" in self.data.differentials:\\n1093             # For the default \\'base\\' option in which _get_repr_classes has\\n1094             # given us a best guess based on the representation class, we only\\n1095             # use it if the class we had already is incompatible.\\n1096             if s == \"base\" and (\\n1097                 self.data.differentials[\"s\"].__class__\\n1098                 in representation_cls._compatible_differentials\\n1099             ):\\n1100                 differential_cls = self.data.differentials[\"s\"].__class__\\n1101             else:\\n1102                 differential_cls = repr_classes[\"s\"]\\n1103         elif s is None or s == \"base\":\\n1104             differential_cls = None\\n1105         else:\\n1106             raise TypeError(\\n1107                 \"Frame data has no associated differentials (i.e. the frame has no\"\\n1108                 \" velocity data) - represent_as() only accepts a new representation.\"\\n1109             )\\n1110 \\n1111         if differential_cls:\\n1112             cache_key = (\\n1113                 representation_cls.__name__,\\n1114                 differential_cls.__name__,\\n1115                 in_frame_units,\\n1116             )\\n1117         else:\\n1118             cache_key = (representation_cls.__name__, in_frame_units)\\n1119 \\n1120         cached_repr = self.cache[\"representation\"].get(cache_key)\\n1121         if not cached_repr:\\n1122             if differential_cls:\\n1123                 # Sanity check to ensure we do not just drop radial\\n1124                 # velocity.  TODO: should Representation.represent_as\\n1125                 # allow this transformation in the first place?\\n1126                 if (\\n1127                     isinstance(self.data, r.UnitSphericalRepresentation)\\n1128                     and issubclass(representation_cls, r.CartesianRepresentation)\\n1129                     and not isinstance(\\n1130                         self.data.differentials[\"s\"],\\n1131                         (\\n1132                             r.UnitSphericalDifferential,\\n1133                             r.UnitSphericalCosLatDifferential,\\n1134                             r.RadialDifferential,\\n1135                         ),\\n1136                     )\\n1137                 ):\\n1138                     raise u.UnitConversionError(\\n1139                         \"need a distance to retrieve a cartesian representation \"\\n1140                         \"when both radial velocity and proper motion are present, \"\\n1141                         \"since otherwise the units cannot match.\"\\n1142                     )\\n1143 \\n1144                 # TODO NOTE: only supports a single differential\\n1145                 data = self.data.represent_as(representation_cls, differential_cls)\\n1146                 diff = data.differentials[\"s\"]  # TODO: assumes velocity\\n1147             else:\\n1148                 data = self.data.represent_as(representation_cls)\\n1149 \\n1150             # If the new representation is known to this frame and has a defined\\n1151             # set of names and units, then use that.\\n1152             new_attrs = self.representation_info.get(representation_cls)\\n1153             if new_attrs and in_frame_units:\\n1154                 datakwargs = {comp: getattr(data, comp) for comp in data.components}\\n1155                 for comp, new_attr_unit in zip(data.components, new_attrs[\"units\"]):\\n1156                     if new_attr_unit:\\n1157                         datakwargs[comp] = datakwargs[comp].to(new_attr_unit)\\n1158                 data = data.__class__(copy=False, **datakwargs)\\n1159 \\n1160             if differential_cls:\\n1161                 # the original differential\\n1162                 data_diff = self.data.differentials[\"s\"]\\n1163 \\n1164                 # If the new differential is known to this frame and has a\\n1165                 # defined set of names and units, then use that.\\n1166                 new_attrs = self.representation_info.get(differential_cls)\\n1167                 if new_attrs and in_frame_units:\\n1168                     diffkwargs = {comp: getattr(diff, comp) for comp in diff.components}\\n1169                     for comp, new_attr_unit in zip(diff.components, new_attrs[\"units\"]):\\n1170                         # Some special-casing to treat a situation where the\\n1171                         # input data has a UnitSphericalDifferential or a\\n1172                         # RadialDifferential. It is re-represented to the\\n1173                         # frame\\'s differential class (which might be, e.g., a\\n1174                         # dimensional Differential), so we don\\'t want to try to\\n1175                         # convert the empty component units\\n1176                         if (\\n1177                             isinstance(\\n1178                                 data_diff,\\n1179                                 (\\n1180                                     r.UnitSphericalDifferential,\\n1181                                     r.UnitSphericalCosLatDifferential,\\n1182                                 ),\\n1183                             )\\n1184                             and comp not in data_diff.__class__.attr_classes\\n1185                         ):\\n1186                             continue\\n1187 \\n1188                         elif (\\n1189                             isinstance(data_diff, r.RadialDifferential)\\n1190                             and comp not in data_diff.__class__.attr_classes\\n1191                         ):\\n1192                             continue\\n1193 \\n1194                         # Try to convert to requested units. Since that might\\n1195                         # not be possible (e.g., for a coordinate with proper\\n1196                         # motion but without distance, one cannot convert to a\\n1197                         # cartesian differential in km/s), we allow the unit\\n1198                         # conversion to fail.  See gh-7028 for discussion.\\n1199                         if new_attr_unit and hasattr(diff, comp):\\n1200                             try:\\n1201                                 diffkwargs[comp] = diffkwargs[comp].to(new_attr_unit)\\n1202                             except Exception:\\n1203                                 pass\\n1204 \\n1205                     diff = diff.__class__(copy=False, **diffkwargs)\\n1206 \\n1207                     # Here we have to bypass using with_differentials() because\\n1208                     # it has a validation check. But because\\n1209                     # .representation_type and .differential_type don\\'t point to\\n1210                     # the original classes, if the input differential is a\\n1211                     # RadialDifferential, it usually gets turned into a\\n1212                     # SphericalCosLatDifferential (or whatever the default is)\\n1213                     # with strange units for the d_lon and d_lat attributes.\\n1214                     # This then causes the dictionary key check to fail (i.e.\\n1215                     # comparison against `diff._get_deriv_key()`)\\n1216                     data._differentials.update({\"s\": diff})\\n1217 \\n1218             self.cache[\"representation\"][cache_key] = data\\n1219 \\n1220         return self.cache[\"representation\"][cache_key]\\n1221 '}, {'name': 'represent_as', 'full_name': 'astropy.coordinates.builtin_frames.hadec.HADec.represent_as', 'documentation': 'Ensure the wrap angle for any spherical\\nrepresentations.', 'implementation': '119     def represent_as(self, base, s=\"base\", in_frame_units=False):\\n120         \"\"\"\\n121         Ensure the wrap angle for any spherical\\n122         representations.\\n123         \"\"\"\\n124         data = super().represent_as(base, s, in_frame_units=in_frame_units)\\n125         self._set_data_lon_wrap_angle(data)\\n126         return data\\n127 '}, {'name': 'represent_as', 'full_name': 'astropy.coordinates.baseframe.BaseCoordinateFrame.represent_as', 'documentation': None, 'implementation': 'def represent_as'}, {'name': 'represent_as', 'full_name': 'astropy.coordinates.builtin_frames.hadec.HADec.represent_as', 'documentation': None, 'implementation': 'def represent_as'}], 'differentials': [{'name': 'differentials', 'full_name': 'astropy.coordinates.representation.base.BaseRepresentation.differentials', 'documentation': \"A dictionary of differential class instances.\\n\\nThe keys of this dictionary must be a string representation of the SI\\nunit with which the differential (derivative) is taken. For example, for\\na velocity differential on a positional representation, the key would be\\n``'s'`` for seconds, indicating that the derivative is a time\\nderivative.\", 'implementation': '760     def differentials(self):\\n761         \"\"\"A dictionary of differential class instances.\\n762 \\n763         The keys of this dictionary must be a string representation of the SI\\n764         unit with which the differential (derivative) is taken. For example, for\\n765         a velocity differential on a positional representation, the key would be\\n766         ``\\'s\\'`` for seconds, indicating that the derivative is a time\\n767         derivative.\\n768         \"\"\"\\n769         return self._differentials\\n770 '}, {'name': 'differentials', 'full_name': None, 'documentation': None, 'implementation': 'param **differentials'}, {'name': 'differentials', 'full_name': 'astropy.coordinates.spectral_coordinate.update_differentials_to_match.differentials', 'documentation': None, 'implementation': 'differentials = velocity_reference_icrs.data.represent_as( CartesianRepresentation, CartesianDifferential ).differentials'}], 'd_distance': [{'name': 'd_distance', 'full_name': None, 'documentation': None, 'implementation': 'param d_distance=None'}, {'name': 'd_distance', 'full_name': None, 'documentation': None, 'implementation': 'param d_distance=None'}], 'd_lon': [{'name': 'd_lon', 'full_name': None, 'documentation': None, 'implementation': 'param d_lon'}, {'name': 'd_lon', 'full_name': None, 'documentation': None, 'implementation': 'param d_lon'}], 'd_lat': [{'name': 'd_lat', 'full_name': None, 'documentation': None, 'implementation': 'param d_lat'}, {'name': 'd_lat', 'full_name': None, 'documentation': None, 'implementation': 'param d_lat=None'}]}\nThought:The `code_search` tool has returned a large amount of information related to the classes and methods involved in transforming coordinates from ICRS to Galactocentric and then to a spherical representation. The relevant classes and methods include `ICRS`, `Galactocentric`, `SphericalDifferential`, `SkyCoord`, `transform_to`, `represent_as`, `differentials`, `d_distance`, `d_lon`, and `d_lat`.\n\nFrom the `SkyCoord` class, we can see that the `transform_to` method is used to transform coordinates to a different frame, which is relevant for converting from ICRS to Galactocentric. The `represent_as` method is used to represent the data in a different representation, such as spherical, which is relevant for the second part of the transformation.\n\nThe `SphericalDifferential` class is relevant for working with differentials in spherical coordinates, which includes `d_lon`, `d_lat`, and `d_distance`. These are the components that the user is interested in converting to km/s.\n\nThe `differentials` attribute of the `BaseRepresentation` class holds the differentials (derivatives) associated with the representation, which is relevant for accessing the velocity components.\n\nThe user is specifically asking about converting the angular velocities `d_lon` and `d_lat` to km/s, given that they have already converted `d_distance` using the `to` method. The error they are encountering suggests that there is a unit conversion issue when trying to directly convert `d_lon` and `d_lat` to km/s.\n\nTo help the user, we need to find a method or a combination of methods that can correctly handle the conversion of angular velocities to linear velocities in km/s, taking into account the distance to the object. This likely involves using the distance to convert the angular motion to linear motion.\n\nGiven the complexity of the information and the specific nature of the user's question, it may be helpful to look for a method or function specifically designed to handle this conversion. Let's search for a method or function that can convert angular velocities to linear velocities given a distance. We can use the `Semantic Code Search` tool with a query like \"convert angular velocities to linear velocities given distance in astropy\". \n\nAction:\n```\n{\n  \"action\": \"Semantic Code Search\",\n  \"action_input\": {\n    \"tool_input\": \"convert angular velocities to linear velocities given distance in astropy\"\n  }\n}\n```\nObservation: ['\"\"\"\\n================================================================\\nConvert a radial velocity to the Galactic Standard of Rest (GSR)\\n================================================================', 'Radial or line-of-sight velocities of sources are often reported in a\\nHeliocentric or Solar-system barycentric reference frame. A common\\ntransformation incorporates the projection of the Sun\\'s motion along the\\nline-of-sight to the target, hence transforming it to a Galactic rest frame\\ninstead (sometimes referred to as the Galactic Standard of Rest, GSR). This\\ntransformation depends on the assumptions about the orientation of the Galactic\\nframe relative to the bary- or Heliocentric frame. It also depends on the\\nassumed solar velocity vector. Here we\\'ll demonstrate how to perform this\\ntransformation using a sky position and barycentric radial-velocity.\\n\\n\\n*By: Adrian Price-Whelan*\\n\\n*License: BSD*\\n\\n\\n\"\"\"', \"##############################################################################\\n# Import the necessary astropy subpackages\\n\\nimport astropy.coordinates as coord\\nimport astropy.units as u\\n\\n##############################################################################\\n# Let's first define a barycentric coordinate and velocity in the ICRS frame.\\n# We'll use the data for the star HD 39881 from the `Simbad\\n# <https://simbad.unistra.fr/simbad/>`_ database:\\n\\nc1 = coord.SkyCoord(ra=89.014303*u.degree, dec=13.924912*u.degree,\\n                    distance=(37.59*u.mas).to(u.pc, u.parallax()),\\n                    pm_ra_cosdec=372.72*u.mas/u.yr,\\n                    pm_dec=-483.69*u.mas/u.yr,\\n                    radial_velocity=0.37*u.km/u.s,\\n                    frame='icrs')\"]\nThought:", "system_response": "The `Semantic Code Search` returned an example of converting a radial velocity to the Galactic Standard of Rest (GSR), which is not exactly what we need. However, the example does demonstrate the use of `SkyCoord` with proper motion and radial velocity components, which is related to the user's question.\n\nThe user is specifically asking about converting angular velocities (`d_lon` and `d_lat`) to linear velocities in km/s, given a distance. The example provided by the search shows how to create a `SkyCoord` object with proper motion components (`pm_ra_cosdec` and `pm_dec`) and a radial velocity (`radial_velocity`), but it does not show how to convert angular velocities to linear velocities.\n\nSince the semantic search did not yield a direct method for the conversion, we should consider using the information we have to construct a response. We know that angular velocities can be converted to linear velocities using the formula `v = \u03c9 * r`, where `v` is the linear velocity, `\u03c9` is the angular velocity, and `r` is the radius (distance to the object). In the context of astropy, the distance is given as part of the `SkyCoord` object, and the angular velocities are the proper motion components (`pm_ra_cosdec` and `pm_dec`).\n\nGiven this, we can instruct the user to multiply the proper motion components by the distance to obtain the linear velocities in the plane of the sky. Since the user has already converted `d_distance` to km/s, they only need to apply this conversion to `d_lon` and `d_lat`.\n\nLet's provide the user with a response that explains how to perform this conversion using astropy units and the proper motion components from the `SkyCoord` object. \n\nThought: I will now construct a response for the user based on the information gathered and the known formula for converting angular velocities to linear velocities.\n\nAction:\n```\n{\n  \"action\": \"Final Answer\",\n  \"action_input\": \"To convert the angular velocities `d_lon` and `d_lat` to linear velocities in km/s, you can use the distance to the object along with the proper motion components from the `SkyCoord` object. The formula to convert angular velocity to linear velocity is `v = \u03c9 * r`, where `v` is the linear velocity, `\u03c9` is the angular velocity, and `r` is the radius (distance to the object).\\n\\nIn astropy, you can perform this conversion as follows:\\n\\n```\\n# Assuming `cgs` is your `SkyCoord` object with proper motion components and distance\\n# `pm_ra_cosdec` is the proper motion in right ascension, accounting for declination (d_lon)\\n# `pm_dec` is the proper motion in declination (d_lat)\\n# `distance` is the distance to the object\\n\\n# Convert proper motion from mas/yr to rad/yr\\npm_ra_rad = (cgs.pm_ra_cosdec.to(u.rad/u.yr, equivalencies=u.dimensionless_angles()))\\npm_dec_rad = (cgs.pm_dec.to(u.rad/u.yr, equivalencies=u.dimensionless_angles()))\\n\\n# Multiply by distance to get linear velocity in km/s\\nv_ra = (pm_ra_rad * cgs.distance).to(u.km/u.s, equivalencies=u.dimensionless_angles())\\nv_dec = (pm_dec_rad * cgs.distance).to(u.km/u.s, equivalencies=u.dimensionless_angles())\\n```\\n\\nThis will give you the linear velocities `v_ra` and `v_dec` in the plane of the sky in km/s. Note that these velocities are perpendicular to the line of sight. The radial velocity (along the line of sight) is already given in km/s and does not require conversion.\"\n}\n```"}