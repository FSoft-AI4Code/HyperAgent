| Tasks | Task Type | Motivation Concept | Input-Output | Evaluation Metrics | Collection Process | Examples |
| --- | --- | --- | --- | --- | --- | --- |
| Relevant Files Identification for Bug Localization From a Bug Report | Micro | Starting from a bug report, a software engineer needs to navigate inside the codebase to trace relevant information to solve the bug. The programmer needs to be able to understand the call graph as well as the connection between functions, methods to keep track on error trace. | Input: Bug Report - Output: files location and names | Hit@1, Hit@5 and Hit@10 (baselines are BugLocator with ~30% on Hit@1) | Starting from Birt and JDT (Top 1 and Top 5) https://www.semanticscholar.org/reader/1d7b3836ad61c30ccf5d59abd5ba6f095f6f8678 baselines: RLocator, BugLocator, FLIM (on 100% data top 1 accuracy is 25% and 35%) (top 5 is 41% and 61%) IR-based bug localization. |  |
| Refactorization Helping | Macro | In order to help the engineers with refactorization recommendation, the system needs to understand the relationship between classes to identify the scope of refactorization. | Input: Augmented Commit Message - Output: class names need to be refactored and refactorization strategies | Hit@1, Hit@5 for correct classes name and Accuracy for the refactorization strategies (baselines are taken from Khanh’s latest paper) | Github crawling the PRs which has commit message related to refactorization. Then augment this query as the query. Identify changed classes as the ground truths | I want to refactor I/O Registry module because of etc -Output: class A, class B and strategy is Skeleton |
| Imagine Execution | Micro | Software engineers are execptional good at predicting the expected intermediate values as well as the final value of some executions happened accross the project, therefore accquire better understanding about the data dependency aspect of the repository. | Input: Some argument values for a specific method or function inside the project - Output: The intermediate values as well as the final value | Exact Match for the results (haven’t found any baselines) | Collecting functions and methods that have long trace of computation, build the environment then execute with the generated input. | If the initial values of the class A are 1,3,8 and the arguments for the method A.add() is 1,2. What the results of the execution. |
| Code Change Recommendation For Requested Feature | Macro | Users usually add incremental adds-on for a new specific feature. The agent that understands well about the project, is able to recommend the possible changeable files by locating similar functionalities with the semantic of the request. | Input: New Feature Request Issue - Ouput: files name and functions, classes to be edited. | Hit@5 and Hit@10. (Baselines are LLM + sparse retrieval methods) | Taken from SWE-Bench | "what files i need to change to add a new tool to the Langchain’s agents”. |
| Locating Relevant Components for a specific functionality query | Macro | The project usually consists of multiple components and inside them, there are also many abstract concepts representing concrete, specific software units. The agent | Input: A functionality query - Output: related class name and function | Accuracy (Baselines are LLM + clustering, topic model) | Starting from documentation of the repository |  |
| Batch Test Geneartion For A Feature | Micro | After adding a new feature, the engineers will add new tests to ensure the new feature be able to function correctly. This is a tedious task, generating automatically these tests for a specific module, component or feature is desired. However, the feature is commonly located in multiple files and might have complex inter relationsip between functions, classes inside it. Therefore, this automatic process needs kind of global context and understand well the structure of the feature. | Input: feature request + new code - Output: Tests | Exact Match or BLEU | Taken instances with label of feature request from SWE-Bench, classify the new added tests as the ground truth labels and the added code as the part of the input. |  |