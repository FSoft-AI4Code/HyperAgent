{"issue_id": "MATH-338", "title": "Wrong parameter for first step size guess for Embedded Runge Kutta methods", "description": "\n<div class=\"user-content-block\">\n<p>In a space application using DOP853 i detected what seems to be a bad parameter in the call to the method  initializeStep of class AdaptiveStepsizeIntegrator.</p>\n<p>Here, DormandPrince853Integrator is a subclass for EmbeddedRungeKuttaIntegrator which perform the call to initializeStep at the beginning of its method integrate(...)</p>\n<p>The problem comes from the array \"scale\" that is used as a parameter in the call off initializeStep(..)</p>\n<p>Following the theory described by Hairer in his book \"Solving Ordinary Differential Equations 1 : Nonstiff Problems\", the scaling should be :</p>\n<p>sci = Atol i + |y0i| * Rtoli</p>\n<p>Whereas EmbeddedRungeKuttaIntegrator uses :  sci = Atoli</p>\n<p>Note that the Gragg-Bulirsch-Stoer integrator uses the good implementation \"sci = Atol i + |y0i| * Rtoli  \" when he performs the call to the same method initializeStep(..)</p>\n<p>In the method initializeStep, the error leads to a wrong step size h used to perform an  Euler step. Most of the time it is unvisible for the user.<br/>\nBut in my space application the Euler step with this wrong step size h (much bigger than it should be)  makes an exception occur (my satellite hits the ground...)</p>\n<p>To fix the bug, one should use the same algorithm as in the rescale method in GraggBulirschStoerIntegrator<br/>\nFor exemple :</p>\n<p> final double[] scale= new double<span class=\"error\">[y0.length]</span>;;</p>\n<p>          if (vecAbsoluteTolerance == null) {<br/>\n              for (int i = 0; i &lt; scale.length; ++i) </p>\n{\n                final double yi = Math.max(Math.abs(y0[i]), Math.abs(y0[i]));\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * yi;\n              }\n<p>            } else {<br/>\n              for (int i = 0; i &lt; scale.length; ++i) </p>\n{\n                final double yi = Math.max(Math.abs(y0[i]), Math.abs(y0[i]));\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yi;\n              }\n<p>            }</p>\n<p>          hNew = initializeStep(equations, forward, getOrder(), scale,<br/>\n                           stepStart, y, yDotK<span class=\"error\">[0]</span>, yTmp, yDotK<span class=\"error\">[1]</span>);</p>\n<p>Sorry for the length of this message, looking forward to hearing from you soon</p>\n<p>Vincent Morand</p>\n</div>\n"}