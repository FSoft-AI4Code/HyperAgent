{"issue_id": "LANG-315", "title": "StopWatch: suspend() acts as split(), if followed by stop()", "description": "\n<div class=\"user-content-block\">\n<p>In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:</p>\n<p>        StopWatch sw = new StopWatch();</p>\n<p>        sw.start();<br/>\n        Thread.sleep(1000);<br/>\n        sw.suspend();<br/>\n        // Time 1 (ok)<br/>\n        System.out.println(sw.getTime());</p>\n<p>        Thread.sleep(2000);<br/>\n        // Time 1 (again, ok)<br/>\n        System.out.println(sw.getTime());</p>\n<p>        sw.resume();<br/>\n        Thread.sleep(3000);<br/>\n        sw.suspend();<br/>\n        // Time 2 (ok)<br/>\n        System.out.println(sw.getTime());</p>\n<p>        Thread.sleep(4000);<br/>\n        // Time 2 (again, ok)<br/>\n        System.out.println(sw.getTime());</p>\n<p>        Thread.sleep(5000);<br/>\n        sw.stop();<br/>\n        // Time 2 (should be, but is Time 3 =&gt; NOT ok)<br/>\n        System.out.println(sw.getTime());</p>\n<p>suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?</p>\n</div>\n"}