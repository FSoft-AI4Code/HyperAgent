{"issue_id": "467", "title": "Unwanted POJO's embedded in tree via serialization to tree", "description": "\n<p dir=\"auto\">I have a class, more or less:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"   class X&lt;T&gt; {\n       String s;\n       List&lt;T&gt; items;\n  };\"><pre class=\"notranslate\"><code>   class X&lt;T&gt; {\n       String s;\n       List&lt;T&gt; items;\n  };\n</code></pre></div>\n<p dir=\"auto\">It has a custom serializer.</p>\n<p dir=\"auto\">When I serialize to a tree, the entire list ends up as a<br/>\nVALUE_EMBEDDED_OBJECT: the ArrayList itself.</p>\n<p dir=\"auto\">Here's the serializer class, note the use of writeObjectField.</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content='public class ListAttributeSerializer extends JsonSerializer&lt;ListAttribute&gt; {\n    @Override\n    public void serialize(ListAttribute value, JsonGenerator jgen,\nSerializerProvider provider) throws IOException {\n        jgen.writeStartObject();\n        jgen.writeStringField(\"itemType\", value.getItemJsonKey());\n        jgen.writeObjectField(\"items\", value.getItems());\n        jgen.writeEndObject();\n    }\n\n    @Override\n    public void serializeWithType(ListAttribute value, JsonGenerator\njgen, SerializerProvider provider, TypeSerializer typeSer) throws\nIOException {\n        typeSer.writeTypePrefixForObject(value, jgen);\n        jgen.writeStringField(\"itemType\", value.getItemJsonKey());\n        jgen.writeObjectField(\"items\", value.getItems());\n        typeSer.writeTypeSuffixForObject(value, jgen);\n}\n}'><pre class=\"notranslate\"><code>public class ListAttributeSerializer extends JsonSerializer&lt;ListAttribute&gt; {\n    @Override\n    public void serialize(ListAttribute value, JsonGenerator jgen,\nSerializerProvider provider) throws IOException {\n        jgen.writeStartObject();\n        jgen.writeStringField(\"itemType\", value.getItemJsonKey());\n        jgen.writeObjectField(\"items\", value.getItems());\n        jgen.writeEndObject();\n    }\n\n    @Override\n    public void serializeWithType(ListAttribute value, JsonGenerator\njgen, SerializerProvider provider, TypeSerializer typeSer) throws\nIOException {\n        typeSer.writeTypePrefixForObject(value, jgen);\n        jgen.writeStringField(\"itemType\", value.getItemJsonKey());\n        jgen.writeObjectField(\"items\", value.getItems());\n        typeSer.writeTypeSuffixForObject(value, jgen);\n}\n}\n</code></pre></div>\n<p dir=\"auto\">And Tatu wrote me:</p>\n<p dir=\"auto\">Ok. valueToTree() uses TokenBuffer as target, so it probably then simply retains Object passed as-is, to defer conversion/serialization, for common use case of buffering. But in your case you would rather get actual serialization into JsonNodes.</p>\n<p dir=\"auto\">You will probably want to write conversion out then, something like:</p>\n<p dir=\"auto\">byte[] json = mapper.writeValueAsBytes(referenceText);<br/>\nJsonNode tree = mapper.readTree(json);</p>\n<p dir=\"auto\">This is just the work-around on short term.<br/>\nBut this is one thing where configurability might be needed; or possibly different methods. One that forces full serialization into JSON with no POJONodes, other that leaves things as is.</p>\n"}