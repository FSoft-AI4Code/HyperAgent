{"issue_id": "MATH-639", "title": "numerical problems in rotation creation", "description": "\n<div class=\"user-content-block\">\n<p>building a rotation from the following vector pairs leads to NaN:<br/>\nu1 = -4921140.837095533, -2.1512094250440013E7, -890093.279426377<br/>\nu2 = -2.7238580938724895E9, -2.169664921341876E9, 6.749688708885301E10<br/>\nv1 = 1, 0, 0<br/>\nv2 = 0, 0, 1</p>\n<p>The constructor first changes the (v1, v2) pair into (v1', v2') ensuring the following scalar products hold:<br/>\n &lt;v1'|v1'&gt; == &lt;u1|u1&gt;<br/>\n &lt;v2'|v2'&gt; == &lt;u2|u2&gt;<br/>\n &lt;u1 |u2&gt;  == &lt;v1'|v2'&gt;</p>\n<p>Once the (v1', v2') pair has been computed, we compute the cross product:<br/>\n  k = (v1' - u1)^(v2' - u2)</p>\n<p>and the scalar product:<br/>\n  c = &lt;k | (u1^u2)&gt;</p>\n<p>By construction, c is positive or null and the quaternion axis we want to build is q = k/<span class=\"error\">[2*sqrt(c)]</span>.<br/>\nc should be null only if some of the vectors are aligned, and this is dealt with later in the algorithm.</p>\n<p>However, there are numerical problems with the vector above with the way these computations are done, as shown<br/>\nby the following comparisons, showing the result we get from our Java code and the result we get from manual<br/>\ncomputation with the same formulas but with enhanced precision:</p>\n<p>commons math:   k = 38514476.5,            -84.,                           -1168590144<br/>\nhigh precision: k = 38514410.36093388...,  -0.374075245201180409222711..., -1168590152.10599715208...</p>\n<p>and it becomes worse when computing c because the vectors are almost orthogonal to each other, hence inducing additional cancellations. We get:<br/>\ncommons math    c = -1.2397173627587605E20<br/>\nhigh precision: c =  558382746168463196.7079627...</p>\n<p>We have lost ALL significant digits in cancellations, and even the sign is wrong!</p>\n</div>\n"}