{"issue_id": "JXPATH-68", "title": "StackOverflow error on a call to 'JXPathContext.createPath()'", "description": "\n<div class=\"user-content-block\">\n<p>I'm running into a StackOverflow error on a call to<br/>\n'JXPathContext.createPath()' whenever I have a path that looks like<br/>\n'a/b<span class=\"error\">[1]</span>/c'.  I took a quick look at the code and it appears JXPath, when<br/>\ntrying to create its parent pointer, simply recreates an equivalent<br/>\npointer(???).</p>\n<p>Here is code to reproduce the problem.</p>\n<p>    Map map = new HashMap();<br/>\n    map.put(\"a\", null);</p>\n<p>    JXPathContext pathContext = JXPathContext.newContext(map);<br/>\n    pathContext.setFactory(new AbstractFactory() {<br/>\n      public boolean createObject(<br/>\n          JXPathContext context, Pointer pointer, Object parent, String<br/>\nname, int index) {</p>\n<p>        Map parentMap = (Map)parent;<br/>\n        System.out.println(parent + \":\" + name + \":\" + index);<br/>\n        if (index &gt; -1) {<br/>\n          List list = (List)parentMap.get(name);<br/>\n          if (list == null) </p>\n{\n            list = new ArrayList();\n          }<br/>\n          int size = list.size();<br/>\n          for (int i = size; i &lt;= index; i++) {\n            list.add(i, null);\n          }<br/>\n          parentMap.put(name, list);<br/>\n        } else {\n          parentMap.put(name, new HashMap());\n        }<br/>\n        return true;<br/>\n      }<br/>\n<br/>\n    });<br/>\n    pathContext.createPath(\"a/b<span class=\"error\">[1]</span>/c\");<br/>\n<br/>\n***************<br/>\n<br/>\nI have continued looking into this, and found that the problem is that, if<br/>\nthe List is created with a 'null' element, JXPath gets stuck in infinite<br/>\nrecursion.<br/>\n<br/>\nTo discover this, I changed my Factory to implement the following method:<br/>\n<br/>\n      public boolean createObject(<br/>\n          JXPathContext context, Pointer pointer, Object parent, <br/>\n          String name, int index) {<br/>\n<br/>\n        if (pointer instanceof NodePointer) {\n          index = ((NodePointer)pointer).getIndex();\n        }<br/>\n        System.out.println(parent + \":\" + name + \":\" + index);<br/>\n        Map parentMap = (Map)parent;<br/>\n        if (index &gt; -1) {<br/>\n          List list = (List)parentMap.get(name);<br/>\n          if (list == null) {            list = new ArrayList();          }\n<p>          int size = list.size();<br/>\n          for (int i = size; i &lt;= index; i++) </p>\n{\n            list.add(i, new HashMap());  // !!!!!!  Don't set to 'null'\n          }\n<p>          parentMap.put(name, list);<br/>\n        } else </p>\n{\n          parentMap.put(name, new HashMap());\n        }\n<p>        return true;<br/>\n      }</p>\n<p>Then I ran the following code:</p>\n<p>    pathContext.createPath(\"a/b<span class=\"error\">[1]</span>/c\");<br/>\n    pathContext.createPath(\"a/b<span class=\"error\">[2]</span>/c\");  // STACK OVERFLOW HERE</p>\n<p>Here is the stack trace at the beginning, where<br/>\n'ValueUtils.expandCollection()' is called.  It puts 'null' into the list,<br/>\nthus causing the stack overflow as we cycle between createPath() &amp;<br/>\ncreateChild().</p>\n<p>Thread <span class=\"error\">[main]</span> (Suspended (breakpoint at line 227 in DynamicPropertyPointer))<br/>\n\tDynamicPropertyPointer.createPath(JXPathContext) line: 227<br/>\n\tDynamicPropertyPointer(PropertyPointer).createChild(JXPathContext,<br/>\nQName, int) line: 188<br/>\n\tNullElementPointer.createPath(JXPathContext) line: 82<br/>\n\tNullPointer.createPath(JXPathContext) line: 86<br/>\n\tNullPropertyPointer.createPath(JXPathContext) line: 103<br/>\n\tNullPointer.createPath(JXPathContext) line: 86<br/>\n\tNullPropertyPointer.createPath(JXPathContext) line: 103<br/>\n\tJXPathContextReferenceImpl.createPath(String, Expression) line: 447<br/>\n\tJXPathContextReferenceImpl.createPath(String) line: 427<br/>\n\tTest.test4() line: 75<br/>\n\tTest.main(String[]) line: 38</p>\n</div>\n"}