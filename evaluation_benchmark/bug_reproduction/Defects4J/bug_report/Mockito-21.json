{"issue_id": "92", "title": "Allow convenient spying on abstract classes", "description": "\n<p dir=\"auto\">I posted this in GoogleCode and was asked to submit in github.</p>\n<p dir=\"auto\">Mockito is easy to use when the test needs to provide canned values for a certain method.</p>\n<p dir=\"auto\">But it gets harder when a canned value isn't sufficient.</p>\n<h5 dir=\"auto\">Example 1: Fake with trivial Logic</h5>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"interface UserAccount {\n  List&lt;String&gt; getEmails();\n  void addEmail(String email);\n  // 12 other methods ...\n}\"><pre class=\"notranslate\"><code>interface UserAccount {\n  List&lt;String&gt; getEmails();\n  void addEmail(String email);\n  // 12 other methods ...\n}\n</code></pre></div>\n<p dir=\"auto\">When mocking such domain entity object, it's tedious to manually program getEmails()/addEmail() with when().thenReturn() and to make sure the two methods are logically consistent, that is, getEmails() returns all emails added.</p>\n<h5 dir=\"auto\">Example 2: callback-style API</h5>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"interface AccountService {\n  void getAccount(String id, AsyncCallback&lt;UserAccount&gt; callback);\n}\"><pre class=\"notranslate\"><code>interface AccountService {\n  void getAccount(String id, AsyncCallback&lt;UserAccount&gt; callback);\n}\n</code></pre></div>\n<p dir=\"auto\">Stubbing AccountService isn't easy. It'd require use of Answer, and the Answer API isn't statically type safe:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"when(service.getAccount(eq(id), any(AsyncCallback.class)).thenAnswer(new Answer&lt;Void&gt;() {\n  AsyncCallback&lt;UserAccount&gt; callback = (AsyncCallback&lt;UserAccount&gt;) getArguments()[1];\n  ...\n});\"><pre class=\"notranslate\"><code>when(service.getAccount(eq(id), any(AsyncCallback.class)).thenAnswer(new Answer&lt;Void&gt;() {\n  AsyncCallback&lt;UserAccount&gt; callback = (AsyncCallback&lt;UserAccount&gt;) getArguments()[1];\n  ...\n});\n</code></pre></div>\n<h5 dir=\"auto\">Example 3: Uninteresting parameters</h5>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"interface AccountRpcService {\n  FutureAccount getAccount(RpcContext context, String id);\n}\"><pre class=\"notranslate\"><code>interface AccountRpcService {\n  FutureAccount getAccount(RpcContext context, String id);\n}\n</code></pre></div>\n<p dir=\"auto\">None of the tests care about the context object. It's an uninteresting parameter imposed by the framework.</p>\n<p dir=\"auto\">If AccountRpcService were directly mocked, all tests would have to use isA() to repetitively mention this uninteresting parameter, like this:</p>\n<p dir=\"auto\"><code class=\"notranslate\">when(service.getAccount(isA(RpcContext.class), eq(\"id\")).thenReturn(...);</code></p>\n<p dir=\"auto\">And all other parameters are required to be wrapped in eq().</p>\n<h4 dir=\"auto\">Proposal</h4>\n<p dir=\"auto\">I propose adding support for abstract classes to mockito to make it easier to deal with tests like above:</p>\n<h5 dir=\"auto\">For example 1</h5>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"abstract class FakeUserAccount implements UserAccount {\n  private final List&lt;String&gt; emails = new ArrayList&lt;&gt;();\n\n  @Override public void addEmail(String email) {\n    emails.add(email);\n  }\n  @Override List&lt;String&gt; getEmails() {\n    return ImmutableList.copyOf(emails);\n  }\n}\n\n@Fake private FakeUserAccount userAccount; // Mockito instantiates abstract class.\"><pre class=\"notranslate\"><code>abstract class FakeUserAccount implements UserAccount {\n  private final List&lt;String&gt; emails = new ArrayList&lt;&gt;();\n\n  @Override public void addEmail(String email) {\n    emails.add(email);\n  }\n  @Override List&lt;String&gt; getEmails() {\n    return ImmutableList.copyOf(emails);\n  }\n}\n\n@Fake private FakeUserAccount userAccount; // Mockito instantiates abstract class.\n</code></pre></div>\n<h5 dir=\"auto\">For example 2</h5>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content='abstract class MockAccountService implements AccountService {\n  @Override public void getAccount(String id, AsyncCallback&lt;UserAccount&gt; callback) {\n    callback.onSuccess(getAccount(id));\n  }\n  abstract UserAccount getAccount(String id);\n}\n\n@Fake private MockAccountService service;\n\n...\n\nwhen(service.getAccount(\"id\")).thenReturn(account);'><pre class=\"notranslate\"><code>abstract class MockAccountService implements AccountService {\n  @Override public void getAccount(String id, AsyncCallback&lt;UserAccount&gt; callback) {\n    callback.onSuccess(getAccount(id));\n  }\n  abstract UserAccount getAccount(String id);\n}\n\n@Fake private MockAccountService service;\n\n...\n\nwhen(service.getAccount(\"id\")).thenReturn(account);\n</code></pre></div>\n<h5 dir=\"auto\">For example 3</h5>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"abstract class MockAccountRpcService implements AccountRpcService {\n  @Override Future&lt;Account&gt; getAccount(RpcContext context, String id) {\n    checkNotNull(context);  // Common sanity test. Don't have to repeat it in tests.\n    return getAccount(id);\n  }\n\n  abstract Future&lt;Account&gt; getAccount(String id);\n}\n\n@Fake private MockAccountRpcService service;\n\nwhen(service.getAccount(&quot;id&quot;)).thenReturn(...);\"><pre class=\"notranslate\"><code>abstract class MockAccountRpcService implements AccountRpcService {\n  @Override Future&lt;Account&gt; getAccount(RpcContext context, String id) {\n    checkNotNull(context);  // Common sanity test. Don't have to repeat it in tests.\n    return getAccount(id);\n  }\n\n  abstract Future&lt;Account&gt; getAccount(String id);\n}\n\n@Fake private MockAccountRpcService service;\n\nwhen(service.getAccount(\"id\")).thenReturn(...);\n</code></pre></div>\n<p dir=\"auto\">My work place internally implemented a default Answer to support abstract classes. We found that the support of abstract classes helps us to avoid overusing mocks when we should be using fakes. And in situations like above we get cleaner test code.</p>\n<p dir=\"auto\">But because it's not integrated in the core Mockito, there are gotchas with our implementation (like, you can't have private/final methods in your fake).</p>\n<p dir=\"auto\">If the idea sounds okay to give a try, I'll volunteer to submit a patch.</p>\n<p dir=\"auto\">Thanks!</p>\n"}