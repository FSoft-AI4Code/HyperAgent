{"issue_id": "LANG-788", "title": "SerializationUtils throws ClassNotFoundException when cloning primitive classes", "description": "\n<div class=\"user-content-block\">\n<p>If a serializable object contains a reference to a primitive class, e.g. int.class or int[].class, the SerializationUtils throw a ClassNotFoundException when trying to clone that object.</p>\n<div class=\"preformatted panel\" style=\"border-width: 1px;\"><div class=\"preformattedContent panelContent\">\n<pre>import org.apache.commons.lang3.SerializationUtils;\nimport org.junit.Test;\n\n\npublic class SerializationUtilsTest {\n\n\t\n\t@Test\n\tpublic void primitiveTypeClassSerialization(){\n\t\tClass&lt;?&gt; primitiveType = int.class;\n\t\t\n\t\tClass&lt;?&gt; clone = SerializationUtils.clone(primitiveType);\n\t\tassertEquals(primitiveType, clone);\n\t}\n}\n</pre>\n</div></div>\n<p>The problem was already reported as a java bug <a class=\"external-link\" href=\"http://bugs.sun.com/view_bug.do?bug_id=4171142\" rel=\"nofollow noopener\" target=\"_blank\">http://bugs.sun.com/view_bug.do?bug_id=4171142</a> and ObjectInputStream is fixed since java version 1.4.<br/>\nThe SerializationUtils problem arises because the SerializationUtils internally use the ClassLoaderAwareObjectInputStream that overrides the ObjectInputStream's<br/>\nresoleClass method without delegating to the super method in case of a ClassNotFoundException.</p>\n<p>I understand the intention of the ClassLoaderAwareObjectInputStream, but this implementation should also implement a fallback to the original implementation.</p>\n<p>For example:</p>\n<div class=\"preformatted panel\" style=\"border-width: 1px;\"><div class=\"preformattedContent panelContent\">\n<pre>        protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n            String name = desc.getName();\n            try {\n                return Class.forName(name, false, classLoader);\n            } catch (ClassNotFoundException ex) {\n            \ttry {\n            \t     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n            \t} catch (Exception e) {\n\t\t     return super.resolveClass(desc);\n\t\t}\n            }\n        }\n</pre>\n</div></div>\n<p>Here is the code in ObjectInputStream that fixed the java bug.</p>\n<div class=\"preformatted panel\" style=\"border-width: 1px;\"><div class=\"preformattedContent panelContent\">\n<pre>    protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)\n\tthrows IOException, ClassNotFoundException\n    {\n\tString name = desc.getName();\n\ttry {\n\t    return Class.forName(name, false, latestUserDefinedLoader());\n\t} catch (ClassNotFoundException ex) {\n\t    Class cl = (Class) primClasses.get(name);\n\t    if (cl != null) {\n\t\treturn cl;\n\t    } else {\n\t\tthrow ex;\n\t    }\n\t}\n    }\n</pre>\n</div></div>\n</div>\n"}