{"issue_id": "88", "title": "Constructing invalid Partials", "description": "\n<p dir=\"auto\">Partials can be constructed by invoking a constructor <code class=\"notranslate\">Partial(DateTimeFieldType[], int[])</code> or by merging together a set of partials using <code class=\"notranslate\">with</code>, each constructed by calling <code class=\"notranslate\">Partial(DateTimeFieldType, int)</code>, e.g.:</p>\n<div class=\"highlight highlight-source-java notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Partial a = new Partial(new DateTimeFieldType[] { year(), hourOfDay() }, new int[] { 1, 1});\nPartial b = new Partial(year(), 1).with(hourOfDay(), 1);\nassert(a == b);\"><pre><span class=\"pl-smi\">Partial</span> <span class=\"pl-s1\">a</span> = <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Partial</span>(<span class=\"pl-k\">new</span> <span class=\"pl-smi\">DateTimeFieldType</span>[] { <span class=\"pl-en\">year</span>(), <span class=\"pl-en\">hourOfDay</span>() }, <span class=\"pl-k\">new</span> <span class=\"pl-smi\">int</span>[] { <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>});\n<span class=\"pl-smi\">Partial</span> <span class=\"pl-s1\">b</span> = <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Partial</span>(<span class=\"pl-en\">year</span>(), <span class=\"pl-c1\">1</span>).<span class=\"pl-en\">with</span>(<span class=\"pl-en\">hourOfDay</span>(), <span class=\"pl-c1\">1</span>);\n<span class=\"pl-k\">assert</span>(<span class=\"pl-s1\">a</span> == <span class=\"pl-s1\">b</span>);</pre></div>\n<p dir=\"auto\">However, the above doesn't work in all cases:</p>\n<div class=\"highlight highlight-source-java notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"new Partial(new DateTimeFieldType[] { clockhourOfDay(), hourOfDay() }, new int[] { 1, 1}); // throws Types array must not contain duplicate\nnew Partial(clockhourOfDay(), 1).with(hourOfDay(), 1); // #&lt;Partial [clockhourOfDay=1, hourOfDay=1]&gt;\"><pre><span class=\"pl-k\">new</span> <span class=\"pl-smi\">Partial</span>(<span class=\"pl-k\">new</span> <span class=\"pl-smi\">DateTimeFieldType</span>[] { <span class=\"pl-en\">clockhourOfDay</span>(), <span class=\"pl-en\">hourOfDay</span>() }, <span class=\"pl-k\">new</span> <span class=\"pl-smi\">int</span>[] { <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>}); <span class=\"pl-c\">// throws Types array must not contain duplicate</span>\n<span class=\"pl-k\">new</span> <span class=\"pl-smi\">Partial</span>(<span class=\"pl-en\">clockhourOfDay</span>(), <span class=\"pl-c1\">1</span>).<span class=\"pl-en\">with</span>(<span class=\"pl-en\">hourOfDay</span>(), <span class=\"pl-c1\">1</span>); <span class=\"pl-c\">// #&lt;Partial [clockhourOfDay=1, hourOfDay=1]&gt;</span></pre></div>\n<p dir=\"auto\">I suppose the Partials should not allow to be constructed in either case. Is that right?</p>\n<p dir=\"auto\">There's also a related issue (probably stems from the fact that the Partial is invalid):</p>\n<div class=\"highlight highlight-source-java notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"new Partial(clockhourOfDay(), 1).with(hourOfDay(), 1).isEqual(new Partial(hourOfDay() ,1).with(clockhourOfDay(), 1)) // throws objects must have matching field types\"><pre><span class=\"pl-k\">new</span> <span class=\"pl-smi\">Partial</span>(<span class=\"pl-en\">clockhourOfDay</span>(), <span class=\"pl-c1\">1</span>).<span class=\"pl-en\">with</span>(<span class=\"pl-en\">hourOfDay</span>(), <span class=\"pl-c1\">1</span>).<span class=\"pl-en\">isEqual</span>(<span class=\"pl-k\">new</span> <span class=\"pl-smi\">Partial</span>(<span class=\"pl-en\">hourOfDay</span>() ,<span class=\"pl-c1\">1</span>).<span class=\"pl-en\">with</span>(<span class=\"pl-en\">clockhourOfDay</span>(), <span class=\"pl-c1\">1</span>)) <span class=\"pl-c\">// throws objects must have matching field types</span></pre></div>\n"}