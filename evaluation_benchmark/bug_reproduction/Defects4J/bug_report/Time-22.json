{"issue_id": "113", "title": "#113 Duration.toPeriod with fixed time zones.\n\n<small>\n<a class=\"icon\" href=\"feed.rss\" rel=\"nofollow\" title=\"Follow this Ticket\"><i class=\"fa fa-rss\"></i></a>\n</small>\n", "description": "\n<div><div class=\"markdown_content\"><p>I have a question concerning the conversion of a Duration to Period. I'm not sure if this is a bug, or if there is a different way to do this.</p>\n<p>The basis of the problem, is that using Duration.toPeriod() uses the chronology of the default time zone to do the conversion. This can cause different results from a timezone with DST and one without. This can be reproduced easily with this test.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">//</span><span class=\"nt\">set</span> <span class=\"nt\">default</span> <span class=\"nt\">time</span> <span class=\"nt\">zone</span> <span class=\"nt\">with</span> <span class=\"nt\">this</span> <span class=\"nt\">argument</span> <span class=\"nt\">-Duser</span><span class=\"p\">.</span><span class=\"nc\">timezone</span><span class=\"o\">=</span><span class=\"s2\">\"GMT\"</span>\n<span class=\"nt\">public</span> <span class=\"nt\">void</span> <span class=\"nt\">testForJodaForum</span><span class=\"o\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"err\">System.out.println(\"</span><span class=\"n\">Timezone</span><span class=\"p\">:</span> <span class=\"s2\">\" + DateTimeZone.getDefault());</span>\n\n<span class=\"s2\">    //Duration of more than 24 hours</span>\n<span class=\"s2\">    Duration aDuration = new Duration(DateTimeConstants.MILLIS_PER_HOUR * 30 + DateTimeConstants.MILLIS_PER_MINUTE * 50</span>\n<span class=\"s2\">        + DateTimeConstants.MILLIS_PER_SECOND * 14);</span>\n\n<span class=\"s2\">    System.out.println(\"</span><span class=\"n\">Duration</span> <span class=\"n\">before</span><span class=\"o\">:</span> <span class=\"s2\">\" + aDuration);</span>\n<span class=\"s2\">    Period period = aDuration.toPeriod();</span>\n<span class=\"s2\">    System.out.println(\"</span><span class=\"n\">Period</span> <span class=\"n\">after</span><span class=\"o\">:</span> <span class=\"err\">\"</span> <span class=\"o\">+</span> <span class=\"n\">period</span><span class=\"p\">);</span>        \n<span class=\"p\">}</span>\n</pre></div>\n<p>A fixed time zone produces this output<br/>\nTimezone: Etc/GMT<br/>\nDuration before: PT111014S<br/>\nPeriod after: P1DT6H50M14S</p>\n<p>A DST time zone produces this output<br/>\nTimezone: America/Chicago<br/>\nDuration before: PT111014S<br/>\nPeriod after: PT30H50M14S</p>\n<p>In the joda code, Duration.toPeriod() uses a period constructor that takes the chronology, but null is passed in, so the chronology of the default time zone is used, which leads to this behavior.</p>\n<p>The javadoc of toPeriod() states that only precise fields of hours, minutes, seconds, and millis will be converted. But for a fixed timezone, days and weeks are also precise, which is stated in the javadoc for toPeriod(Chronology chrono). In our app, we need consistent behavior regardless of the default time zone, which is to have all the extra hours put into the hours bucket. Since Duration is supposed to be a 'time zone independent' length of time, I don't think we should have to do any chronology manipulation to get this to work.</p>\n<p>Any help is appreciated.</p>\n<p>Thanks,<br/>\nCameron</p></div></div>\n"}