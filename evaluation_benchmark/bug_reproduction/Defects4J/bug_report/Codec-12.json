{"issue_id": "CODEC-130", "title": "Base64InputStream.skip skips underlying stream, not output", "description": "\n<div class=\"user-content-block\">\n<p>Base64InputStream.skip() skips within underlying stream, leading to unexpected behaviour.</p>\n<p>The following code will reproduce the issue:</p>\n<p>@Test<br/>\npublic void testSkip() throws Throwable {<br/>\n    InputStream ins =<br/>\n            new ByteArrayInputStream(\"AAAA////\".getBytes(\"ISO-8859-1\"));//should decode to </p>\n{0, 0, 0, 255, 255, 255}\n<p>    Base64InputStream instance = new Base64InputStream(ins);<br/>\n    assertEquals(3L, instance.skip(3L)); //should skip 3 decoded characters, or 4 encoded characters<br/>\n    assertEquals(255, instance.read()); //Currently returns 3, as it is decoding \"A/\", not \"//\" <br/>\n}</p>\n<p>The following code, if added to Base64InputStream, or (BaseNCodecInputStream in the dev build) would resolve the issue:</p>\n<p>@Override<br/>\npublic long skip(long n) throws IOException {<br/>\n    //delegate to read()<br/>\n    long bytesRead = 0;<br/>\n    while ((bytesRead &lt; n) &amp;&amp; (read() != -1)) </p>\n{\n        bytesRead++;\n    }\n<p>    return bytesRead;<br/>\n}</p>\n<p>More efficient code may be possible.</p>\n</div>\n"}