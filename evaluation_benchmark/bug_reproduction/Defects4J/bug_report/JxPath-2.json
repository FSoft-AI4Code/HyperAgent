{"issue_id": "JXPATH-50", "title": "does not properly handle NodeSet returned by extension function", "description": "\n<div class=\"user-content-block\">\n<p>Per the documentation, my function is returning a BasicNodeSet containing zero<br/>\nor more pointers:</p>\n<p>  public static NodeSet observations(ExpressionContext context) {<br/>\n    // the cast below shouldn't break, as this is the only pointer type that<br/>\n    // makes sense in this context<br/>\n    List&lt;NodePointer&gt; ptrs = extractObservations(<br/>\n                                  (NodePointer)context.getContextNodePointer(), <br/>\n                                  new ArrayList&lt;NodePointer&gt;());<br/>\n    BasicNodeSet result = new BasicNodeSet();<br/>\n    for (NodePointer ptr : ptrs) </p>\n{\n      result.add(ptr);\n    }\n<p>    return result;<br/>\n  }</p>\n<p>However, if I call JXPathContext.selectNodes(\"ems:observations()\"), I'm getting<br/>\na single node containing the BasicNodeSet. I notice that there is a testcase for<br/>\nfunctions that return NodeSets, but that it uses expressions that actually<br/>\nreturn the children of the NodeSet (\"test:nodeSet()/name\").</p>\n<p>There appear to be two problems. First, Expression.iterate() and<br/>\nExpression.iteratePointers() do not correctly recognize a NodeSet as something<br/>\niterable. I've resolved this by reaching into the NodeSet and getting an<br/>\niterator over its pointers.</p>\n<p>Second, Expression.PointerIterator doesn't recognize when it already has a<br/>\npointer, and instead tries to wrap it in a new pointer. This ends up treating<br/>\nthe pointer as a bean.</p>\n<p>I've made these changes, and written a testcase that uses an unadorned NodeSet<br/>\nfunction. I also found a class that used a variable named \"enum\", and changed<br/>\nthis so that it would compile under 1.5.</p>\n<p>The patch is attached. It's relative to \"commons-jxpath-1.2\" (root of extract<br/>\ndirectory).</p>\n</div>\n"}